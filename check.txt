    Blocking waiting for file lock on build directory
    Checking proc-macro-nested v0.1.7
    Checking futures-util v0.3.17
    Checking futures-executor v0.3.17
    Checking futures v0.3.17
    Checking opentelemetry v0.16.0
    Checking tracing-opentelemetry v0.16.0
    Checking masts v0.1.0 (/home/hedge/src/dynahist_rust)
error[E0603]: struct `Bin` is private
 --> src/histograms/dynamic_histogram.rs:6:18
  |
6 | use crate::bins::Bin;
  |                  ^^^ private struct
  |
note: the struct `Bin` is defined here
 --> src/bins/mod.rs:5:1
  |
5 | struct Bin {}
  | ^^^^^^^^^^

error[E0603]: struct `Value` is private
  --> src/histograms/dynamic_histogram.rs:21:20
   |
21 | use crate::values::Value;
   |                    ^^^^^ private struct
   |
note: the struct `Value` is defined here
  --> src/values/mod.rs:4:1
   |
4  | struct Value {}
   | ^^^^^^^^^^^^

warning: unused `#[macro_use]` import
 --> src/lib.rs:5:1
  |
5 | #[macro_use]
  | ^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `crate::layouts::guess_layout::GuessLayout`
 --> src/layouts/custom_layout.rs:6:5
  |
6 | use crate::layouts::guess_layout::GuessLayout;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::layouts::Sketch`
 --> src/layouts/custom_layout.rs:7:5
  |
7 | use crate::layouts::Sketch;
  |     ^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::seriate::serialization::SeriateWrite`
 --> src/layouts/custom_layout.rs:9:5
  |
9 | use crate::seriate::serialization::SeriateWrite;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::seriate::deserialization::SeriateRead`
  --> src/layouts/custom_layout.rs:10:5
   |
10 | use crate::seriate::deserialization::SeriateRead;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::histograms::histogram::Histogram`
  --> src/layouts/custom_layout.rs:12:5
   |
12 | use crate::histograms::histogram::Histogram;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::layouts::custom_layout::CustomLayout`
 --> src/layouts/layout_serialization.rs:7:5
  |
7 | use crate::layouts::custom_layout::CustomLayout;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::layouts::log_linear_layout::LogLinearLayout`
  --> src/layouts/layout_serialization.rs:11:5
   |
11 | use crate::layouts::log_linear_layout::LogLinearLayout;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::layouts::log_optimal_layout::LogOptimalLayout`
  --> src/layouts/layout_serialization.rs:12:5
   |
12 | use crate::layouts::log_optimal_layout::LogOptimalLayout;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::layouts::log_quadratic_layout::LogQuadraticLayout`
  --> src/layouts/layout_serialization.rs:13:5
   |
13 | use crate::layouts::log_quadratic_layout::LogQuadraticLayout;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::layouts::open_telemetry_exponential_buckets_layout::OpenTelemetryExponentialBucketsLayout`
  --> src/layouts/layout_serialization.rs:14:5
   |
14 | use crate::layouts::open_telemetry_exponential_buckets_layout::OpenTelemetryExponentialBucketsLayout;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::seriate::deserialization::SeriateRead`
 --> src/layouts/layout_serialization_definition.rs:6:5
  |
6 | use crate::seriate::deserialization::SeriateRead;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::seriate::serialization::SeriateWrite`
 --> src/layouts/layout_serialization_definition.rs:7:5
  |
7 | use crate::seriate::serialization::SeriateWrite;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::layouts::layout::Layout`
 --> src/layouts/layout_serialization_definition.rs:9:5
  |
9 | use crate::layouts::layout::Layout;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::seriate::serialization::SeriateWrite`
  --> src/layouts/log_linear_layout.rs:12:5
   |
12 | use crate::seriate::serialization::SeriateWrite;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::seriate::deserialization::SeriateRead`
  --> src/layouts/log_linear_layout.rs:13:5
   |
13 | use crate::seriate::deserialization::SeriateRead;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::seriate::serialization::SeriateWrite`
  --> src/layouts/log_optimal_layout.rs:10:5
   |
10 | use crate::seriate::serialization::SeriateWrite;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::seriate::deserialization::SeriateRead`
  --> src/layouts/log_optimal_layout.rs:11:5
   |
11 | use crate::seriate::deserialization::SeriateRead;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::seriate::serialization::SeriateWrite`
  --> src/layouts/log_quadratic_layout.rs:11:5
   |
11 | use crate::seriate::serialization::SeriateWrite;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::seriate::deserialization::SeriateRead`
  --> src/layouts/log_quadratic_layout.rs:12:5
   |
12 | use crate::seriate::deserialization::SeriateRead;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unnecessary parentheses around `return` value
   --> src/layouts/log_quadratic_layout.rs:336:16
    |
336 |         return ((mantissa_plus1 - 1.0) * (5.0 - mantissa_plus1) + exponent_mul3);
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove these parentheses
    |
    = note: `#[warn(unused_parens)]` on by default

warning: unused import: `crate::seriate::deserialization::SeriateRead`
 --> src/layouts/open_telemetry_exponential_buckets_layout.rs:8:5
  |
8 | use crate::seriate::deserialization::SeriateRead;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::seriate::serialization::SeriateWrite`
 --> src/layouts/open_telemetry_exponential_buckets_layout.rs:9:5
  |
9 | use crate::seriate::serialization::SeriateWrite;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `bytes::Buf`
  --> src/seriate/mod.rs:21:5
   |
21 | use bytes::Buf;
   |     ^^^^^^^^^^

warning: unused import: `bytes::BufMut`
  --> src/seriate/mod.rs:22:5
   |
22 | use bytes::BufMut;
   |     ^^^^^^^^^^^^^

warning: unused import: `crate::quantiles::quantile_estimators::QuantileEstimator`
  --> src/histograms/abstract_histogram.rs:19:5
   |
19 | use crate::quantiles::quantile_estimators::QuantileEstimator;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::seriate::SeriateHistogram`
  --> src/histograms/histogram.rs:13:5
   |
13 | use crate::seriate::SeriateHistogram;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::layouts::layout::Layout`
  --> src/histograms/preprocessed_histogram.rs:15:5
   |
15 | use crate::layouts::layout::Layout;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::utilities::Algorithms`
  --> src/histograms/preprocessed_histogram.rs:18:5
   |
18 | use crate::utilities::Algorithms;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: trait objects without an explicit `dyn` are deprecated
   --> src/histograms/dynamic_histogram.rs:119:15
    |
119 |      type B = std::iter::Iterator<Item=Bin>; //placeholder
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `dyn`: `dyn std::iter::Iterator<Item=Bin>`
    |
    = note: `#[warn(bare_trait_objects)]` on by default
    = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!
    = note: for more information, see issue #80165 <https://github.com/rust-lang/rust/issues/80165>

warning: trait objects without an explicit `dyn` are deprecated
   --> src/histograms/dynamic_histogram.rs:120:15
    |
120 |      type V = std::iter::Iterator<Item=Value>; //placeholder
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `dyn`: `dyn std::iter::Iterator<Item=Value>`
    |
    = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!
    = note: for more information, see issue #80165 <https://github.com/rust-lang/rust/issues/80165>

error[E0599]: no method named `read` found for struct `SerializationReader` in the current scope
   --> src/layouts/layout_serialization.rs:146:46
    |
146 |         return Ok(definition.unwrap().reader.read(&data_input));
    |                                              ^^^^ method not found in `SerializationReader`
    |
   ::: src/seriate/deserialization.rs:24:1
    |
24  | pub struct SerializationReader{
    | ------------------------------ method `read` not found for this
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `read`, perhaps you need to implement one of them:
            candidate #1: `SeriateRead`
            candidate #2: `std::io::Read`

error[E0046]: not all trait items implemented, missing: `new`
  --> src/quantiles/quantile_estimators.rs:71:1
   |
71 | impl ValueEstimation for SciPyQuantileEstimator {}
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `new` in implementation
   |
  ::: src/values/value_estimation.rs:22:5
   |
22 |     fn new() -> Self;
   |     ----------------- `new` from trait

error[E0053]: method `read_from` has an incompatible type for trait
  --> src/sketches/data.rs:40:85
   |
40 |     fn read_from<R: std::io::Read>(buffer: &mut R, order: bytestream::ByteOrder) -> Result<Self, DynaHistError> {
   |                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |                                                                                     |
   |                                                                                     expected struct `std::io::Error`, found enum `DynaHistError`
   |                                                                                     help: change the output type to match the trait: `Result<DataInput, std::io::Error>`
   |
   = note: expected fn pointer `fn(&mut R, ByteOrder) -> Result<_, std::io::Error>`
              found fn pointer `fn(&mut R, ByteOrder) -> Result<_, DynaHistError>`

error[E0053]: method `write_to` has an incompatible type for trait
  --> src/sketches/data.rs:52:10
   |
52 |     ) -> Result<(), DynaHistError> {
   |          ^^^^^^^^^^^^^^^^^^^^^^^^^
   |          |
   |          expected struct `std::io::Error`, found enum `DynaHistError`
   |          help: change the output type to match the trait: `Result<(), std::io::Error>`
   |
   = note: expected fn pointer `fn(&DataOutput, &mut W, ByteOrder) -> Result<_, std::io::Error>`
              found fn pointer `fn(&DataOutput, &mut W, ByteOrder) -> Result<_, DynaHistError>`

error[E0271]: type mismatch resolving `<T as Iterator>::Item == T`
   --> src/histograms/abstract_histogram.rs:132:5
    |
124 | impl<T> IntoIterator for Quantiles<T>
    |      - this type parameter
...
132 |     type IntoIter = <T as std::iter::IntoIterator>::IntoIter;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found associated type
    |
   ::: /home/hedge/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/collect.rs:211:29
    |
211 |     type IntoIter: Iterator<Item = Self::Item>;
    |                             ----------------- required by this bound in `std::iter::IntoIterator::IntoIter`
    |
    = note: expected type parameter `T`
              found associated type `<T as Iterator>::Item`
help: consider further restricting type parameter `T`
    |
129 |     T: std::iter::Iterator, T: Iterator<Item = T>
    |                           ^^^^^^^^^^^^^^^^^^^^^^^

error[E0046]: not all trait items implemented, missing: `get_histogram`, `get_non_empty_index`
  --> src/histograms/abstract_mutable_histogram.rs:53:1
   |
53 | impl AbstractBin for BinCopyImpl {}
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `get_histogram`, `get_non_empty_index` in implementation
   |
  ::: src/bins/abstract_bin.rs:14:5
   |
14 |     fn get_histogram(&self) -> Self;
   |     -------------------------------- `get_histogram` from trait
...
54 |     fn get_non_empty_index(&self) -> i32 ;
   |     -------------------------------------- `get_non_empty_index` from trait

error[E0046]: not all trait items implemented, missing: `get_bin_count`, `get_lower_bound`, `get_upper_bound`, `get_less_count`, `get_greater_count`, `get_bin_index`, `is_underflow_bin`, `is_overflow_bin`
  --> src/histograms/abstract_mutable_histogram.rs:54:1
   |
54 | impl BinSketch for BinCopyImpl {}
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `get_bin_count`, `get_lower_bound`, `get_upper_bound`, `get_less_count`, `get_greater_count`, `get_bin_index`, `is_underflow_bin`, `is_overflow_bin` in implementation
   |
  ::: src/bins/bin.rs:10:5
   |
10 |     fn get_bin_count(&self) -> i64;
   |     ------------------------------- `get_bin_count` from trait
...
17 |     fn get_lower_bound(&self) -> f64;
   |     --------------------------------- `get_lower_bound` from trait
...
24 |     fn get_upper_bound(&self) -> f64;
   |     --------------------------------- `get_upper_bound` from trait
...
34 |     fn get_less_count(&self) -> i64;
   |     -------------------------------- `get_less_count` from trait
...
38 |     fn get_greater_count(&self) -> i64;
   |     ----------------------------------- `get_greater_count` from trait
...
42 |     fn get_bin_index(&self) -> i32;
   |     ------------------------------- `get_bin_index` from trait
...
58 |     fn is_underflow_bin(&self) -> bool;
   |     ----------------------------------- `is_underflow_bin` from trait
...
62 |     fn is_overflow_bin(&self) -> bool;
   |     ---------------------------------- `is_overflow_bin` from trait

error[E0609]: no field `histogram` on type `&abstract_mutable_histogram::BinCopyImpl`
  --> src/histograms/abstract_mutable_histogram.rs:65:21
   |
65 |         return self.histogram;
   |                     ^^^^^^^^^ unknown field
   |
   = note: available fields are: `bin_count`, `less_count`, `greater_count`, `bin_index`

error[E0609]: no field `histogram` on type `&abstract_mutable_histogram::BinIteratorImpl`
   --> src/histograms/abstract_mutable_histogram.rs:180:21
    |
180 |         return self.histogram;
    |                     ^^^^^^^^^ unknown field
    |
    = note: available fields are: `bin_index`, `less_count`, `greater_count`, `count`

error[E0046]: not all trait items implemented, missing: `L`, `B`, `Q`, `V`, `get_first_non_empty_bin`, `get_last_non_empty_bin`, `get_bin_by_rank`, `get_total_count`, `get_min`, `get_max`, `get_count`, `is_empty`, `get_value`, `get_value_from_estimator`, `get_preprocessed_copy`, `add_histogram`, `add_histogram_from_estimator`, `add_ascending_sequence`, `write`, `get_estimated_footprint_in_bytes`, `is_mutable`, `non_empty_bins_ascending`, `non_empty_bins_descending`
   --> src/histograms/fixed.rs:39:1
    |
39  |   impl Histogram for StaticHistogram {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `L`, `B`, `Q`, `V`, `get_first_non_empty_bin`, `get_last_non_empty_bin`, `get_bin_by_rank`, `get_total_count`, `get_min`, `get_max`, `get_count`, `is_empty`, `get_value`, `get_value_from_estimator`, `get_preprocessed_copy`, `add_histogram`, `add_histogram_from_estimator`, `add_ascending_sequence`, `write`, `get_estimated_footprint_in_bytes`, `is_mutable`, `non_empty_bins_ascending`, `non_empty_bins_descending` in implementation
    |
   ::: src/histograms/histogram.rs:21:5
    |
21  |       type L: Layout + Preconditions + Algorithms;
    |       -------------------------------------------- `L` from trait
22  |       type B: BinIterator + BinSketch + Iterator;
    |       ------------------------------------------- `B` from trait
23  |       type Q: QuantileEstimation;
    |       --------------------------- `Q` from trait
24  |       type V: ValueEstimation;
    |       ------------------------ `V` from trait
...
42  |       fn get_first_non_empty_bin(&self) -> &Self::B;
    |       ---------------------------------------------- `get_first_non_empty_bin` from trait
...
55  |       fn get_last_non_empty_bin(&self) -> &Self::B;
    |       --------------------------------------------- `get_last_non_empty_bin` from trait
...
68  |       fn get_bin_by_rank(&self, rank: i64) -> &Self::B;
    |       ------------------------------------------------- `get_bin_by_rank` from trait
...
105 |       fn get_total_count(&self) -> i64;
    |       --------------------------------- `get_total_count` from trait
...
111 |       fn get_min(&self) -> f64;
    |       ------------------------- `get_min` from trait
...
117 |       fn get_max(&self) -> f64;
    |       ------------------------- `get_max` from trait
...
122 |       fn get_count(&self, bin_index: i32) -> i64;
    |       ------------------------------------------- `get_count` from trait
...
126 |       fn is_empty(&self) -> bool;
    |       --------------------------- `is_empty` from trait
...
149 |       fn get_value(&self, rank: i64) -> f64;
    |       -------------------------------------- `get_value` from trait
...
173 |       fn get_value_from_estimator(&self, rank: i64, value_estimator: &Self::V) -> f64;
    |       -------------------------------------------------------------------------------- `get_value_from_estimator` from trait
...
184 |       fn get_preprocessed_copy(&self) -> Self;
    |       ---------------------------------------- `get_preprocessed_copy` from trait
...
256 |       fn add_histogram(&self, histogram: &Self) -> Self;
    |       -------------------------------------------------- `add_histogram` from trait
...
279 |       fn add_histogram_from_estimator(&self, histogram: &Self, value_estimator: &Self::V) -> Self;
    |       -------------------------------------------------------------------------------------------- `add_histogram_from_estimator` from trait
...
308 | /     fn add_ascending_sequence<F: Fn(i64) -> f64>(
309 | |         &self,
310 | |         ascending_sequence: &F,
311 | |         length: i64,
312 | |     ) -> Self;
    | |______________- `add_ascending_sequence` from trait
...
326 |       fn write(&self, data_output: &DataOutput) -> Result<(), std::rc::Rc<DynaHistError>>;
    |       ------------------------------------------------------------------------------------ `write` from trait
...
333 |       fn get_estimated_footprint_in_bytes(&self) -> i64;
    |       -------------------------------------------------- `get_estimated_footprint_in_bytes` from trait
...
340 |       fn is_mutable(&self) -> bool;
    |       ----------------------------- `is_mutable` from trait
...
441 |       fn non_empty_bins_ascending(&self) -> &Self::B;
    |       ----------------------------------------------- `non_empty_bins_ascending` from trait
...
445 |       fn non_empty_bins_descending(&self) -> &Self::B;
    |       ------------------------------------------------ `non_empty_bins_descending` from trait

error[E0046]: not all trait items implemented, missing: `H`, `B`, `V`
   --> src/histograms/fixed.rs:73:1
    |
73  | impl AbstractHistogram for StaticHistogram {}
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `H`, `B`, `V` in implementation
    |
   ::: src/histograms/abstract_histogram.rs:266:5
    |
266 |     type H: Histogram;
    |     ------------------ `H` from trait
267 |     type B: BinIterator + BinSketch + std::iter::Iterator;
    |     ------------------------------------------------------ `B` from trait
268 |     type V: ValueIterator + ValueSketch + std::iter::Iterator;
    |     ---------------------------------------------------------- `V` from trait

error[E0046]: not all trait items implemented, missing: `BIter`, `VIter`
   --> src/histograms/fixed.rs:76:1
    |
76  | impl AbstractMutableHistogram for StaticHistogram {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `BIter`, `VIter` in implementation
    |
   ::: src/histograms/abstract_mutable_histogram.rs:185:5
    |
185 |     type BIter: BinIterator + BinSketch + Iterator;
    |     ----------------------------------------------- `BIter` from trait
186 |     type VIter: ValueIterator + ValueSketch + Iterator;
    |     --------------------------------------------------- `VIter` from trait

error[E0046]: not all trait items implemented, missing: `get_lower_bound`, `get_upper_bound`, `is_underflow_bin`, `is_overflow_bin`
  --> src/histograms/preprocessed_histogram.rs:26:1
   |
26 | impl BinSketch for BinCopyImpl {
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `get_lower_bound`, `get_upper_bound`, `is_underflow_bin`, `is_overflow_bin` in implementation
   |
  ::: src/bins/bin.rs:17:5
   |
17 |     fn get_lower_bound(&self) -> f64;
   |     --------------------------------- `get_lower_bound` from trait
...
24 |     fn get_upper_bound(&self) -> f64;
   |     --------------------------------- `get_upper_bound` from trait
...
58 |     fn is_underflow_bin(&self) -> bool;
   |     ----------------------------------- `is_underflow_bin` from trait
...
62 |     fn is_overflow_bin(&self) -> bool;
   |     ---------------------------------- `is_overflow_bin` from trait

error[E0046]: not all trait items implemented, missing: `get_bin_count`, `get_lower_bound`, `get_upper_bound`, `get_less_count`, `get_greater_count`, `get_bin_index`, `is_underflow_bin`, `is_overflow_bin`
  --> src/histograms/preprocessed_histogram.rs:79:1
   |
79 | impl BinSketch for BinIteratorImpl {}
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `get_bin_count`, `get_lower_bound`, `get_upper_bound`, `get_less_count`, `get_greater_count`, `get_bin_index`, `is_underflow_bin`, `is_overflow_bin` in implementation
   |
  ::: src/bins/bin.rs:10:5
   |
10 |     fn get_bin_count(&self) -> i64;
   |     ------------------------------- `get_bin_count` from trait
...
17 |     fn get_lower_bound(&self) -> f64;
   |     --------------------------------- `get_lower_bound` from trait
...
24 |     fn get_upper_bound(&self) -> f64;
   |     --------------------------------- `get_upper_bound` from trait
...
34 |     fn get_less_count(&self) -> i64;
   |     -------------------------------- `get_less_count` from trait
...
38 |     fn get_greater_count(&self) -> i64;
   |     ----------------------------------- `get_greater_count` from trait
...
42 |     fn get_bin_index(&self) -> i32;
   |     ------------------------------- `get_bin_index` from trait
...
58 |     fn is_underflow_bin(&self) -> bool;
   |     ----------------------------------- `is_underflow_bin` from trait
...
62 |     fn is_overflow_bin(&self) -> bool;
   |     ---------------------------------- `is_overflow_bin` from trait

error[E0046]: not all trait items implemented, missing: `get_histogram`
  --> src/histograms/preprocessed_histogram.rs:80:1
   |
80 | impl AbstractBin for BinIteratorImpl {
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `get_histogram` in implementation
   |
  ::: src/bins/abstract_bin.rs:14:5
   |
14 |     fn get_histogram(&self) -> Self;
   |     -------------------------------- `get_histogram` from trait

error[E0046]: not all trait items implemented, missing: `B`
  --> src/histograms/preprocessed_histogram.rs:88:1
   |
88 | impl BinIterator for BinIteratorImpl {
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `B` in implementation
   |
  ::: src/bins/bin_iterator.rs:16:5
   |
16 |     type B: BinSketch;
   |     ------------------ `B` from trait

error[E0046]: not all trait items implemented, missing: `H`, `B`, `V`
   --> src/histograms/preprocessed_histogram.rs:118:1
    |
118 | impl AbstractHistogram for PreprocessedHistogram {}
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `H`, `B`, `V` in implementation
    |
   ::: src/histograms/abstract_histogram.rs:266:5
    |
266 |     type H: Histogram;
    |     ------------------ `H` from trait
267 |     type B: BinIterator + BinSketch + std::iter::Iterator;
    |     ------------------------------------------------------ `B` from trait
268 |     type V: ValueIterator + ValueSketch + std::iter::Iterator;
    |     ---------------------------------------------------------- `V` from trait

error[E0046]: not all trait items implemented, missing: `L`, `B`, `Q`, `V`, `get_first_non_empty_bin`, `get_last_non_empty_bin`, `get_bin_by_rank`, `get_total_count`, `get_min`, `get_max`, `get_count`, `is_empty`, `get_value`, `get_value_from_estimator`, `get_preprocessed_copy`, `add_values`, `add_histogram`, `add_histogram_from_estimator`, `add_ascending_sequence`, `write`, `get_estimated_footprint_in_bytes`, `is_mutable`, `non_empty_bins_ascending`, `non_empty_bins_descending`
   --> src/histograms/preprocessed_histogram.rs:120:1
    |
120 |   impl Histogram for PreprocessedHistogram {}
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `L`, `B`, `Q`, `V`, `get_first_non_empty_bin`, `get_last_non_empty_bin`, `get_bin_by_rank`, `get_total_count`, `get_min`, `get_max`, `get_count`, `is_empty`, `get_value`, `get_value_from_estimator`, `get_preprocessed_copy`, `add_values`, `add_histogram`, `add_histogram_from_estimator`, `add_ascending_sequence`, `write`, `get_estimated_footprint_in_bytes`, `is_mutable`, `non_empty_bins_ascending`, `non_empty_bins_descending` in implementation
    |
   ::: src/histograms/histogram.rs:21:5
    |
21  |       type L: Layout + Preconditions + Algorithms;
    |       -------------------------------------------- `L` from trait
22  |       type B: BinIterator + BinSketch + Iterator;
    |       ------------------------------------------- `B` from trait
23  |       type Q: QuantileEstimation;
    |       --------------------------- `Q` from trait
24  |       type V: ValueEstimation;
    |       ------------------------ `V` from trait
...
42  |       fn get_first_non_empty_bin(&self) -> &Self::B;
    |       ---------------------------------------------- `get_first_non_empty_bin` from trait
...
55  |       fn get_last_non_empty_bin(&self) -> &Self::B;
    |       --------------------------------------------- `get_last_non_empty_bin` from trait
...
68  |       fn get_bin_by_rank(&self, rank: i64) -> &Self::B;
    |       ------------------------------------------------- `get_bin_by_rank` from trait
...
105 |       fn get_total_count(&self) -> i64;
    |       --------------------------------- `get_total_count` from trait
...
111 |       fn get_min(&self) -> f64;
    |       ------------------------- `get_min` from trait
...
117 |       fn get_max(&self) -> f64;
    |       ------------------------- `get_max` from trait
...
122 |       fn get_count(&self, bin_index: i32) -> i64;
    |       ------------------------------------------- `get_count` from trait
...
126 |       fn is_empty(&self) -> bool;
    |       --------------------------- `is_empty` from trait
...
149 |       fn get_value(&self, rank: i64) -> f64;
    |       -------------------------------------- `get_value` from trait
...
173 |       fn get_value_from_estimator(&self, rank: i64, value_estimator: &Self::V) -> f64;
    |       -------------------------------------------------------------------------------- `get_value_from_estimator` from trait
...
184 |       fn get_preprocessed_copy(&self) -> Self;
    |       ---------------------------------------- `get_preprocessed_copy` from trait
...
233 |       fn add_values(&self, value: f64, count: i64) -> Self;
    |       ----------------------------------------------------- `add_values` from trait
...
256 |       fn add_histogram(&self, histogram: &Self) -> Self;
    |       -------------------------------------------------- `add_histogram` from trait
...
279 |       fn add_histogram_from_estimator(&self, histogram: &Self, value_estimator: &Self::V) -> Self;
    |       -------------------------------------------------------------------------------------------- `add_histogram_from_estimator` from trait
...
308 | /     fn add_ascending_sequence<F: Fn(i64) -> f64>(
309 | |         &self,
310 | |         ascending_sequence: &F,
311 | |         length: i64,
312 | |     ) -> Self;
    | |______________- `add_ascending_sequence` from trait
...
326 |       fn write(&self, data_output: &DataOutput) -> Result<(), std::rc::Rc<DynaHistError>>;
    |       ------------------------------------------------------------------------------------ `write` from trait
...
333 |       fn get_estimated_footprint_in_bytes(&self) -> i64;
    |       -------------------------------------------------- `get_estimated_footprint_in_bytes` from trait
...
340 |       fn is_mutable(&self) -> bool;
    |       ----------------------------- `is_mutable` from trait
...
441 |       fn non_empty_bins_ascending(&self) -> &Self::B;
    |       ----------------------------------------------- `non_empty_bins_ascending` from trait
...
445 |       fn non_empty_bins_descending(&self) -> &Self::B;
    |       ------------------------------------------------ `non_empty_bins_descending` from trait

error[E0308]: mismatched types
   --> src/histograms/preprocessed_histogram.rs:234:71
    |
234 |         return Err(DynaHistError::UnsupportedOperationError { source: "Not implemented" });
    |                                                                       ^^^^^^^^^^^^^^^^^ expected struct `std::io::Error`, found `&str`

error[E0277]: the trait bound `Result<_, DynaHistError>: Histogram` is not satisfied
   --> src/histograms/preprocessed_histogram.rs:233:56
    |
233 |     fn add_values(&self,  value: f64,   count: i64) -> impl Histogram {
    |                                                        ^^^^^^^^^^^^^^ the trait `Histogram` is not implemented for `Result<_, DynaHistError>`

error[E0308]: mismatched types
   --> src/histograms/preprocessed_histogram.rs:238:71
    |
238 |         return Err(DynaHistError::UnsupportedOperationError { source: "Not implemented" });
    |                                                                       ^^^^^^^^^^^^^^^^^ expected struct `std::io::Error`, found `&str`

error[E0277]: the trait bound `Result<_, DynaHistError>: Histogram` is not satisfied
   --> src/histograms/preprocessed_histogram.rs:237:41
    |
237 |     fn add_value(&self,  value: f64) -> impl Histogram {
    |                                         ^^^^^^^^^^^^^^ the trait `Histogram` is not implemented for `Result<_, DynaHistError>`

error[E0308]: mismatched types
   --> src/histograms/preprocessed_histogram.rs:242:71
    |
242 |         return Err(DynaHistError::UnsupportedOperationError { source: "Not implemented" });
    |                                                                       ^^^^^^^^^^^^^^^^^ expected struct `std::io::Error`, found `&str`

error[E0277]: the trait bound `Result<_, DynaHistError>: Histogram` is not satisfied
   --> src/histograms/preprocessed_histogram.rs:241:116
    |
241 |     fn add_histogram_from_estimator(&self,  histogram: impl Histogram,  value_estimator: &impl ValueEstimation) -> impl Histogram {
    |                                                                                                                    ^^^^^^^^^^^^^^ the trait `Histogram` is not implemented for `Result<_, DynaHistError>`

error[E0308]: mismatched types
   --> src/histograms/preprocessed_histogram.rs:246:71
    |
246 |         return Err(DynaHistError::UnsupportedOperationError { source: "Not implemented" });
    |                                                                       ^^^^^^^^^^^^^^^^^ expected struct `std::io::Error`, found `&str`

error[E0277]: the trait bound `Result<_, DynaHistError>: Histogram` is not satisfied
   --> src/histograms/preprocessed_histogram.rs:245:99
    |
245 |     fn add_ascending_sequence<F: Fn(i64) -> f64>(&self,  ascending_sequence: &F,  length: i64) -> impl Histogram {
    |                                                                                                   ^^^^^^^^^^^^^^ the trait `Histogram` is not implemented for `Result<_, DynaHistError>`

error[E0046]: not all trait items implemented, missing: `L`, `B`, `Q`, `V`, `get_first_non_empty_bin`, `get_last_non_empty_bin`, `get_bin_by_rank`, `get_total_count`, `get_min`, `get_max`, `get_count`, `is_empty`, `get_value`, `get_value_from_estimator`, `get_preprocessed_copy`, `add_values`, `add_histogram`, `add_histogram_from_estimator`, `add_ascending_sequence`, `write`, `get_estimated_footprint_in_bytes`, `is_mutable`, `non_empty_bins_ascending`, `non_empty_bins_descending`
   --> src/histograms/dynamic_histogram.rs:124:1
    |
124 |   impl Histogram for DynamicHistogram {}
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `L`, `B`, `Q`, `V`, `get_first_non_empty_bin`, `get_last_non_empty_bin`, `get_bin_by_rank`, `get_total_count`, `get_min`, `get_max`, `get_count`, `is_empty`, `get_value`, `get_value_from_estimator`, `get_preprocessed_copy`, `add_values`, `add_histogram`, `add_histogram_from_estimator`, `add_ascending_sequence`, `write`, `get_estimated_footprint_in_bytes`, `is_mutable`, `non_empty_bins_ascending`, `non_empty_bins_descending` in implementation
    |
   ::: src/histograms/histogram.rs:21:5
    |
21  |       type L: Layout + Preconditions + Algorithms;
    |       -------------------------------------------- `L` from trait
22  |       type B: BinIterator + BinSketch + Iterator;
    |       ------------------------------------------- `B` from trait
23  |       type Q: QuantileEstimation;
    |       --------------------------- `Q` from trait
24  |       type V: ValueEstimation;
    |       ------------------------ `V` from trait
...
42  |       fn get_first_non_empty_bin(&self) -> &Self::B;
    |       ---------------------------------------------- `get_first_non_empty_bin` from trait
...
55  |       fn get_last_non_empty_bin(&self) -> &Self::B;
    |       --------------------------------------------- `get_last_non_empty_bin` from trait
...
68  |       fn get_bin_by_rank(&self, rank: i64) -> &Self::B;
    |       ------------------------------------------------- `get_bin_by_rank` from trait
...
105 |       fn get_total_count(&self) -> i64;
    |       --------------------------------- `get_total_count` from trait
...
111 |       fn get_min(&self) -> f64;
    |       ------------------------- `get_min` from trait
...
117 |       fn get_max(&self) -> f64;
    |       ------------------------- `get_max` from trait
...
122 |       fn get_count(&self, bin_index: i32) -> i64;
    |       ------------------------------------------- `get_count` from trait
...
126 |       fn is_empty(&self) -> bool;
    |       --------------------------- `is_empty` from trait
...
149 |       fn get_value(&self, rank: i64) -> f64;
    |       -------------------------------------- `get_value` from trait
...
173 |       fn get_value_from_estimator(&self, rank: i64, value_estimator: &Self::V) -> f64;
    |       -------------------------------------------------------------------------------- `get_value_from_estimator` from trait
...
184 |       fn get_preprocessed_copy(&self) -> Self;
    |       ---------------------------------------- `get_preprocessed_copy` from trait
...
233 |       fn add_values(&self, value: f64, count: i64) -> Self;
    |       ----------------------------------------------------- `add_values` from trait
...
256 |       fn add_histogram(&self, histogram: &Self) -> Self;
    |       -------------------------------------------------- `add_histogram` from trait
...
279 |       fn add_histogram_from_estimator(&self, histogram: &Self, value_estimator: &Self::V) -> Self;
    |       -------------------------------------------------------------------------------------------- `add_histogram_from_estimator` from trait
...
308 | /     fn add_ascending_sequence<F: Fn(i64) -> f64>(
309 | |         &self,
310 | |         ascending_sequence: &F,
311 | |         length: i64,
312 | |     ) -> Self;
    | |______________- `add_ascending_sequence` from trait
...
326 |       fn write(&self, data_output: &DataOutput) -> Result<(), std::rc::Rc<DynaHistError>>;
    |       ------------------------------------------------------------------------------------ `write` from trait
...
333 |       fn get_estimated_footprint_in_bytes(&self) -> i64;
    |       -------------------------------------------------- `get_estimated_footprint_in_bytes` from trait
...
340 |       fn is_mutable(&self) -> bool;
    |       ----------------------------- `is_mutable` from trait
...
441 |       fn non_empty_bins_ascending(&self) -> &Self::B;
    |       ----------------------------------------------- `non_empty_bins_ascending` from trait
...
445 |       fn non_empty_bins_descending(&self) -> &Self::B;
    |       ------------------------------------------------ `non_empty_bins_descending` from trait

error[E0186]: method `get_count` has a `&self` declaration in the trait, but not in the impl
   --> src/histograms/dynamic_histogram.rs:127:5
    |
127 |     fn get_count(counts: &Vec<i64>, relative_idx: i32, mode: i8) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&self` in impl
    |
   ::: src/histograms/abstract_mutable_histogram.rs:286:5
    |
286 |     fn get_count(&self, bin_index: i32) -> i64 {
    |     ------------------------------------------ `&self` used in trait

error[E0049]: method `add_histogram_from_estimator` has 2 type parameters but its trait declaration has 1 type parameter
   --> src/histograms/dynamic_histogram.rs:267:20
    |
267 |         histogram: impl Histogram,
    |                    ^^^^^^^^^^^^^^
    |                    |
    |                    found 2 type parameters
    |                    `impl Trait` introduces an implicit type parameter
268 |         value_estimator: impl ValueEstimation,
    |                          ^^^^^^^^^^^^^^^^^^^^ `impl Trait` introduces an implicit type parameter
    |
   ::: src/histograms/abstract_mutable_histogram.rs:221:26
    |
221 |         value_estimator: impl ValueEstimation,
    |                          --------------------
    |                          |
    |                          expected 1 type parameter
    |                          `impl Trait` introduces an implicit type parameter

error[E0046]: not all trait items implemented, missing: `BIter`, `VIter`
   --> src/histograms/dynamic_histogram.rs:126:1
    |
126 | impl AbstractMutableHistogram for DynamicHistogram {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `BIter`, `VIter` in implementation
    |
   ::: src/histograms/abstract_mutable_histogram.rs:185:5
    |
185 |     type BIter: BinIterator + BinSketch + Iterator;
    |     ----------------------------------------------- `BIter` from trait
186 |     type VIter: ValueIterator + ValueSketch + Iterator;
    |     --------------------------------------------------- `VIter` from trait

error[E0308]: mismatched types
  --> src/utilities/tests/layout.rs:22:17
   |
22 |     fn new() -> LayoutTestUtil {}
   |        ---      ^^^^^^^^^^^^^^ expected struct `LayoutTestUtil`, found `()`
   |        |
   |        implicitly returns `()` as its body has no tail or `return` expression

error[E0308]: mismatched types
  --> src/utilities/tests/layout.rs:59:36
   |
59 |         let over_flow_index: i32 = layout.get_underflow_bin_index();
   |                              ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
   |                              |
   |                              expected due to this
   |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
   |
59 |         let over_flow_index: i32 = layout.get_underflow_bin_index().try_into().unwrap();
   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/utilities/tests/layout.rs:60:30
   |
60 |         let check = value >= over_flow_index;
   |                              ^^^^^^^^^^^^^^^ expected `usize`, found `i32`
   |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
   |
60 |         let check = value >= over_flow_index.try_into().unwrap();
   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/utilities/tests/layout.rs:77:41
   |
77 |             &layout.get_bin_lower_bound(&layout.get_underflow_bin_index()),
   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&usize`
   |
help: consider removing the borrow
   |
77 |             &layout.get_bin_lower_bound(layout.get_underflow_bin_index()),
   |                                        --

error[E0308]: mismatched types
  --> src/utilities/tests/layout.rs:81:41
   |
81 |             &layout.get_bin_lower_bound(&layout.get_underflow_bin_index()),
   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&usize`
   |
help: consider removing the borrow
   |
81 |             &layout.get_bin_lower_bound(layout.get_underflow_bin_index()),
   |                                        --

error[E0308]: mismatched types
  --> src/utilities/tests/layout.rs:82:41
   |
82 |             &layout.get_bin_lower_bound(i32::MIN)
   |                                         ^^^^^^^^ expected `usize`, found `i32`
   |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
   |
82 |             &layout.get_bin_lower_bound(i32::MIN.try_into().unwrap())
   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/utilities/tests/layout.rs:85:41
   |
85 |             &layout.get_bin_upper_bound(&layout.get_underflow_bin_index()),
   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&usize`
   |
help: consider removing the borrow
   |
85 |             &layout.get_bin_upper_bound(layout.get_underflow_bin_index()),
   |                                        --

error[E0308]: mismatched types
  --> src/utilities/tests/layout.rs:89:41
   |
89 |             &layout.get_bin_upper_bound(&layout.get_underflow_bin_index()),
   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&usize`
   |
help: consider removing the borrow
   |
89 |             &layout.get_bin_upper_bound(layout.get_underflow_bin_index()),
   |                                        --

error[E0308]: mismatched types
  --> src/utilities/tests/layout.rs:90:41
   |
90 |             &layout.get_bin_upper_bound(i32::MIN)
   |                                         ^^^^^^^^ expected `usize`, found `i32`
   |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
   |
90 |             &layout.get_bin_upper_bound(i32::MIN.try_into().unwrap())
   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/utilities/tests/layout.rs:93:41
   |
93 |             &layout.get_bin_lower_bound(&layout.get_overflow_bin_index()),
   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&usize`
   |
help: consider removing the borrow
   |
93 |             &layout.get_bin_lower_bound(layout.get_overflow_bin_index()),
   |                                        --

error[E0308]: mismatched types
  --> src/utilities/tests/layout.rs:97:41
   |
97 |             &layout.get_bin_lower_bound(&layout.get_overflow_bin_index()),
   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&usize`
   |
help: consider removing the borrow
   |
97 |             &layout.get_bin_lower_bound(layout.get_overflow_bin_index()),
   |                                        --

error[E0308]: mismatched types
  --> src/utilities/tests/layout.rs:98:41
   |
98 |             &layout.get_bin_lower_bound(i32::MAX)
   |                                         ^^^^^^^^ expected `usize`, found `i32`
   |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
   |
98 |             &layout.get_bin_lower_bound(i32::MAX.try_into().unwrap())
   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:101:41
    |
101 |             &layout.get_bin_upper_bound(&layout.get_overflow_bin_index()),
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&usize`
    |
help: consider removing the borrow
    |
101 |             &layout.get_bin_upper_bound(layout.get_overflow_bin_index()),
    |                                        --

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:105:41
    |
105 |             &layout.get_bin_upper_bound(&layout.get_overflow_bin_index()),
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&usize`
    |
help: consider removing the borrow
    |
105 |             &layout.get_bin_upper_bound(layout.get_overflow_bin_index()),
    |                                        --

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:106:41
    |
106 |             &layout.get_bin_upper_bound(i32::MAX)
    |                                         ^^^^^^^^ expected `usize`, found `i32`
    |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
106 |             &layout.get_bin_upper_bound(i32::MAX.try_into().unwrap())
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:109:30
    |
109 |             let mut i: i32 = layout.get_underflow_bin_index();
    |                        ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |                        |
    |                        expected due to this
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
109 |             let mut i: i32 = layout.get_underflow_bin_index().try_into().unwrap();
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:110:24
    |
110 |             while i <= layout.get_overflow_bin_index() {
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
110 |             while i <= layout.get_overflow_bin_index().try_into().unwrap() {
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:112:71
    |
112 |                     let lower_bound: f64 = layout.get_bin_lower_bound(i);
    |                                                                       ^ expected `usize`, found `i32`
    |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
112 |                     let lower_bound: f64 = layout.get_bin_lower_bound(i.try_into().unwrap());
    |                                                                       ^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:113:29
    |
113 |                     if i == layout.get_underflow_bin_index() {
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
113 |                     if i == layout.get_underflow_bin_index().try_into().unwrap() {
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: the trait bound `i32: RelativeEq` is not satisfied
   --> src/utilities/tests/layout.rs:116:25
    |
116 |                         approx::relative_eq!(i, &layout.map_to_bin_index(lower_bound));
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `RelativeEq` is not implemented for `i32`
    |
   ::: /home/hedge/.cargo/registry/src/github.com-1ecc6299db9ec823/approx-0.5.0/src/lib.rs:259:8
    |
259 |     A: RelativeEq<B> + ?Sized,
    |        ------------- required by this bound in `Relative`
    |
    = note: this error originates in the macro `approx::relative_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `i32: RelativeEq` is not satisfied
   --> src/utilities/tests/layout.rs:116:25
    |
116 |                         approx::relative_eq!(i, &layout.map_to_bin_index(lower_bound));
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `RelativeEq` is not implemented for `i32`
    |
    = note: required because of the requirements on the impl of `Default` for `Relative<i32>`
note: required by `std::default::Default::default`
   --> /home/hedge/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/default.rs:116:5
    |
116 |     fn default() -> Self;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = note: this error originates in the macro `approx::relative_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `i32: RelativeEq` is not satisfied
   --> src/utilities/tests/layout.rs:116:25
    |
116 |                         approx::relative_eq!(i, &layout.map_to_bin_index(lower_bound));
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `RelativeEq` is not implemented for `i32`
    |
    = note: this error originates in the macro `approx::relative_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:116:25
    |
116 |                         approx::relative_eq!(i, &layout.map_to_bin_index(lower_bound));
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&usize`
    |
    = note: expected reference `&i32`
               found reference `&&usize`
    = note: this error originates in the macro `approx::relative_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `i32: RelativeEq` is not satisfied
   --> src/utilities/tests/layout.rs:117:25
    |
117 | /                         approx::relative_eq!(
118 | |                             i - 1,
119 | |                             &layout.map_to_bin_index(&float_next_after::NextAfter::next_after(
120 | |                                 lower_bound,
121 | |                                 f64::NEG_INFINITY
122 | |                             ))
123 | |                         );
    | |__________________________^ the trait `RelativeEq` is not implemented for `i32`
    |
   ::: /home/hedge/.cargo/registry/src/github.com-1ecc6299db9ec823/approx-0.5.0/src/lib.rs:259:8
    |
259 |       A: RelativeEq<B> + ?Sized,
    |          ------------- required by this bound in `Relative`
    |
    = note: this error originates in the macro `approx::relative_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `i32: RelativeEq` is not satisfied
   --> src/utilities/tests/layout.rs:117:25
    |
117 | /                         approx::relative_eq!(
118 | |                             i - 1,
119 | |                             &layout.map_to_bin_index(&float_next_after::NextAfter::next_after(
120 | |                                 lower_bound,
121 | |                                 f64::NEG_INFINITY
122 | |                             ))
123 | |                         );
    | |__________________________^ the trait `RelativeEq` is not implemented for `i32`
    |
    = note: required because of the requirements on the impl of `Default` for `Relative<i32>`
note: required by `std::default::Default::default`
   --> /home/hedge/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/default.rs:116:5
    |
116 |     fn default() -> Self;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = note: this error originates in the macro `approx::relative_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `i32: RelativeEq` is not satisfied
   --> src/utilities/tests/layout.rs:117:25
    |
117 | /                         approx::relative_eq!(
118 | |                             i - 1,
119 | |                             &layout.map_to_bin_index(&float_next_after::NextAfter::next_after(
120 | |                                 lower_bound,
121 | |                                 f64::NEG_INFINITY
122 | |                             ))
123 | |                         );
    | |__________________________^ the trait `RelativeEq` is not implemented for `i32`
    |
    = note: this error originates in the macro `approx::relative_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:119:54
    |
119 |   ...                   &layout.map_to_bin_index(&float_next_after::NextAfter::next_after(
    |  ________________________________________________^
120 | | ...                       lower_bound,
121 | | ...                       f64::NEG_INFINITY
122 | | ...                   ))
    | |_______________________^ expected `f64`, found `&f64`
    |
help: consider removing the borrow
    |
119 |                             &layout.map_to_bin_index(float_next_after::NextAfter::next_after(
    |                                                     --

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:117:25
    |
117 | /                         approx::relative_eq!(
118 | |                             i - 1,
119 | |                             &layout.map_to_bin_index(&float_next_after::NextAfter::next_after(
120 | |                                 lower_bound,
121 | |                                 f64::NEG_INFINITY
122 | |                             ))
123 | |                         );
    | |__________________________^ expected `i32`, found `&usize`
    |
    = note: expected reference `&i32`
               found reference `&&usize`
    = note: this error originates in the macro `approx::relative_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:125:71
    |
125 |                     let upper_bound: f64 = layout.get_bin_upper_bound(i);
    |                                                                       ^ expected `usize`, found `i32`
    |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
125 |                     let upper_bound: f64 = layout.get_bin_upper_bound(i.try_into().unwrap());
    |                                                                       ^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:126:29
    |
126 |                     if i == layout.get_overflow_bin_index() {
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
126 |                     if i == layout.get_overflow_bin_index().try_into().unwrap() {
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:129:25
    |
129 |                         assert_eq!(i, &layout.map_to_bin_index(upper_bound));
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&usize`
    |
    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:132:54
    |
132 |   ...                   &layout.map_to_bin_index(&float_next_after::NextAfter::next_after(
    |  ________________________________________________^
133 | | ...                       upper_bound,
134 | | ...                       f64::INFINITY
135 | | ...                   ))
    | |_______________________^ expected `f64`, found `&f64`
    |
help: consider removing the borrow
    |
132 |                             &layout.map_to_bin_index(float_next_after::NextAfter::next_after(
    |                                                     --

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:130:25
    |
130 | /                         assert_eq!(
131 | |                             i + 1,
132 | |                             &layout.map_to_bin_index(&float_next_after::NextAfter::next_after(
133 | |                                 upper_bound,
134 | |                                 f64::INFINITY
135 | |                             ))
136 | |                         );
    | |__________________________^ expected `i32`, found `&usize`
    |
    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:153:13
    |
153 |             &layout.map_to_bin_index(f64::INFINITY)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&usize`
    |
help: consider removing the borrow
    |
153 |             layout.map_to_bin_index(f64::INFINITY)
    |            --

error[E0600]: cannot apply unary operator `!` to type `Arc<(Mutex<bool>, Condvar)>`
   --> src/utilities/tests/layout.rs:151:9
    |
151 | /         assert!(Self::valid_pos_inf_index(
152 | |             layout,
153 | |             &layout.map_to_bin_index(f64::INFINITY)
154 | |         ));
    | |___________^ cannot apply unary operator `!`
    |
    = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:158:13
    |
158 |             &layout.map_to_bin_index(SMALLEST_POSITIVE_NAN)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&usize`
    |
help: consider removing the borrow
    |
158 |             layout.map_to_bin_index(SMALLEST_POSITIVE_NAN)
    |            --

error[E0600]: cannot apply unary operator `!` to type `Arc<(Mutex<bool>, Condvar)>`
   --> src/utilities/tests/layout.rs:156:9
    |
156 | /         assert!(Self::valid_nan_index(
157 | |             layout,
158 | |             &layout.map_to_bin_index(SMALLEST_POSITIVE_NAN)
159 | |         ));
    | |___________^ cannot apply unary operator `!`
    |
    = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:162:13
    |
162 |             &layout.map_to_bin_index(f64::NAN)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&usize`
    |
help: consider removing the borrow
    |
162 |             layout.map_to_bin_index(f64::NAN)
    |            --

error[E0600]: cannot apply unary operator `!` to type `Arc<(Mutex<bool>, Condvar)>`
   --> src/utilities/tests/layout.rs:160:9
    |
160 | /         assert!(Self::valid_nan_index(
161 | |             layout,
162 | |             &layout.map_to_bin_index(f64::NAN)
163 | |         ));
    | |___________^ cannot apply unary operator `!`
    |
    = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:166:13
    |
166 |             &layout.map_to_bin_index(GREATEST_POSITIVE_NAN)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&usize`
    |
help: consider removing the borrow
    |
166 |             layout.map_to_bin_index(GREATEST_POSITIVE_NAN)
    |            --

error[E0600]: cannot apply unary operator `!` to type `Arc<(Mutex<bool>, Condvar)>`
   --> src/utilities/tests/layout.rs:164:9
    |
164 | /         assert!(Self::valid_nan_index(
165 | |             layout,
166 | |             &layout.map_to_bin_index(GREATEST_POSITIVE_NAN)
167 | |         ));
    | |___________^ cannot apply unary operator `!`
    |
    = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:170:13
    |
170 |             &layout.map_to_bin_index(f64::NEG_INFINITY)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&usize`
    |
help: consider removing the borrow
    |
170 |             layout.map_to_bin_index(f64::NEG_INFINITY)
    |            --

error[E0600]: cannot apply unary operator `!` to type `Arc<(Mutex<bool>, Condvar)>`
   --> src/utilities/tests/layout.rs:168:9
    |
168 | /         assert!(Self::valid_neg_inf_index(
169 | |             layout,
170 | |             &layout.map_to_bin_index(f64::NEG_INFINITY)
171 | |         ));
    | |___________^ cannot apply unary operator `!`
    |
    = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0061]: this function takes 1 argument but 0 arguments were supplied
   --> src/utilities/tests/layout.rs:174:21
    |
174 |             &layout.map_to_bin_index() & f64::from_bits(0xfff0000000000001)
    |                     ^^^^^^^^^^^^^^^^- supplied 0 arguments
    |                     |
    |                     expected 1 argument
    |
note: associated function defined here
   --> src/layouts/layout.rs:34:8
    |
34  |     fn map_to_bin_index(&self, value: f64) -> usize;
    |        ^^^^^^^^^^^^^^^^

error[E0277]: no implementation for `&usize & f64`
   --> src/utilities/tests/layout.rs:174:40
    |
174 |             &layout.map_to_bin_index() & f64::from_bits(0xfff0000000000001)
    |                                        ^ no implementation for `&usize & f64`
    |
    = help: the trait `BitAnd<f64>` is not implemented for `&usize`

error[E0600]: cannot apply unary operator `!` to type `Arc<(Mutex<bool>, Condvar)>`
   --> src/utilities/tests/layout.rs:172:9
    |
172 | /         assert!(Self::valid_nan_index(
173 | |             layout,
174 | |             &layout.map_to_bin_index() & f64::from_bits(0xfff0000000000001)
175 | |         ));
    | |___________^ cannot apply unary operator `!`
    |
    = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:178:38
    |
178 |             &layout.map_to_bin_index(&f64::from_bits(0xfff8000000000000))
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `&f64`
    |
help: consider removing the borrow
    |
178 |             &layout.map_to_bin_index(f64::from_bits(0xfff8000000000000))
    |                                     --

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:178:13
    |
178 |             &layout.map_to_bin_index(&f64::from_bits(0xfff8000000000000))
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&usize`
    |
help: consider removing the borrow
    |
178 |             layout.map_to_bin_index(&f64::from_bits(0xfff8000000000000))
    |            --

error[E0600]: cannot apply unary operator `!` to type `Arc<(Mutex<bool>, Condvar)>`
   --> src/utilities/tests/layout.rs:176:9
    |
176 | /         assert!(Self::valid_nan_index(
177 | |             layout,
178 | |             &layout.map_to_bin_index(&f64::from_bits(0xfff8000000000000))
179 | |         ));
    | |___________^ cannot apply unary operator `!`
    |
    = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:182:38
    |
182 |             &layout.map_to_bin_index(&f64::from_bits(0xffffffffffffffff))
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `&f64`
    |
help: consider removing the borrow
    |
182 |             &layout.map_to_bin_index(f64::from_bits(0xffffffffffffffff))
    |                                     --

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:182:13
    |
182 |             &layout.map_to_bin_index(&f64::from_bits(0xffffffffffffffff))
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&usize`
    |
help: consider removing the borrow
    |
182 |             layout.map_to_bin_index(&f64::from_bits(0xffffffffffffffff))
    |            --

error[E0600]: cannot apply unary operator `!` to type `Arc<(Mutex<bool>, Condvar)>`
   --> src/utilities/tests/layout.rs:180:9
    |
180 | /         assert!(Self::valid_nan_index(
181 | |             layout,
182 | |             &layout.map_to_bin_index(&f64::from_bits(0xffffffffffffffff))
183 | |         ));
    | |___________^ cannot apply unary operator `!`
    |
    = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0034]: multiple applicable items in scope
   --> src/utilities/tests/layout.rs:188:45
    |
188 |         let exact_lower_bound: f64 = layout.get_bin_lower_bound(bin_idx);
    |                                             ^^^^^^^^^^^^^^^^^^^ multiple `get_bin_lower_bound` found
    |
note: candidate #1 is defined in the trait `GuessLayout`
   --> src/layouts/guess_layout.rs:23:5
    |
23  |     fn get_bin_lower_bound(&self, bin_index: i32) -> f64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `layouts::layout::Layout`
   --> src/layouts/layout.rs:76:5
    |
76  |     fn get_bin_lower_bound(&self, bin_index: usize) -> f64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
188 |         let exact_lower_bound: f64 = GuessLayout::get_bin_lower_bound(layout, bin_idx);
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
188 |         let exact_lower_bound: f64 = layouts::layout::Layout::get_bin_lower_bound(layout, bin_idx);
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:195:17
    |
195 |                 approximate_lower_bound_long_representation,
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |                 |
    |                 expected reference, found `i64`
    |                 help: consider borrowing here: `&approximate_lower_bound_long_representation`
    |
    = note: expected reference `&_`
                    found type `i64`

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:196:17
    |
196 |                 exact_lower_bound_long_representation,
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |                 |
    |                 expected reference, found `i64`
    |                 help: consider borrowing here: `&exact_lower_bound_long_representation`
    |
    = note: expected reference `&_`
                    found type `i64`

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:194:13
    |
194 | /             num::CheckedSub::checked_sub(
195 | |                 approximate_lower_bound_long_representation,
196 | |                 exact_lower_bound_long_representation,
197 | |             ),
    | |_____________^ expected `i64`, found enum `Option`
    |
    = note: expected type `i64`
               found enum `Option<_>`

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:199:17
    |
199 |                 exact_lower_bound_long_representation,
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |                 |
    |                 expected reference, found `i64`
    |                 help: consider borrowing here: `&exact_lower_bound_long_representation`
    |
    = note: expected reference `&_`
                    found type `i64`

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:200:17
    |
200 |                 approximate_lower_bound_long_representation,
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |                 |
    |                 expected reference, found `i64`
    |                 help: consider borrowing here: `&approximate_lower_bound_long_representation`
    |
    = note: expected reference `&_`
                    found type `i64`

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:198:13
    |
198 | /             num::CheckedSub::checked_sub(
199 | |                 exact_lower_bound_long_representation,
200 | |                 approximate_lower_bound_long_representation,
201 | |             ),
    | |_____________^ expected `i64`, found enum `Option`
    |
    = note: expected type `i64`
               found enum `Option<_>`

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:209:48
    |
209 |         let int_stream: std::ops::Range<i32> = start..end;
    |                                                ^^^^^ expected `i32`, found `usize`

error[E0308]: mismatched types
   --> src/utilities/tests/layout.rs:209:55
    |
209 |         let int_stream: std::ops::Range<i32> = start..end;
    |                                                       ^^^ expected `i32`, found `usize`

error[E0599]: no method named `iter` found for struct `std::ops::Range` in the current scope
   --> src/utilities/tests/layout.rs:211:45
    |
211 |         let maxed: Option<u64> = int_stream.iter().map(|index| i64::into(index)).max();
    |                                             ^^^^ method not found in `std::ops::Range<i32>`

error[E0308]: mismatched types
  --> src/utilities/algorithms.rs:85:13
   |
85 |             f64::NAN.to_bits()
   |             ^^^^^^^^^^^^^^^^^^ expected `()`, found `u64`
   |
help: consider using a semicolon here
   |
85 |             f64::NAN.to_bits();
   |                               ^
help: try adding a return type
   |
83 |     fn to_bits_nan_collapse(x: f64) -> u64 {
   |                                     ^^^^^^

error[E0308]: mismatched types
  --> src/utilities/algorithms.rs:87:13
   |
87 |             x.to_bits()
   |             ^^^^^^^^^^^ expected `()`, found `u64`
   |
help: consider using a semicolon here
   |
87 |             x.to_bits();
   |                        ^
help: try adding a return type
   |
83 |     fn to_bits_nan_collapse(x: f64) -> u64 {
   |                                     ^^^^^^

error[E0308]: mismatched types
   --> src/utilities/algorithms.rs:130:22
    |
130 |         let l: i64 = x.to_bits();
    |                ---   ^^^^^^^^^^^ expected `i64`, found `u64`
    |                |
    |                expected due to this
    |
help: you can convert a `u64` to an `i64` and panic if the converted value doesn't fit
    |
130 |         let l: i64 = x.to_bits().try_into().unwrap();
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/utilities/algorithms.rs:144:31
    |
144 |         return f64::from_bits(((l >> 62) >> /* >>> */ 1) ^ l);
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `i64`
    |
help: you can convert an `i64` to a `u64` and panic if the converted value doesn't fit
    |
144 |         return f64::from_bits((((l >> 62) >> /* >>> */ 1) ^ l).try_into().unwrap());
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `eval` found for reference `&P` in the current scope
   --> src/utilities/algorithms.rs:173:26
    |
173 |             if predicate.eval(mid) {
    |                          ^^^^ method not found in `&P`
    |
    = note: `predicate` is a function, perhaps you wish to call it

error[E0599]: no method named `eval` found for reference `&P` in the current scope
   --> src/utilities/algorithms.rs:180:38
    |
180 |             high != max || predicate.eval(high),
    |                                      ^^^^ method not found in `&P`
    |
    = note: `predicate` is a function, perhaps you wish to call it

error[E0308]: mismatched types
   --> src/utilities/algorithms.rs:181:13
    |
181 |             &Self::INVALID_PREDICATE_MSG_FORMAT_STRING,
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`
    |
    = note: expected reference `&String`
               found reference `&&'static str`

error[E0599]: no method named `eval` found for reference `&P` in the current scope
   --> src/utilities/algorithms.rs:184:51
    |
184 |         if low == min && low != high && predicate.eval(min) {
    |                                                   ^^^^ method not found in `&P`
    |
    = note: `predicate` is a function, perhaps you wish to call it

error[E0308]: mismatched types
   --> src/utilities/algorithms.rs:243:25
    |
243 |                         &Self::INVALID_PREDICATE_MSG_FORMAT_STRING,
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`
    |
    = note: expected reference `&String`
               found reference `&&'static str`

error[E0599]: no method named `eval` found for type parameter `P` in the current scope
   --> src/utilities/algorithms.rs:259:26
    |
259 |             if predicate.eval(mid) {
    |                          ^^^^ method not found in `P`
    |
    = note: `predicate` is a function, perhaps you wish to call it

error[E0308]: mismatched types
   --> src/utilities/algorithms.rs:278:20
    |
276 |     fn clip(value: i32, min: i32, max: i32) -> Result<i32, DynaHistError> {
    |                                                -------------------------- expected `Result<i32, DynaHistError>` because of return type
277 |         if value >= min && value <= max {
278 |             return value;
    |                    ^^^^^
    |                    |
    |                    expected enum `Result`, found `i32`
    |                    help: try using a variant of the expected enum: `Ok(value)`
    |
    = note: expected enum `Result<i32, DynaHistError>`
               found type `i32`

error[E0308]: mismatched types
   --> src/utilities/algorithms.rs:281:62
    |
281 |             return Err(DynaHistError::IllegalArgumentError { source });
    |                                                              ^^^^^^ expected struct `std::io::Error`, found struct `String`

error[E0308]: mismatched types
  --> src/utilities/preconditions.rs:21:62
   |
21 |             return Err(DynaHistError::IllegalArgumentError { source });
   |                                                              ^^^^^^ expected struct `std::io::Error`, found `&str`

error[E0317]: `if` may be missing an `else` clause
  --> src/utilities/preconditions.rs:19:9
   |
19 | /         if !expression {
20 | |             let source = "Check argument failed";
21 | |             return Err(DynaHistError::IllegalArgumentError { source });
22 | |         }
   | |_________^ expected `()`, found enum `Result`
   |
   = note: expected unit type `()`
                   found enum `Result<bool, DynaHistError>`
   = note: `if` expressions without `else` evaluate to `()`
   = help: consider adding an `else` block that evaluates to the expected type

error[E0559]: variant `DynaHistError::IllegalArgumentError` has no field named `error_message`
  --> src/utilities/preconditions.rs:41:62
   |
41 |             return Err(DynaHistError::IllegalArgumentError { error_message });
   |                                                              ^^^^^^^^^^^^^ `DynaHistError::IllegalArgumentError` does not have this field
   |
   = note: available fields are: `source`

error[E0317]: `if` may be missing an `else` clause
  --> src/utilities/preconditions.rs:40:9
   |
40 | /         if !expression {
41 | |             return Err(DynaHistError::IllegalArgumentError { error_message });
42 | |         }
   | |_________^ expected `()`, found enum `Result`
   |
   = note: expected unit type `()`
                   found enum `Result<bool, DynaHistError>`
   = note: `if` expressions without `else` evaluate to `()`
   = help: consider adding an `else` block that evaluates to the expected type

error[E0277]: the trait bound `&str: From<i64>` is not satisfied
  --> src/utilities/preconditions.rs:70:74
   |
70 |             let source = error_message_format_string.replace("{}", value.into());
   |                                                                          ^^^^ the trait `From<i64>` is not implemented for `&str`
   |
   = help: the following implementations were found:
             <&'static str as From<&'_derivative_strum Sketch>>
             <&'static str as From<Sketch>>
   = note: required because of the requirements on the impl of `Into<&str>` for `i64`

error[E0308]: mismatched types
  --> src/utilities/preconditions.rs:75:62
   |
75 |             return Err(DynaHistError::IllegalArgumentError { source });
   |                                                              ^^^^^^ expected struct `std::io::Error`, found struct `String`

error[E0317]: `if` may be missing an `else` clause
  --> src/utilities/preconditions.rs:69:9
   |
69 | /         if !expression {
70 | |             let source = error_message_format_string.replace("{}", value.into());
71 | |             // From `stdlib`:
72 | |             // "The format functions provided by Rusts standard library do not
...  |
75 | |             return Err(DynaHistError::IllegalArgumentError { source });
76 | |         }
   | |_________^ expected `()`, found enum `Result`
   |
   = note: expected unit type `()`
                   found enum `Result<bool, DynaHistError>`
   = note: `if` expressions without `else` evaluate to `()`
   = help: consider adding an `else` block that evaluates to the expected type

error[E0599]: no method named `get_layout` found for type parameter `Self` in the current scope
  --> src/bins/abstract_bin.rs:29:61
   |
29 |         return self.get_bin_index() == self.get_histogram().get_layout().get_underflow_bin_index();
   |                                                             ^^^^^^^^^^ method not found in `Self`
   |
   = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following traits define an item `get_layout`, perhaps you need to add another supertrait for one of them:
   |
11 | pub trait AbstractBin: BinSketch + AbstractHistogram {
   |                                  ^^^^^^^^^^^^^^^^^^^
11 | pub trait AbstractBin: BinSketch + Histogram {
   |                                  ^^^^^^^^^^^

error[E0599]: no method named `get_layout` found for type parameter `Self` in the current scope
  --> src/bins/abstract_bin.rs:33:61
   |
33 |         return self.get_bin_index() == self.get_histogram().get_layout().get_overflow_bin_index();
   |                                                             ^^^^^^^^^^ method not found in `Self`
   |
   = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following traits define an item `get_layout`, perhaps you need to add another supertrait for one of them:
   |
11 | pub trait AbstractBin: BinSketch + AbstractHistogram {
   |                                  ^^^^^^^^^^^^^^^^^^^
11 | pub trait AbstractBin: BinSketch + Histogram {
   |                                  ^^^^^^^^^^^

error[E0599]: no method named `get_min` found for type parameter `Self` in the current scope
  --> src/bins/abstract_bin.rs:38:28
   |
38 |         let h1 = histogram.get_min();
   |                            ^^^^^^^ method not found in `Self`
   |
   = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following traits define an item `get_min`, perhaps you need to add another supertrait for one of them:
   |
11 | pub trait AbstractBin: BinSketch + AbstractMutableHistogram {
   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^
11 | pub trait AbstractBin: BinSketch + Histogram {
   |                                  ^^^^^^^^^^^

error[E0277]: the size for values of type `Self` cannot be known at compilation time
  --> src/bins/abstract_bin.rs:37:13
   |
37 |         let histogram = self.get_histogram();
   |             ^^^^^^^^^ doesn't have a size known at compile-time
   |
   = note: all local variables must have a statically known size
   = help: unsized locals are gated as an unstable feature
help: consider further restricting `Self`
   |
36 |     fn get_lower_bound(&self) -> f64 where Self: Sized {
   |                                      ^^^^^^^^^^^^^^^^^

error[E0599]: no method named `get_layout` found for type parameter `Self` in the current scope
  --> src/bins/abstract_bin.rs:40:14
   |
40 |             .get_layout()
   |              ^^^^^^^^^^ method not found in `Self`
   |
   = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following traits define an item `get_layout`, perhaps you need to add another supertrait for one of them:
   |
11 | pub trait AbstractBin: BinSketch + AbstractHistogram {
   |                                  ^^^^^^^^^^^^^^^^^^^
11 | pub trait AbstractBin: BinSketch + Histogram {
   |                                  ^^^^^^^^^^^

error[E0599]: no method named `get_max` found for type parameter `Self` in the current scope
  --> src/bins/abstract_bin.rs:47:28
   |
47 |         let h1 = histogram.get_max();
   |                            ^^^^^^^ method not found in `Self`
   |
   = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following traits define an item `get_max`, perhaps you need to add another supertrait for one of them:
   |
11 | pub trait AbstractBin: BinSketch + AbstractMutableHistogram {
   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^
11 | pub trait AbstractBin: BinSketch + Histogram {
   |                                  ^^^^^^^^^^^

error[E0277]: the size for values of type `Self` cannot be known at compilation time
  --> src/bins/abstract_bin.rs:46:13
   |
46 |         let histogram = self.get_histogram();
   |             ^^^^^^^^^ doesn't have a size known at compile-time
   |
   = note: all local variables must have a statically known size
   = help: unsized locals are gated as an unstable feature
help: consider further restricting `Self`
   |
45 |     fn get_upper_bound(&self) -> f64 where Self: Sized {
   |                                      ^^^^^^^^^^^^^^^^^

error[E0599]: no method named `get_layout` found for type parameter `Self` in the current scope
  --> src/bins/abstract_bin.rs:49:14
   |
49 |             .get_layout()
   |              ^^^^^^^^^^ method not found in `Self`
   |
   = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following traits define an item `get_layout`, perhaps you need to add another supertrait for one of them:
   |
11 | pub trait AbstractBin: BinSketch + AbstractHistogram {
   |                                  ^^^^^^^^^^^^^^^^^^^
11 | pub trait AbstractBin: BinSketch + Histogram {
   |                                  ^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/values/value_estimation.rs:41:13
   |
41 |             relative_rank - (bin.get_bin_count() - relative_rank - 1),
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `i64`
   |
help: you can convert an `i64` to an `f64`, producing the floating point representation of the integer, rounded if necessary
   |
41 |             (relative_rank - (bin.get_bin_count() - relative_rank - 1)) as f64,
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/values/value_estimation.rs:42:13
   |
42 |             -bin.get_bin_count() + (if bin.is_first_non_empty_bin() { 1 } else { 0 }),
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `i64`
   |
help: you can convert an `i64` to an `f64`, producing the floating point representation of the integer, rounded if necessary
   |
42 |             (-bin.get_bin_count() + (if bin.is_first_non_empty_bin() { 1 } else { 0 })) as f64,
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/values/value_estimation.rs:43:13
   |
43 |             &bin.get_lower_bound(),
   |             ^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `&f64`
   |
help: consider removing the borrow
   |
43 |             bin.get_lower_bound(),
   |            --

error[E0308]: mismatched types
  --> src/values/value_estimation.rs:44:13
   |
44 |             bin.get_bin_count() - (if bin.is_last_non_empty_bin() { 1 } else { 0 }),
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `i64`
   |
help: you can convert an `i64` to an `f64`, producing the floating point representation of the integer, rounded if necessary
   |
44 |             (bin.get_bin_count() - (if bin.is_last_non_empty_bin() { 1 } else { 0 })) as f64,
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/values/value_estimation.rs:45:13
   |
45 |             &bin.get_upper_bound(),
   |             ^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `&f64`
   |
help: consider removing the borrow
   |
45 |             bin.get_upper_bound(),
   |            --

error[E0308]: mismatched types
  --> src/values/value_estimation.rs:88:13
   |
88 |             &bin.get_lower_bound(),
   |             ^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `&f64`
   |
help: consider removing the borrow
   |
88 |             bin.get_lower_bound(),
   |            --

error[E0277]: the trait bound `f64: Ord` is not satisfied
    --> src/values/value_estimation.rs:87:16
     |
87   |         return std::cmp::max(
     |                ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`
     |
    ::: /home/hedge/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1171:15
     |
1171 | pub fn max<T: Ord>(v1: T, v2: T) -> T {
     |               --- required by this bound in `std::cmp::max`

error[E0277]: the trait bound `f64: Ord` is not satisfied
    --> src/values/value_estimation.rs:89:14
     |
89   |             &std::cmp::min(
     |              ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`
     |
    ::: /home/hedge/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1108:15
     |
1108 | pub fn min<T: Ord>(v1: T, v2: T) -> T {
     |               --- required by this bound in `std::cmp::min`
     |
     = note: required because of the requirements on the impl of `Ord` for `&f64`

error[E0308]: mismatched types
  --> src/values/value_estimation.rs:91:17
   |
91 |                 (bin.get_lower_bound() + bin.get_upper_bound()) * 0.5,
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |                 |
   |                 expected `&f64`, found `f64`
   |                 help: consider borrowing here: `&((bin.get_lower_bound() + bin.get_upper_bound()) * 0.5)`

error[E0308]: mismatched types
  --> src/values/value_estimation.rs:89:13
   |
89 | /             &std::cmp::min(
90 | |                 &bin.get_upper_bound(),
91 | |                 (bin.get_lower_bound() + bin.get_upper_bound()) * 0.5,
92 | |             ),
   | |_____________^ expected `f64`, found `&&f64`

error[E0308]: mismatched types
   --> src/values/value_estimation.rs:123:34
    |
123 |         let bin: dyn BinSketch = histogram.get_bin_by_rank(rank);
    |                  -------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected trait object `dyn BinSketch`, found reference
    |                  |
    |                  expected due to this
    |
    = note: expected trait object `dyn BinSketch`
                  found reference `&<impl Histogram as Histogram>::B`

error[E0277]: the size for values of type `dyn BinSketch` cannot be known at compilation time
   --> src/values/value_estimation.rs:123:13
    |
123 |         let bin: dyn BinSketch = histogram.get_bin_by_rank(rank);
    |             ^^^ doesn't have a size known at compile-time
    |
    = help: the trait `Sized` is not implemented for `dyn BinSketch`
    = note: all local variables must have a statically known size
    = help: unsized locals are gated as an unstable feature

error[E0308]: mismatched types
   --> src/values/value_estimation.rs:124:43
    |
124 |         return self.get_estimate_from_bin(bin, rank);
    |                                           ^^^
    |                                           |
    |                                           expected reference, found trait object `dyn BinSketch`
    |                                           help: consider borrowing here: `&bin`
    |
    = note: expected reference `&_`
            found trait object `dyn BinSketch`

error[E0277]: the size for values of type `Self` cannot be known at compilation time
   --> src/values/value_estimation.rs:196:69
    |
189 |     fn as_type<'a, V: 'static, U: 'static>(x: &'a V) -> Option<&'a U> {
    |                                   ------- required by this bound in `ValueEstimation::as_type`
...
196 |         if let Some(_u) = Self::as_type::<_, ValueEstimatorUniform>(self) {
    |                                                                     ^^^^ doesn't have a size known at compile-time
    |
help: consider further restricting `Self`
    |
195 |     fn get_estimate_from_bin<'a, B: BinSketch>(&self, bin: &B, rank: i64) -> f64 where Self: Sized {
    |                                                                                  ^^^^^^^^^^^^^^^^^

error[E0277]: the size for values of type `Self` cannot be known at compilation time
   --> src/values/value_estimation.rs:199:79
    |
189 |     fn as_type<'a, V: 'static, U: 'static>(x: &'a V) -> Option<&'a U> {
    |                                   ------- required by this bound in `ValueEstimation::as_type`
...
199 |         } else if let Some(_l) = Self::as_type::<_, ValueEstimatorLowerBound>(self) {
    |                                                                               ^^^^ doesn't have a size known at compile-time
    |
help: consider further restricting `Self`
    |
195 |     fn get_estimate_from_bin<'a, B: BinSketch>(&self, bin: &B, rank: i64) -> f64 where Self: Sized {
    |                                                                                  ^^^^^^^^^^^^^^^^^

error[E0277]: the size for values of type `Self` cannot be known at compilation time
   --> src/values/value_estimation.rs:202:79
    |
189 |     fn as_type<'a, V: 'static, U: 'static>(x: &'a V) -> Option<&'a U> {
    |                                   ------- required by this bound in `ValueEstimation::as_type`
...
202 |         } else if let Some(_p) = Self::as_type::<_, ValueEstimatorUpperBound>(self) {
    |                                                                               ^^^^ doesn't have a size known at compile-time
    |
help: consider further restricting `Self`
    |
195 |     fn get_estimate_from_bin<'a, B: BinSketch>(&self, bin: &B, rank: i64) -> f64 where Self: Sized {
    |                                                                                  ^^^^^^^^^^^^^^^^^

error[E0277]: the size for values of type `Self` cannot be known at compilation time
   --> src/values/value_estimation.rs:205:77
    |
189 |     fn as_type<'a, V: 'static, U: 'static>(x: &'a V) -> Option<&'a U> {
    |                                   ------- required by this bound in `ValueEstimation::as_type`
...
205 |         } else if let Some(_m) = Self::as_type::<_, ValueEstimatorMidPoint>(self) {
    |                                                                             ^^^^ doesn't have a size known at compile-time
    |
help: consider further restricting `Self`
    |
195 |     fn get_estimate_from_bin<'a, B: BinSketch>(&self, bin: &B, rank: i64) -> f64 where Self: Sized {
    |                                                                                  ^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/values/value_estimation.rs:209:13
    |
209 |             tracing::info!("it's something we don't know")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `()`
    |
    = note: this error originates in the macro `$crate::event` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no method named `read_unsigned_byte` found for reference `&DataInput` in the current scope
  --> src/layouts/custom_layout.rs:31:73
   |
31 |         Self::check_serial_version(Self::SERIAL_VERSION_V0, &data_input.read_unsigned_byte());
   |                                                                         ^^^^^^^^^^^^^^^^^^ method not found in `&DataInput`

error[E0308]: mismatched types
  --> src/layouts/custom_layout.rs:32:24
   |
32 |         let len: i32 = Self::read_unsigned_var_int(&data_input);
   |                  ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found enum `Result`
   |                  |
   |                  expected due to this
   |
   = note: expected type `i32`
              found enum `Result<i32, Rc<DynaHistError>>`

error[E0308]: mismatched types
  --> src/layouts/custom_layout.rs:33:47
   |
33 |         let sorted_bin_boundaries = vec![0.0; len];
   |                                               ^^^ expected `usize`, found `i32`
   |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
   |
33 |         let sorted_bin_boundaries = vec![0.0; len.try_into().unwrap()];
   |                                               ^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `read_double` found for reference `&DataInput` in the current scope
  --> src/layouts/custom_layout.rs:38:59
   |
38 |                     sorted_bin_boundaries[i] = data_input.read_double();
   |                                                           ^^^^^^^^^^^ method not found in `&DataInput`

error[E0277]: the type `[{float}]` cannot be indexed by `i32`
  --> src/layouts/custom_layout.rs:38:21
   |
38 |                     sorted_bin_boundaries[i] = data_input.read_double();
   |                     ^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`
   |
   = help: the trait `SliceIndex<[{float}]>` is not implemented for `i32`
   = note: required because of the requirements on the impl of `Index<i32>` for `Vec<{float}>`

error[E0308]: mismatched types
  --> src/layouts/custom_layout.rs:44:37
   |
44 |         return Ok(CustomLayout::new(&sorted_bin_boundaries));
   |                                     ^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `&Vec<{float}>`
   |
   = note: expected struct `Vec<f64>`
           found reference `&Vec<{float}>`
help: consider removing the borrow
   |
44 |         return Ok(CustomLayout::new(sorted_bin_boundaries));
   |                                    --

error[E0599]: no method named `write_byte` found for reference `&DataOutput` in the current scope
  --> src/layouts/custom_layout.rs:48:21
   |
48 |         data_output.write_byte(Self::SERIAL_VERSION_V0);
   |                     ^^^^^^^^^^ method not found in `&DataOutput`

error[E0308]: mismatched types
  --> src/layouts/custom_layout.rs:49:38
   |
49 |         Self::write_unsigned_var_int(self.sorted_bin_boundaries.len(), &data_output);
   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
   |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
   |
49 |         Self::write_unsigned_var_int(self.sorted_bin_boundaries.len().try_into().unwrap(), &data_output);
   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `write_double` found for reference `&DataOutput` in the current scope
  --> src/layouts/custom_layout.rs:51:25
   |
51 |             data_output.write_double(boundary);
   |                         ^^^^^^^^^^^^ method not found in `&DataOutput`

error[E0599]: no method named `len` found for type `f64` in the current scope
  --> src/layouts/custom_layout.rs:72:52
   |
72 |         Self::check_argument(sorted_bin_boundaries.len() > 0);
   |                                                    ^^^ help: there is an associated function with a similar name: `ln`

error[E0608]: cannot index into a value of type `f64`
  --> src/layouts/custom_layout.rs:73:30
   |
73 |         Self::check_argument(sorted_bin_boundaries[0] > f64::NEG_INFINITY);
   |                              ^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `len` found for type `f64` in the current scope
  --> src/layouts/custom_layout.rs:76:45
   |
76 |             while i < sorted_bin_boundaries.len() {
   |                                             ^^^ help: there is an associated function with a similar name: `ln`

error[E0608]: cannot index into a value of type `f64`
  --> src/layouts/custom_layout.rs:79:50
   |
79 |                         Self::map_double_to_long(sorted_bin_boundaries[i - 1])
   |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0608]: cannot index into a value of type `f64`
  --> src/layouts/custom_layout.rs:80:56
   |
80 | ...                   < Self::map_double_to_long(sorted_bin_boundaries[i]),
   |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/layouts/custom_layout.rs:89:53
   |
89 |         return CustomLayout::new(Self::vec_to_array(sorted_bin_boundaries));
   |                                                     ^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `f64`
   |
   = note: expected struct `Vec<_>`
                found type `f64`

error[E0308]: mismatched types
  --> src/layouts/custom_layout.rs:89:34
   |
89 |         return CustomLayout::new(Self::vec_to_array(sorted_bin_boundaries));
   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`
   |                                  |
   |                                  expected struct `Vec`, found array
   |
   = note: expected struct `Vec<f64>`
               found array `[_; _]`

error[E0599]: no method named `try_into` found for struct `Vec<T>` in the current scope
   --> src/layouts/custom_layout.rs:100:11
    |
100 |         v.try_into().unwrap_or_else(|v: Vec<T>| {
    |           ^^^^^^^^ method not found in `Vec<T>`
    |
   ::: /home/hedge/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:397:8
    |
397 |     fn try_into(self) -> Result<T, Self::Error>;
    |        -------- the method is available for `Vec<T>` here
    |
    = help: items from traits can only be used if the trait is in scope
    = note: the following trait is implemented but not in scope; perhaps add a `use` for it:
            `use std::convert::TryInto;`

error[E0308]: mismatched types
   --> src/layouts/custom_layout.rs:110:16
    |
110 |         if let Some(value) = self.map_to_bin_index_detail(value, 0_f64, 0_f64, 0_i64, 0_f64) {
    |                ^^^^^^^^^^^   --------------------------------------------------------------- this expression has type `usize`
    |                |
    |                expected `usize`, found enum `Option`
    |
    = note: expected type `usize`
               found enum `Option<_>`

error[E0317]: `if` may be missing an `else` clause
   --> src/layouts/custom_layout.rs:110:9
    |
110 | /         if let Some(value) = self.map_to_bin_index_detail(value, 0_f64, 0_f64, 0_i64, 0_f64) {
111 | |             return value;
112 | |         }
    | |_________^ expected `()`, found `usize`
    |
    = note: `if` expressions without `else` evaluate to `()`
    = help: consider adding an `else` block that evaluates to the expected type

error[E0308]: mismatched types
   --> src/layouts/custom_layout.rs:123:26
    |
123 |         let predicate = |&x: usize| {
    |                          ^^--------
    |                          |   |
    |                          |   expected due to this
    |                          expected `usize`, found reference
    |                          help: did you mean `x`: `&usize`
    |
    = note:   expected type `usize`
            found reference `&_`

error[E0308]: mismatched types
   --> src/layouts/custom_layout.rs:127:33
    |
123 |           let predicate = |&x: usize| {
    |  _________________________-
124 | |             x == self.sorted_bin_boundaries.len()
125 | |                 || Self::map_double_to_long(self.sorted_bin_boundaries[x]) > mapped_value
126 | |         };
    | |_________- the found closure
127 |           return Self::find_first(predicate, 0, self.sorted_bin_boundaries.len());
    |                                   ^^^^^^^^^
    |                                   |
    |                                   expected reference, found closure
    |                                   help: consider borrowing here: `&predicate`
    |
    = note: expected reference `&_`
                 found closure `[closure@src/layouts/custom_layout.rs:123:25: 126:10]`

error[E0308]: mismatched types
   --> src/layouts/custom_layout.rs:127:47
    |
127 |         return Self::find_first(predicate, 0, self.sorted_bin_boundaries.len());
    |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i64`, found `usize`
    |
help: you can convert a `usize` to an `i64` and panic if the converted value doesn't fit
    |
127 |         return Self::find_first(predicate, 0, self.sorted_bin_boundaries.len().try_into().unwrap());
    |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/custom_layout.rs:127:16
    |
121 |     ) -> usize {
    |          ----- expected `usize` because of return type
...
127 |         return Self::find_first(predicate, 0, self.sorted_bin_boundaries.len());
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `i64`
    |
help: you can convert an `i64` to a `usize` and panic if the converted value doesn't fit
    |
127 |         return Self::find_first(predicate, 0, self.sorted_bin_boundaries.len()).try_into().unwrap();
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/layouts/guess_layout.rs:24:25
   |
24 |         if bin_index <= self.get_underflow_bin_index() {
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
   |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
   |
24 |         if bin_index <= self.get_underflow_bin_index().try_into().unwrap() {
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/layouts/guess_layout.rs:27:54
   |
27 |         let effective_bin_index: i32 = std::cmp::min(self.get_overflow_bin_index(), bin_index);
   |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
   |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
   |
27 |         let effective_bin_index: i32 = std::cmp::min(self.get_overflow_bin_index().try_into().unwrap(), bin_index);
   |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/layouts/guess_layout.rs:31:14
   |
31 |             |&x: i32| self.map_to_bin_index(self.map_long_to_double(x)) >= effective_bin_index;
   |              ^^------
   |              |   |
   |              |   expected due to this
   |              expected `i32`, found reference
   |              help: did you mean `x`: `&i32`
   |
   = note:   expected type `i32`
           found reference `&_`

error[E0599]: no method named `map_long_to_double` found for reference `&Self` in the current scope
   --> src/layouts/guess_layout.rs:31:50
    |
31  |             |&x: i32| self.map_to_bin_index(self.map_long_to_double(x)) >= effective_bin_index;
    |                                                  ^^^^^^^^^^^^^^^^^^ this is an associated function, not a method
    |
    = note: found the following associated functions; to be used as methods, functions must have a `self` parameter
note: the candidate is defined in the trait `Algorithms`
   --> src/utilities/algorithms.rs:142:5
    |
142 |     fn map_long_to_double(l: i64) -> f64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: use associated function syntax instead
    |
31  |             |&x: i32| self.map_to_bin_index(Self::map_long_to_double(x)) >= effective_bin_index;
    |                                             ^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for the candidate
    |
31  |             |&x: i32| self.map_to_bin_index(Algorithms::map_long_to_double(&self, x)) >= effective_bin_index;
    |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: the following trait defines an item `map_long_to_double`, perhaps you need to add another supertrait for it:
    |
19  | pub(crate) trait GuessLayout: Layout + Algorithms {
    |                                      ^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/layouts/guess_layout.rs:31:76
   |
31 |             |&x: i32| self.map_to_bin_index(self.map_long_to_double(x)) >= effective_bin_index;
   |                                                                            ^^^^^^^^^^^^^^^^^^^ expected `usize`, found `i32`
   |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
   |
31 |             |&x: i32| self.map_to_bin_index(self.map_long_to_double(x)) >= effective_bin_index.try_into().unwrap();
   |                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `find_first_guess` found for reference `&Self` in the current scope
   --> src/layouts/guess_layout.rs:32:26
    |
32  |         let first = self.find_first_guess(
    |                          ^^^^^^^^^^^^^^^^ this is an associated function, not a method
    |
    = note: found the following associated functions; to be used as methods, functions must have a `self` parameter
note: the candidate is defined in the trait `Algorithms`
   --> src/utilities/algorithms.rs:209:5
    |
209 | /     fn find_first_guess<P>(predicate: P, min: i64, max: i64, initial_guess: i64) -> i64
210 | |     where
211 | |         P: Fn(i64) -> bool,
    | |___________________________^
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: use associated function syntax instead
    |
32  |         let first = Self::find_first_guess(
    |                     ^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for the candidate
    |
32  |         let first = Algorithms::find_first_guess(&self, predicate, self.NEGATIVE_INFINITY_MAPPED_TO_LONG, self.POSITIVE_INFINITY_MAPPED_TO_LONG, self.map_double_to_long(approximate_bin_lower_bound));
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: the following trait defines an item `find_first_guess`, perhaps you need to add another supertrait for it:
    |
19  | pub(crate) trait GuessLayout: Layout + Algorithms {
    |                                      ^^^^^^^^^^^^

error[E0609]: no field `NEGATIVE_INFINITY_MAPPED_TO_LONG` on type `&Self`
  --> src/layouts/guess_layout.rs:34:18
   |
19 | / pub(crate) trait GuessLayout: Layout {
20 | |
21 | |     const LOG_MIN_VALUE: f64 = f64::MIN.ln();
22 | |
...  |
34 | |             self.NEGATIVE_INFINITY_MAPPED_TO_LONG,
   | |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...  |
69 | |     fn get_bin_lower_bound_approximation_helper(&self, idx: i32) -> f64;
70 | | }
   | |_- type parameter 'Self' declared here

error[E0609]: no field `POSITIVE_INFINITY_MAPPED_TO_LONG` on type `&Self`
  --> src/layouts/guess_layout.rs:35:18
   |
19 | / pub(crate) trait GuessLayout: Layout {
20 | |
21 | |     const LOG_MIN_VALUE: f64 = f64::MIN.ln();
22 | |
...  |
35 | |             self.POSITIVE_INFINITY_MAPPED_TO_LONG,
   | |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...  |
69 | |     fn get_bin_lower_bound_approximation_helper(&self, idx: i32) -> f64;
70 | | }
   | |_- type parameter 'Self' declared here

error[E0599]: no method named `map_double_to_long` found for reference `&Self` in the current scope
   --> src/layouts/guess_layout.rs:36:18
    |
36  |             self.map_double_to_long(approximate_bin_lower_bound),
    |                  ^^^^^^^^^^^^^^^^^^ this is an associated function, not a method
    |
    = note: found the following associated functions; to be used as methods, functions must have a `self` parameter
note: the candidate is defined in the trait `Algorithms`
   --> src/utilities/algorithms.rs:129:5
    |
129 |     fn map_double_to_long(x: f64) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: use associated function syntax instead
    |
36  |             Self::map_double_to_long(approximate_bin_lower_bound),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for the candidate
    |
36  |             Algorithms::map_double_to_long(&self, approximate_bin_lower_bound),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: the following trait defines an item `map_double_to_long`, perhaps you need to add another supertrait for it:
    |
19  | pub(crate) trait GuessLayout: Layout + Algorithms {
    |                                      ^^^^^^^^^^^^

error[E0599]: no method named `map_long_to_double` found for reference `&Self` in the current scope
   --> src/layouts/guess_layout.rs:38:21
    |
38  |         return self.map_long_to_double(first);
    |                     ^^^^^^^^^^^^^^^^^^ this is an associated function, not a method
    |
    = note: found the following associated functions; to be used as methods, functions must have a `self` parameter
note: the candidate is defined in the trait `Algorithms`
   --> src/utilities/algorithms.rs:142:5
    |
142 |     fn map_long_to_double(l: i64) -> f64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: use associated function syntax instead
    |
38  |         return Self::map_long_to_double(first);
    |                ^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for the candidate
    |
38  |         return Algorithms::map_long_to_double(&self, first);
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: the following trait defines an item `map_long_to_double`, perhaps you need to add another supertrait for it:
    |
19  | pub(crate) trait GuessLayout: Layout + Algorithms {
    |                                      ^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/layouts/guess_layout.rs:42:25
   |
42 |         if bin_index >= self.get_overflow_bin_index() {
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
   |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
   |
42 |         if bin_index >= self.get_overflow_bin_index().try_into().unwrap() {
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/layouts/guess_layout.rs:45:54
   |
45 |         let effective_bin_index: i32 = std::cmp::max(self.get_underflow_bin_index(), bin_index);
   |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
   |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
   |
45 |         let effective_bin_index: i32 = std::cmp::max(self.get_underflow_bin_index().try_into().unwrap(), bin_index);
   |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/layouts/guess_layout.rs:49:14
   |
49 |             |&x: i32| self.map_to_bin_index(self.map_long_to_double(x)) <= effective_bin_index;
   |              ^^------
   |              |   |
   |              |   expected due to this
   |              expected `i32`, found reference
   |              help: did you mean `x`: `&i32`
   |
   = note:   expected type `i32`
           found reference `&_`

error[E0599]: no method named `map_long_to_double` found for reference `&Self` in the current scope
   --> src/layouts/guess_layout.rs:49:50
    |
49  |             |&x: i32| self.map_to_bin_index(self.map_long_to_double(x)) <= effective_bin_index;
    |                                                  ^^^^^^^^^^^^^^^^^^ this is an associated function, not a method
    |
    = note: found the following associated functions; to be used as methods, functions must have a `self` parameter
note: the candidate is defined in the trait `Algorithms`
   --> src/utilities/algorithms.rs:142:5
    |
142 |     fn map_long_to_double(l: i64) -> f64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: use associated function syntax instead
    |
49  |             |&x: i32| self.map_to_bin_index(Self::map_long_to_double(x)) <= effective_bin_index;
    |                                             ^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for the candidate
    |
49  |             |&x: i32| self.map_to_bin_index(Algorithms::map_long_to_double(&self, x)) <= effective_bin_index;
    |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: the following trait defines an item `map_long_to_double`, perhaps you need to add another supertrait for it:
    |
19  | pub(crate) trait GuessLayout: Layout + Algorithms {
    |                                      ^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/layouts/guess_layout.rs:49:76
   |
49 |             |&x: i32| self.map_to_bin_index(self.map_long_to_double(x)) <= effective_bin_index;
   |                                                                            ^^^^^^^^^^^^^^^^^^^ expected `usize`, found `i32`
   |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
   |
49 |             |&x: i32| self.map_to_bin_index(self.map_long_to_double(x)) <= effective_bin_index.try_into().unwrap();
   |                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `find_first_guess` found for reference `&Self` in the current scope
   --> src/layouts/guess_layout.rs:50:26
    |
50  |         let first = self.find_first_guess(
    |                          ^^^^^^^^^^^^^^^^ this is an associated function, not a method
    |
    = note: found the following associated functions; to be used as methods, functions must have a `self` parameter
note: the candidate is defined in the trait `Algorithms`
   --> src/utilities/algorithms.rs:209:5
    |
209 | /     fn find_first_guess<P>(predicate: P, min: i64, max: i64, initial_guess: i64) -> i64
210 | |     where
211 | |         P: Fn(i64) -> bool,
    | |___________________________^
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: use associated function syntax instead
    |
50  |         let first = Self::find_first_guess(
    |                     ^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for the candidate
    |
50  |         let first = Algorithms::find_first_guess(&self, predicate, self.POSITIVE_INFINITY_MAPPED_TO_LONG, self.NEGATIVE_INFINITY_MAPPED_TO_LONG, self.map_double_to_long(approximate_bin_upper_bound));
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: the following trait defines an item `find_first_guess`, perhaps you need to add another supertrait for it:
    |
19  | pub(crate) trait GuessLayout: Layout + Algorithms {
    |                                      ^^^^^^^^^^^^

error[E0609]: no field `POSITIVE_INFINITY_MAPPED_TO_LONG` on type `&Self`
  --> src/layouts/guess_layout.rs:52:18
   |
19 | / pub(crate) trait GuessLayout: Layout {
20 | |
21 | |     const LOG_MIN_VALUE: f64 = f64::MIN.ln();
22 | |
...  |
52 | |             self.POSITIVE_INFINITY_MAPPED_TO_LONG,
   | |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...  |
69 | |     fn get_bin_lower_bound_approximation_helper(&self, idx: i32) -> f64;
70 | | }
   | |_- type parameter 'Self' declared here

error[E0609]: no field `NEGATIVE_INFINITY_MAPPED_TO_LONG` on type `&Self`
  --> src/layouts/guess_layout.rs:53:18
   |
19 | / pub(crate) trait GuessLayout: Layout {
20 | |
21 | |     const LOG_MIN_VALUE: f64 = f64::MIN.ln();
22 | |
...  |
53 | |             self.NEGATIVE_INFINITY_MAPPED_TO_LONG,
   | |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...  |
69 | |     fn get_bin_lower_bound_approximation_helper(&self, idx: i32) -> f64;
70 | | }
   | |_- type parameter 'Self' declared here

error[E0599]: no method named `map_double_to_long` found for reference `&Self` in the current scope
   --> src/layouts/guess_layout.rs:54:18
    |
54  |             self.map_double_to_long(approximate_bin_upper_bound),
    |                  ^^^^^^^^^^^^^^^^^^ this is an associated function, not a method
    |
    = note: found the following associated functions; to be used as methods, functions must have a `self` parameter
note: the candidate is defined in the trait `Algorithms`
   --> src/utilities/algorithms.rs:129:5
    |
129 |     fn map_double_to_long(x: f64) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: use associated function syntax instead
    |
54  |             Self::map_double_to_long(approximate_bin_upper_bound),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for the candidate
    |
54  |             Algorithms::map_double_to_long(&self, approximate_bin_upper_bound),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: the following trait defines an item `map_double_to_long`, perhaps you need to add another supertrait for it:
    |
19  | pub(crate) trait GuessLayout: Layout + Algorithms {
    |                                      ^^^^^^^^^^^^

error[E0599]: no method named `map_long_to_double` found for reference `&Self` in the current scope
   --> src/layouts/guess_layout.rs:56:21
    |
56  |         return self.map_long_to_double(first);
    |                     ^^^^^^^^^^^^^^^^^^ this is an associated function, not a method
    |
    = note: found the following associated functions; to be used as methods, functions must have a `self` parameter
note: the candidate is defined in the trait `Algorithms`
   --> src/utilities/algorithms.rs:142:5
    |
142 |     fn map_long_to_double(l: i64) -> f64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: use associated function syntax instead
    |
56  |         return Self::map_long_to_double(first);
    |                ^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for the candidate
    |
56  |         return Algorithms::map_long_to_double(&self, first);
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: the following trait defines an item `map_long_to_double`, perhaps you need to add another supertrait for it:
    |
19  | pub(crate) trait GuessLayout: Layout + Algorithms {
    |                                      ^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/layouts/layout.rs:80:54
   |
80 |         let effective_bin_index: i32 = std::cmp::min(&self.get_overflow_bin_index(), bin_index);
   |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&usize`

error[E0308]: mismatched types
  --> src/layouts/layout.rs:80:86
   |
80 |         let effective_bin_index: i32 = std::cmp::min(&self.get_overflow_bin_index(), bin_index);
   |                                                                                      ^^^^^^^^^ expected `i32`, found `usize`
   |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
   |
80 |         let effective_bin_index: i32 = std::cmp::min(&self.get_overflow_bin_index(), bin_index.try_into().unwrap());
   |                                                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/layouts/layout.rs:84:14
   |
84 |             |&x: i32| Self::map_to_bin_index(Self::map_long_to_double(x)) >= effective_bin_index;
   |              ^^------
   |              |   |
   |              |   expected due to this
   |              expected `i32`, found reference
   |              help: did you mean `x`: `&i32`
   |
   = note:   expected type `i32`
           found reference `&_`

error[E0061]: this function takes 2 arguments but 1 argument was supplied
  --> src/layouts/layout.rs:84:23
   |
84 |             |&x: i32| Self::map_to_bin_index(Self::map_long_to_double(x)) >= effective_bin_index;
   |                       ^^^^^^^^^^^^^^^^^^^^^^ --------------------------- supplied 1 argument
   |                       |
   |                       expected 2 arguments
   |
note: associated function defined here
  --> src/layouts/layout.rs:34:8
   |
34 |     fn map_to_bin_index(&self, value: f64) -> usize;
   |        ^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/layouts/layout.rs:84:78
   |
84 |             |&x: i32| Self::map_to_bin_index(Self::map_long_to_double(x)) >= effective_bin_index;
   |                                                                              ^^^^^^^^^^^^^^^^^^^ expected `usize`, found `i32`
   |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
   |
84 |             |&x: i32| Self::map_to_bin_index(Self::map_long_to_double(x)) >= effective_bin_index.try_into().unwrap();
   |                                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/layouts/layout.rs:86:13
   |
84 |             |&x: i32| Self::map_to_bin_index(Self::map_long_to_double(x)) >= effective_bin_index;
   |             ------------------------------------------------------------------------------------ the found closure
85 |         let first = Self::find_first(
86 |             predicate,
   |             ^^^^^^^^^
   |             |
   |             expected reference, found closure
   |             help: consider borrowing here: `&predicate`
   |
   = note: expected reference `&_`
                found closure `[closure@src/layouts/layout.rs:84:13: 84:97]`

error[E0308]: mismatched types
  --> src/layouts/layout.rs:87:13
   |
87 |             Self::NEGATIVE_INFINITY_MAPPED_TO_LONG,
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i64`, found `isize`
   |
help: you can convert an `isize` to an `i64` and panic if the converted value doesn't fit
   |
87 |             Self::NEGATIVE_INFINITY_MAPPED_TO_LONG.try_into().unwrap(),
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/layouts/layout.rs:88:13
   |
88 |             Self::POSITIVE_INFINITY_MAPPED_TO_LONG,
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i64`, found `isize`
   |
help: you can convert an `isize` to an `i64` and panic if the converted value doesn't fit
   |
88 |             Self::POSITIVE_INFINITY_MAPPED_TO_LONG.try_into().unwrap(),
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/layout.rs:110:54
    |
110 |         let effective_bin_index: i32 = std::cmp::max(&self.get_underflow_bin_index(), bin_index);
    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&usize`

error[E0308]: mismatched types
   --> src/layouts/layout.rs:110:87
    |
110 |         let effective_bin_index: i32 = std::cmp::max(&self.get_underflow_bin_index(), bin_index);
    |                                                                                       ^^^^^^^^^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
110 |         let effective_bin_index: i32 = std::cmp::max(&self.get_underflow_bin_index(), bin_index.try_into().unwrap());
    |                                                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/layout.rs:114:14
    |
114 |             |&x: i64| Self::map_to_bin_index(Self::map_long_to_double(x)) <= effective_bin_index;
    |              ^^------
    |              |   |
    |              |   expected due to this
    |              expected `i64`, found reference
    |              help: did you mean `x`: `&i64`
    |
    = note:   expected type `i64`
            found reference `&_`

error[E0061]: this function takes 2 arguments but 1 argument was supplied
   --> src/layouts/layout.rs:114:23
    |
114 |             |&x: i64| Self::map_to_bin_index(Self::map_long_to_double(x)) <= effective_bin_index;
    |                       ^^^^^^^^^^^^^^^^^^^^^^ --------------------------- supplied 1 argument
    |                       |
    |                       expected 2 arguments
    |
note: associated function defined here
   --> src/layouts/layout.rs:34:8
    |
34  |     fn map_to_bin_index(&self, value: f64) -> usize;
    |        ^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/layout.rs:114:78
    |
114 |             |&x: i64| Self::map_to_bin_index(Self::map_long_to_double(x)) <= effective_bin_index;
    |                                                                              ^^^^^^^^^^^^^^^^^^^ expected `usize`, found `i32`
    |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
114 |             |&x: i64| Self::map_to_bin_index(Self::map_long_to_double(x)) <= effective_bin_index.try_into().unwrap();
    |                                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/layout.rs:116:13
    |
114 |             |&x: i64| Self::map_to_bin_index(Self::map_long_to_double(x)) <= effective_bin_index;
    |             ------------------------------------------------------------------------------------ the found closure
115 |         let first = Self::find_first(
116 |             predicate,
    |             ^^^^^^^^^
    |             |
    |             expected reference, found closure
    |             help: consider borrowing here: `&predicate`
    |
    = note: expected reference `&_`
                 found closure `[closure@src/layouts/layout.rs:114:13: 114:97]`

error[E0308]: mismatched types
   --> src/layouts/layout.rs:117:13
    |
117 |             Self::POSITIVE_INFINITY_MAPPED_TO_LONG,
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i64`, found `isize`
    |
help: you can convert an `isize` to an `i64` and panic if the converted value doesn't fit
    |
117 |             Self::POSITIVE_INFINITY_MAPPED_TO_LONG.try_into().unwrap(),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/layout.rs:118:13
    |
118 |             Self::NEGATIVE_INFINITY_MAPPED_TO_LONG,
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i64`, found `isize`
    |
help: you can convert an `isize` to an `i64` and panic if the converted value doesn't fit
    |
118 |             Self::NEGATIVE_INFINITY_MAPPED_TO_LONG.try_into().unwrap(),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0624]: associated function `write` is private
   --> src/layouts/layout.rs:140:40
    |
140 |           return Ok(LayoutSerialization::write(self, data_output));
    |                                          ^^^^^ private associated function
    |
   ::: src/layouts/layout_serialization.rs:107:5
    |
107 | /     fn write(
108 | |         layout: impl Layout,
109 | |         data_output: impl bytes::BufMut,
110 | |     ) -> Result<(), std::rc::Rc<DynaHistError>> {
    | |_______________________________________________- private associated function defined here

error[E0277]: the trait bound `&Self: layouts::layout::Layout` is not satisfied
   --> src/layouts/layout.rs:140:19
    |
140 |         return Ok(LayoutSerialization::write(self, data_output));
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `layouts::layout::Layout` is not implemented for `&Self`
    |
   ::: src/layouts/layout_serialization.rs:107:8
    |
107 |     fn write(
    |        ----- required by a bound in this
108 |         layout: impl Layout,
    |                      ------ required by this bound in `LayoutSerialization::write`

error[E0277]: the trait bound `&DataOutput: BufMut` is not satisfied
   --> src/layouts/layout.rs:140:52
    |
140 |         return Ok(LayoutSerialization::write(self, data_output));
    |                                                    ^^^^^^^^^^^ the trait `BufMut` is not implemented for `&DataOutput`
    |
   ::: src/layouts/layout_serialization.rs:107:8
    |
107 |     fn write(
    |        ----- required by a bound in this
108 |         layout: impl Layout,
109 |         data_output: impl bytes::BufMut,
    |                           ------------- required by this bound in `LayoutSerialization::write`

error[E0308]: mismatched types
   --> src/layouts/layout.rs:140:19
    |
140 |         return Ok(LayoutSerialization::write(self, data_output));
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found enum `Result`
    |
    = note: expected unit type `()`
                    found enum `Result<(), Rc<DynaHistError>>`

error[E0624]: associated function `read` is private
   --> src/layouts/layout.rs:160:40
    |
160 |         return Ok(LayoutSerialization::read(data_input));
    |                                        ^^^^ private associated function
    |
   ::: src/layouts/layout_serialization.rs:136:5
    |
136 |     fn read(data_input: impl bytes::Buf) -> Result<impl Layout, std::rc::Rc<DynaHistError>> {
    |     --------------------------------------------------------------------------------------- private associated function defined here

error[E0277]: the trait bound `DataInput: Buf` is not satisfied
   --> src/layouts/layout.rs:160:45
    |
160 |         return Ok(LayoutSerialization::read(data_input));
    |                                             ^^^^^^^^^^ the trait `Buf` is not implemented for `DataInput`
    |
   ::: src/layouts/layout_serialization.rs:136:30
    |
136 |     fn read(data_input: impl bytes::Buf) -> Result<impl Layout, std::rc::Rc<DynaHistError>> {
    |                              ---------- required by this bound in `LayoutSerialization::read`

error[E0308]: mismatched types
   --> src/layouts/layout.rs:160:19
    |
20  | / pub(crate) trait Layout: Preconditions + Algorithms {
21  | |     type L: Layout;
22  | |
23  | |     const SERIAL_VERSION_V0: i8 = 0;
...   |
160 | |         return Ok(LayoutSerialization::read(data_input));
    | |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `Self`, found enum `Result`
...   |
210 | |     }
211 | | }
    | |_- this type parameter
    |
   ::: src/layouts/layout_serialization.rs:136:52
    |
136 |       fn read(data_input: impl bytes::Buf) -> Result<impl Layout, std::rc::Rc<DynaHistError>> {
    |                                                      ----------- the found opaque type
    |
    = note: expected type parameter `Self`
                         found enum `Result<impl layouts::layout::Layout, Rc<DynaHistError>>`

error[E0061]: this function takes 2 arguments but 4 arguments were supplied
   --> src/layouts/layout.rs:196:16
    |
196 |         return LayoutSerializationDefinition::new(serial_version, &layout, writer, reader);
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ --------------  -------  ------  ------ supplied 4 arguments
    |                |
    |                expected 2 arguments
    |
note: associated function defined here
   --> src/layouts/layout_serialization_definition.rs:31:12
    |
31  |     pub fn new( serial_version: i64,  layout: Sketch) -> Self {
    |            ^^^  -------------------   --------------

error[E0624]: associated function `new` is private
   --> src/layouts/layout.rs:208:51
    |
208 |         let layout_seriate = LayoutSerialization::new();
    |                                                   ^^^ private associated function
    |
   ::: src/layouts/layout_serialization.rs:29:5
    |
29  |     fn new(length: usize) -> Self {
    |     ----------------------------- private associated function defined here

error[E0061]: this function takes 1 argument but 0 arguments were supplied
   --> src/layouts/layout.rs:208:30
    |
208 |         let layout_seriate = LayoutSerialization::new();
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^-- supplied 0 arguments
    |                              |
    |                              expected 1 argument
    |
note: associated function defined here
   --> src/layouts/layout_serialization.rs:29:8
    |
29  |     fn new(length: usize) -> Self {
    |        ^^^ -------------

error[E0599]: no method named `register` found for struct `LayoutSerialization` in the current scope
   --> src/layouts/layout.rs:209:24
    |
209 |         layout_seriate.register(definitions);
    |         ---------------^^^^^^^^-------------
    |         |              |
    |         |              this is an associated function, not a method
    |         help: disambiguate the associated function for candidate #2: `layouts::layout::Layout::register(layout_seriate, definitions)`
    |
   ::: src/layouts/layout_serialization.rs:18:1
    |
18  | pub struct LayoutSerialization {
    | ------------------------------ method `register` not found for this
    |
    = note: found the following associated functions; to be used as methods, functions must have a `self` parameter
note: candidate #1 is defined in an impl for the type `LayoutSerialization`
   --> src/layouts/layout_serialization.rs:71:5
    |
71  |     fn register(definitions: &Vec<&LayoutSerializationDefinition>) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `layouts::layout::Layout`
   --> src/layouts/layout.rs:207:5
    |
207 |     fn register(definitions: &LayoutSerializationDefinition) {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
note: `layouts::layout::Layout` defines an item `register`, perhaps you need to implement it
   --> src/layouts/layout.rs:20:1
    |
20  | pub(crate) trait Layout: Preconditions + Algorithms {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0223]: ambiguous associated type
  --> src/layouts/layout_serialization.rs:75:35
   |
75 |             Self::check_argument(!Self::RESERVED_SERIAL_VERSIONS::contains(
   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<LayoutSerialization as Trait>::RESERVED_SERIAL_VERSIONS`

error[E0599]: no method named `put` found for struct `HashMap` in the current scope
  --> src/layouts/layout_serialization.rs:80:18
   |
80 |                 .put(definition.serial_version, definition);
   |                  ^^^ method not found in `HashMap<i64, LayoutSerializationDefinition>`

error[E0277]: can't compare `&String` with `String`
  --> src/layouts/layout_serialization.rs:81:51
   |
81 |             Self::check_argument(&old_def1.layout == definition.layout);
   |                                                   ^^ no implementation for `&String == String`
   |
   = help: the trait `PartialEq<String>` is not implemented for `&String`

error[E0599]: no method named `put` found for struct `HashMap` in the current scope
  --> src/layouts/layout_serialization.rs:85:18
   |
85 |                 .put(definition.layout, definition);
   |                  ^^^ method not found in `HashMap<String, LayoutSerializationDefinition>`

error[E0599]: the method `clone` exists for struct `HashMap<i64, LayoutSerializationDefinition>`, but its trait bounds were not satisfied
   --> src/layouts/layout_serialization.rs:90:66
    |
90  |               serial_to_definitions: seriate.serial_to_definitions.clone(),
    |                                                                    ^^^^^ method cannot be called on `HashMap<i64, LayoutSerializationDefinition>` due to unsatisfied trait bounds
    |
   ::: /home/hedge/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/collections/hash/map.rs:207:1
    |
207 |   pub struct HashMap<K, V, S = RandomState> {
    |   ----------------------------------------- doesn't satisfy `HashMap<i64, LayoutSerializationDefinition>: Clone`
    |
   ::: src/layouts/layout_serialization_definition.rs:14:1
    |
14  | / pub struct LayoutSerializationDefinition
15  | | // where
16  | | //     L: Layout
17  | | {
...   |
21  | |     pub reader: SerializationReader,
22  | | }
    | |_- doesn't satisfy `LayoutSerializationDefinition: Clone`
    |
    = note: the following trait bounds were not satisfied:
            `LayoutSerializationDefinition: Clone`
            which is required by `HashMap<i64, LayoutSerializationDefinition>: Clone`

error[E0599]: the method `clone` exists for struct `HashMap<String, LayoutSerializationDefinition>`, but its trait bounds were not satisfied
   --> src/layouts/layout_serialization.rs:91:66
    |
91  |               layout_to_definitions: seriate.layout_to_definitions.clone(),
    |                                                                    ^^^^^ method cannot be called on `HashMap<String, LayoutSerializationDefinition>` due to unsatisfied trait bounds
    |
   ::: /home/hedge/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/collections/hash/map.rs:207:1
    |
207 |   pub struct HashMap<K, V, S = RandomState> {
    |   ----------------------------------------- doesn't satisfy `_: Clone`
    |
   ::: src/layouts/layout_serialization_definition.rs:14:1
    |
14  | / pub struct LayoutSerializationDefinition
15  | | // where
16  | | //     L: Layout
17  | | {
...   |
21  | |     pub reader: SerializationReader,
22  | | }
    | |_- doesn't satisfy `LayoutSerializationDefinition: Clone`
    |
    = note: the following trait bounds were not satisfied:
            `LayoutSerializationDefinition: Clone`
            which is required by `HashMap<String, LayoutSerializationDefinition>: Clone`

error[E0609]: no field `layout_to_definitions` on type `impl Layout`
   --> src/layouts/layout_serialization.rs:112:19
    |
112 |         if layout.layout_to_definitions.contains_key(&layout.histogram_type) {
    |                   ^^^^^^^^^^^^^^^^^^^^^

error[E0609]: no field `histogram_type` on type `impl Layout`
   --> src/layouts/layout_serialization.rs:112:62
    |
112 |         if layout.layout_to_definitions.contains_key(&layout.histogram_type) {
    |                                                              ^^^^^^^^^^^^^^

error[E0609]: no field `layout_to_definitions` on type `impl Layout`
   --> src/layouts/layout_serialization.rs:113:33
    |
113 |             definition = layout.layout_to_definitions.get(&layout.histogram_type);
    |                                 ^^^^^^^^^^^^^^^^^^^^^

error[E0609]: no field `histogram_type` on type `impl Layout`
   --> src/layouts/layout_serialization.rs:113:67
    |
113 |             definition = layout.layout_to_definitions.get(&layout.histogram_type);
    |                                                                   ^^^^^^^^^^^^^^

error[E0609]: no field `histogram_type` on type `impl Layout`
   --> src/layouts/layout_serialization.rs:117:24
    |
117 |                 layout.histogram_type
    |                        ^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/layout_serialization.rs:115:48
    |
115 |               return Err(DynaHistError::IOError( format!(
    |  ________________________________________________^
116 | |                 "{} has not been registered for serialization!",
117 | |                 layout.histogram_type
118 | |             )));
    | |_____________^ expected struct `anyhow::Error`, found struct `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> src/layouts/layout_serialization.rs:115:24
    |
115 |               return Err(DynaHistError::IOError( format!(
    |  ________________________^
116 | |                 "{} has not been registered for serialization!",
117 | |                 layout.histogram_type
118 | |             )));
    | |______________^ expected struct `Rc`, found enum `DynaHistError`
    |
    = note: expected struct `Rc<DynaHistError>`
                 found enum `DynaHistError`

error[E0599]: no method named `write` found for struct `SerializationWriter` in the current scope
   --> src/layouts/layout_serialization.rs:121:27
    |
121 |         definition.writer.write(layout, &data_output);
    |                           ^^^^^ method not found in `SerializationWriter`
    |
   ::: src/seriate/serialization.rs:24:1
    |
24  | pub struct SerializationWriter {
    | ------------------------------ method `write` not found for this
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `write`, perhaps you need to implement one of them:
            candidate #1: `SeriateWrite`
            candidate #2: `Seriate`
            candidate #3: `AbstractMutableHistogram`
            candidate #4: `Histogram`
            candidate #5: `std::io::Write`
            candidate #6: `Hasher`

error[E0308]: mismatched types
   --> src/layouts/layout_serialization.rs:110:10
    |
107 |     fn write(
    |        ----- implicitly returns `()` as its body has no tail or `return` expression
...
110 |     ) -> Result<(), std::rc::Rc<DynaHistError>> {
    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Result`, found `()`
    |
    = note:   expected enum `Result<(), Rc<DynaHistError>>`
            found unit type `()`

error[E0624]: associated function `new` is private
  --> src/layouts/layout_serialization_definition.rs:42:42
   |
42 |             writer: SerializationWriter::new(layout),
   |                                          ^^^ private associated function
   |
  ::: src/seriate/serialization.rs:30:5
   |
30 |     fn new(layout: Sketch) -> Self {
   |     ------------------------------ private associated function defined here

error[E0624]: associated function `new` is private
  --> src/layouts/layout_serialization_definition.rs:43:42
   |
43 |             reader: SerializationReader::new(layout),
   |                                          ^^^ private associated function
   |
  ::: src/seriate/deserialization.rs:30:5
   |
30 |     fn new(layout: Sketch) -> Self {
   |     ------------------------------ private associated function defined here

error[E0061]: this function takes 5 arguments but 6 arguments were supplied
  --> src/layouts/log_linear_layout.rs:46:21
   |
46 |         return self.map_to_bin_index_detail(&self,
   |                     ^^^^^^^^^^^^^^^^^^^^^^^ -----
   |                     |
   |                     expected 5 arguments
47 |             value,
   |             -----
48 |             self.factor_normal,
   |             ------------------
49 |             self.factor_subnormal,
   |             ---------------------
50 |             self.unsigned_value_bits_normal_limit,
   |             -------------------------------------
51 |             self.offset,
   |             ----------- supplied 6 arguments
   |
note: associated function defined here
  --> src/layouts/layout.rs:36:8
   |
36 |     fn map_to_bin_index_detail(&self,
   |        ^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/layouts/log_linear_layout.rs:73:31
   |
73 |         let value_bits: i64 = value.to_bits();
   |                         ---   ^^^^^^^^^^^^^^^ expected `i64`, found `u64`
   |                         |
   |                         expected due to this
   |
help: you can convert a `u64` to an `i64` and panic if the converted value doesn't fit
   |
73 |         let value_bits: i64 = value.to_bits().try_into().unwrap();
   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/layouts/log_linear_layout.rs:77:19
   |
77 |             idx = Self::calculate_normal_idx(unsigned_value_bits, factor_normal, offset);
   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`

error[E0308]: mismatched types
  --> src/layouts/log_linear_layout.rs:79:19
   |
79 |             idx = Self::calculate_sub_normal_idx(unsigned_value_bits, factor_subnormal);
   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`

error[E0308]: mismatched types
  --> src/layouts/log_linear_layout.rs:81:39
   |
81 |         return if value_bits >= 0x0 { idx } else { !idx };
   |                                       ^^^ expected `usize`, found `i32`
   |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
   |
81 |         return if value_bits >= 0x0 { idx.try_into().unwrap() } else { !idx };
   |                                       ^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/layouts/log_linear_layout.rs:81:52
   |
81 |         return if value_bits >= 0x0 { idx } else { !idx };
   |                                                    ^^^^ expected `usize`, found `i32`
   |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
   |
81 |         return if value_bits >= 0x0 { idx } else { (!idx).try_into().unwrap() };
   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: cannot multiply `i32` by `f64`
   --> src/layouts/log_linear_layout.rs:103:26
    |
103 |         let x: f64 = idx * self.absolute_bin_width_limit;
    |                          ^ no implementation for `i32 * f64`
    |
    = help: the trait `Mul<f64>` is not implemented for `i32`

error[E0308]: mismatched types
   --> src/layouts/log_linear_layout.rs:104:31
    |
104 |         if x < f64::from_bits(self.unsigned_value_bits_normal_limit) {
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `i64`
    |
help: you can convert an `i64` to a `u64` and panic if the converted value doesn't fit
    |
104 |         if x < f64::from_bits(self.unsigned_value_bits_normal_limit.try_into().unwrap()) {
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: cannot subtract `f64` from `i32`
   --> src/layouts/log_linear_layout.rs:107:31
    |
107 |             let s: f64 = (idx - self.offset) / self.factor_normal;
    |                               ^ no implementation for `i32 - f64`
    |
    = help: the trait `Sub<f64>` is not implemented for `i32`

error[E0277]: cannot subtract `i32` from `f64`
   --> src/layouts/log_linear_layout.rs:109:41
    |
109 |             let mantissa_plus1: f64 = s - exponent;
    |                                         ^ no implementation for `f64 - i32`
    |
    = help: the trait `Sub<i32>` is not implemented for `f64`

error[E0308]: mismatched types
   --> src/layouts/log_linear_layout.rs:113:49
    |
113 |             return mantissa_plus1 * i32::pow(2, exponent - 1023);
    |                                                 ^^^^^^^^^^^^^^^ expected `u32`, found `i32`
    |
help: you can convert an `i32` to a `u32` and panic if the converted value doesn't fit
    |
113 |             return mantissa_plus1 * i32::pow(2, (exponent - 1023).try_into().unwrap());
    |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: cannot multiply `f64` by `i32`
   --> src/layouts/log_linear_layout.rs:113:35
    |
113 |             return mantissa_plus1 * i32::pow(2, exponent - 1023);
    |                                   ^ no implementation for `f64 * i32`
    |
    = help: the trait `Mul<i32>` is not implemented for `f64`

error[E0599]: no method named `read_unsigned_byte` found for reference `&DataInput` in the current scope
   --> src/layouts/log_linear_layout.rs:121:73
    |
121 |         Self::check_serial_version(Self::SERIAL_VERSION_V0, &data_input.read_unsigned_byte());
    |                                                                         ^^^^^^^^^^^^^^^^^^ method not found in `&DataInput`

error[E0599]: no method named `read_double` found for reference `&DataInput` in the current scope
   --> src/layouts/log_linear_layout.rs:122:60
    |
122 |         let absolute_bin_width_limit_tmp: f64 = data_input.read_double();
    |                                                            ^^^^^^^^^^^ method not found in `&DataInput`

error[E0599]: no method named `read_double` found for reference `&DataInput` in the current scope
   --> src/layouts/log_linear_layout.rs:123:60
    |
123 |         let relative_bin_width_limit_tmp: f64 = data_input.read_double();
    |                                                            ^^^^^^^^^^^ method not found in `&DataInput`

error[E0599]: no function or associated item named `read_signed_var_int` found for struct `SeriateUtil` in the current scope
   --> src/layouts/log_linear_layout.rs:124:57
    |
124 |         let underflow_bin_index_tmp: i32 = SeriateUtil::read_signed_var_int(&data_input);
    |                                                         ^^^^^^^^^^^^^^^^^^^ function or associated item not found in `SeriateUtil`
    |
   ::: src/seriate/mod.rs:26:1
    |
26  | pub struct SeriateUtil {}
    | ---------------------- function or associated item `read_signed_var_int` not found for this
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `Seriate` defines an item `read_signed_var_int`, perhaps you need to implement it
   --> src/seriate/mod.rs:301:1
    |
301 | pub trait Seriate {
    | ^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `read_signed_var_int` found for struct `SeriateUtil` in the current scope
   --> src/layouts/log_linear_layout.rs:125:56
    |
125 |         let overflow_bin_index_tmp: i32 = SeriateUtil::read_signed_var_int(&data_input);
    |                                                        ^^^^^^^^^^^^^^^^^^^ function or associated item not found in `SeriateUtil`
    |
   ::: src/seriate/mod.rs:26:1
    |
26  | pub struct SeriateUtil {}
    | ---------------------- function or associated item `read_signed_var_int` not found for this
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `Seriate` defines an item `read_signed_var_int`, perhaps you need to implement it
   --> src/seriate/mod.rs:301:1
    |
301 | pub trait Seriate {
    | ^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_linear_layout.rs:144:13
    |
144 |             underflow_bin_index_tmp,
    |             ^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `i32`
    |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
144 |             underflow_bin_index_tmp.try_into().unwrap(),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_linear_layout.rs:145:13
    |
145 |             overflow_bin_index_tmp,
    |             ^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `i32`
    |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
145 |             overflow_bin_index_tmp.try_into().unwrap(),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `write_byte` found for reference `&DataOutput` in the current scope
   --> src/layouts/log_linear_layout.rs:154:21
    |
154 |         data_output.write_byte(Self::SERIAL_VERSION_V0);
    |                     ^^^^^^^^^^ method not found in `&DataOutput`

error[E0599]: no method named `write_double` found for reference `&DataOutput` in the current scope
   --> src/layouts/log_linear_layout.rs:155:21
    |
155 |         data_output.write_double(self.absolute_bin_width_limit);
    |                     ^^^^^^^^^^^^ method not found in `&DataOutput`

error[E0599]: no method named `write_double` found for reference `&DataOutput` in the current scope
   --> src/layouts/log_linear_layout.rs:156:21
    |
156 |         data_output.write_double(self.relative_bin_width_limit);
    |                     ^^^^^^^^^^^^ method not found in `&DataOutput`

error[E0308]: mismatched types
   --> src/layouts/log_linear_layout.rs:157:36
    |
157 |         Self::write_signed_var_int(self.underflow_bin_index, &data_output);
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
157 |         Self::write_signed_var_int(self.underflow_bin_index.try_into().unwrap(), &data_output);
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_linear_layout.rs:158:36
    |
158 |         Self::write_signed_var_int(self.overflow_bin_index, &data_output)
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
158 |         Self::write_signed_var_int(self.overflow_bin_index.try_into().unwrap(), &data_output)
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_linear_layout.rs:188:37
    |
188 |         let first_normal_idx: i32 = Self::calculate_first_normal_index(relative_bin_width_limit);
    |                               ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |                               |
    |                               expected due to this
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
188 |         let first_normal_idx: i32 = Self::calculate_first_normal_index(relative_bin_width_limit).try_into().unwrap();
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_linear_layout.rs:193:80
    |
193 |             Self::calculate_unsigned_value_bits_normal_limit(factor_subnormal, first_normal_idx);
    |                                                                                ^^^^^^^^^^^^^^^^ expected `usize`, found `i32`
    |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
193 |             Self::calculate_unsigned_value_bits_normal_limit(factor_subnormal, first_normal_idx.try_into().unwrap());
    |                                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_linear_layout.rs:197:13
    |
197 |             first_normal_idx,
    |             ^^^^^^^^^^^^^^^^ expected `usize`, found `i32`
    |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
197 |             first_normal_idx.try_into().unwrap(),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0061]: this function takes 2 arguments but 5 arguments were supplied
   --> src/layouts/log_linear_layout.rs:199:54
    |
199 |         let value_range_lower_bound_bin_index: i32 = Self::map_to_bin_index(
    |                                                      ^^^^^^^^^^^^^^^^^^^^^^ expected 2 arguments
200 |             value_range_lower_bound,
    |             -----------------------
201 |             factor_normal,
    |             -------------
202 |             factor_subnormal,
    |             ----------------
203 |             unsigned_value_bits_normal_limit,
    |             --------------------------------
204 |             offset,
    |             ------ supplied 5 arguments
    |
note: associated function defined here
   --> src/layouts/layout.rs:34:8
    |
34  |     fn map_to_bin_index(&self, value: f64) -> usize;
    |        ^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_linear_layout.rs:199:54
    |
199 |           let value_range_lower_bound_bin_index: i32 = Self::map_to_bin_index(
    |  ________________________________________________---___^
    | |                                                |
    | |                                                expected due to this
200 | |             value_range_lower_bound,
201 | |             factor_normal,
202 | |             factor_subnormal,
203 | |             unsigned_value_bits_normal_limit,
204 | |             offset,
205 | |         );
    | |_________^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
199 |         let value_range_lower_bound_bin_index: i32 = Self::map_to_bin_index(
200 |             value_range_lower_bound,
201 |             factor_normal,
202 |             factor_subnormal,
203 |             unsigned_value_bits_normal_limit,
204 |             offset,
  ...

error[E0061]: this function takes 2 arguments but 5 arguments were supplied
   --> src/layouts/log_linear_layout.rs:206:54
    |
206 |         let value_range_upper_bound_bin_index: i32 = Self::map_to_bin_index(
    |                                                      ^^^^^^^^^^^^^^^^^^^^^^ expected 2 arguments
207 |             value_range_upper_bound,
    |             -----------------------
208 |             factor_normal,
    |             -------------
209 |             factor_subnormal,
    |             ----------------
210 |             unsigned_value_bits_normal_limit,
    |             --------------------------------
211 |             offset,
    |             ------ supplied 5 arguments
    |
note: associated function defined here
   --> src/layouts/layout.rs:34:8
    |
34  |     fn map_to_bin_index(&self, value: f64) -> usize;
    |        ^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_linear_layout.rs:206:54
    |
206 |           let value_range_upper_bound_bin_index: i32 = Self::map_to_bin_index(
    |  ________________________________________________---___^
    | |                                                |
    | |                                                expected due to this
207 | |             value_range_upper_bound,
208 | |             factor_normal,
209 | |             factor_subnormal,
210 | |             unsigned_value_bits_normal_limit,
211 | |             offset,
212 | |         );
    | |_________^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
206 |         let value_range_upper_bound_bin_index: i32 = Self::map_to_bin_index(
207 |             value_range_upper_bound,
208 |             factor_normal,
209 |             factor_subnormal,
210 |             unsigned_value_bits_normal_limit,
211 |             offset,
  ...

error[E0308]: mismatched types
   --> src/layouts/log_linear_layout.rs:223:13
    |
223 |             underflow_bin_index,
    |             ^^^^^^^^^^^^^^^^^^^ expected `usize`, found `i32`
    |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
223 |             underflow_bin_index.try_into().unwrap(),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_linear_layout.rs:224:13
    |
224 |             overflow_bin_index,
    |             ^^^^^^^^^^^^^^^^^^ expected `usize`, found `i32`
    |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
224 |             overflow_bin_index.try_into().unwrap(),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_linear_layout.rs:241:10
    |
232 |     fn new(
    |        --- implicitly returns `()` as its body has no tail or `return` expression
...
241 |     ) -> LogLinearLayout {
    |          ^^^^^^^^^^^^^^^ expected struct `LogLinearLayout`, found `()`

error[E0599]: no function or associated item named `double_to_raw_long_bits` found for struct `LogLinearLayout` in the current scope
   --> src/layouts/log_linear_layout.rs:261:20
    |
24  | pub struct LogLinearLayout {
    | -------------------------- function or associated item `double_to_raw_long_bits` not found for this
...
261 |             &Self::double_to_raw_long_bits(f64::INFINITY),
    |                    ^^^^^^^^^^^^^^^^^^^^^^^ function or associated item not found in `LogLinearLayout`

error[E0631]: type mismatch in closure arguments
   --> src/layouts/log_linear_layout.rs:258:16
    |
257 |             |&x| Self::calculate_sub_normal_idx(x, factor_subnormal) >= first_normal_idx;
    |             ---------------------------------------------------------------------------- found signature of `fn(&i64) -> _`
258 |         return Self::find_first_guess(
    |                ^^^^^^^^^^^^^^^^^^^^^^ expected signature of `fn(i64) -> _`
    |
note: required by `Algorithms::find_first_guess`
   --> src/utilities/algorithms.rs:209:5
    |
209 | /     fn find_first_guess<P>(predicate: P, min: i64, max: i64, initial_guess: i64) -> i64
210 | |     where
211 | |         P: Fn(i64) -> bool,
    | |___________________________^

error[E0308]: mismatched types
   --> src/layouts/log_linear_layout.rs:262:13
    |
262 | /             &Self::calculate_unsigned_value_bits_normal_limit_approximate(
263 | |                 factor_subnormal,
264 | |                 first_normal_idx,
265 | |             ),
    | |_____________^ expected `i64`, found `&i64`
    |
help: consider removing the borrow
    |
262 |             Self::calculate_unsigned_value_bits_normal_limit_approximate(
    |            --

error[E0277]: cannot divide `usize` by `f64`
   --> src/layouts/log_linear_layout.rs:273:58
    |
273 |         return Self::map_double_to_long(first_normal_idx / factor_subnormal);
    |                                                          ^ no implementation for `usize / f64`
    |
    = help: the trait `Div<f64>` is not implemented for `usize`

error[E0038]: the trait `Float` cannot be made into an object
   --> src/layouts/log_linear_layout.rs:281:22
    |
281 |         return 1.0 / num::Float::log_1p(relative_bin_width_limit);
    |                      ^^^^^^^^^^ `Float` cannot be made into an object
    |
note: for a trait to be "object safe" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>
   --> /home/hedge/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.2.14/src/lib.rs:67:16
    |
67  | pub trait Num: PartialEq + Zero + One + NumOps {
    |                ^^^^^^^^^                ^^^^^^ the trait cannot be made into an object because it uses `Self` as a type parameter
    |                |
    |                the trait cannot be made into an object because it uses `Self` as a type parameter
    |
   ::: /home/hedge/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.2.14/src/float.rs:905:41
    |
905 | pub trait Float: Num + Copy + NumCast + PartialOrd + Neg<Output = Self> {
    |                                         ^^^^^^^^^^ the trait cannot be made into an object because it uses `Self` as a type parameter
    |
   ::: /home/hedge/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.2.14/src/identities.rs:12:25
    |
12  | pub trait Zero: Sized + Add<Self, Output = Self> {
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^
    |                         |         |
    |                         |         the trait cannot be made into an object because it uses `Self` as a type parameter
    |                         the trait cannot be made into an object because it uses `Self` as a type parameter
...
90  | pub trait One: Sized + Mul<Self, Output = Self> {
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^
    |                        |         |
    |                        |         the trait cannot be made into an object because it uses `Self` as a type parameter
    |                        the trait cannot be made into an object because it uses `Self` as a type parameter

error[E0308]: mismatched types
   --> src/layouts/log_linear_layout.rs:295:34
    |
295 |               let bin_index: i32 = Self::calculate_normal_idx(
    |  ____________________________---___^
    | |                            |
    | |                            expected due to this
296 | |                 unsigned_value_bits_normal_limit,
297 | |                 factor_normal,
298 | |                 offset_candidate,
299 | |             );
    | |_____________^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
295 |             let bin_index: i32 = Self::calculate_normal_idx(
296 |                 unsigned_value_bits_normal_limit,
297 |                 factor_normal,
298 |                 offset_candidate,
299 |             ).try_into().unwrap();
    |

error[E0308]: mismatched types
   --> src/layouts/log_linear_layout.rs:300:33
    |
300 |             return bin_index >= first_normal_idx;
    |                                 ^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |
note: return type inferred to be `i32` here
   --> src/layouts/log_linear_layout.rs:300:20
    |
300 |             return bin_index >= first_normal_idx;
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
300 |             return bin_index >= first_normal_idx.try_into().unwrap();
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_linear_layout.rs:304:13
    |
304 |             Self::NEGATIVE_INFINITY_MAPPED_TO_LONG,
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i64`, found `isize`
    |
help: you can convert an `isize` to an `i64` and panic if the converted value doesn't fit
    |
304 |             Self::NEGATIVE_INFINITY_MAPPED_TO_LONG.try_into().unwrap(),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_linear_layout.rs:305:13
    |
305 |             Self::POSITIVE_INFINITY_MAPPED_TO_LONG,
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i64`, found `isize`
    |
help: you can convert an `isize` to an `i64` and panic if the converted value doesn't fit
    |
305 |             Self::POSITIVE_INFINITY_MAPPED_TO_LONG.try_into().unwrap(),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0631]: type mismatch in closure arguments
   --> src/layouts/log_linear_layout.rs:302:42
    |
293 |         let predicate = |&x| {
    |                         ---- found signature of `fn(&i64) -> _`
...
302 |         return Self::map_long_to_double(&Self::find_first_guess(
    |                                          ^^^^^^^^^^^^^^^^^^^^^^ expected signature of `fn(i64) -> _`
    |
note: required by `Algorithms::find_first_guess`
   --> src/utilities/algorithms.rs:209:5
    |
209 | /     fn find_first_guess<P>(predicate: P, min: i64, max: i64, initial_guess: i64) -> i64
210 | |     where
211 | |         P: Fn(i64) -> bool,
    | |___________________________^

error[E0308]: mismatched types
   --> src/layouts/log_linear_layout.rs:306:39
    |
306 |               &Self::map_double_to_long(&Self::calculate_offset_approximate(
    |  _______________________________________^
307 | |                 unsigned_value_bits_normal_limit,
308 | |                 factor_normal,
309 | |                 first_normal_idx,
310 | |             )),
    | |_____________^ expected `f64`, found `&f64`
    |
help: consider removing the borrow
    |
306 |             &Self::map_double_to_long(Self::calculate_offset_approximate(
    |                                      --

error[E0308]: mismatched types
   --> src/layouts/log_linear_layout.rs:306:13
    |
306 | /             &Self::map_double_to_long(&Self::calculate_offset_approximate(
307 | |                 unsigned_value_bits_normal_limit,
308 | |                 factor_normal,
309 | |                 first_normal_idx,
310 | |             )),
    | |______________^ expected `i64`, found `&i64`
    |
help: consider removing the borrow
    |
306 |             Self::map_double_to_long(&Self::calculate_offset_approximate(
    |            --

error[E0308]: mismatched types
   --> src/layouts/log_linear_layout.rs:302:41
    |
302 |           return Self::map_long_to_double(&Self::find_first_guess(
    |  _________________________________________^
303 | |             predicate,
304 | |             Self::NEGATIVE_INFINITY_MAPPED_TO_LONG,
305 | |             Self::POSITIVE_INFINITY_MAPPED_TO_LONG,
...   |
310 | |             )),
311 | |         ));
    | |_________^ expected `i64`, found `&i64`
    |
help: consider removing the borrow
    |
302 |         return Self::map_long_to_double(Self::find_first_guess(
    |                                        --

error[E0277]: cannot subtract `f64` from `usize`
   --> src/layouts/log_linear_layout.rs:320:13
    |
320 |             - factor_normal * Self::map_to_bin_index_helper(unsigned_value_bits_normal_limit);
    |             ^ no implementation for `usize - f64`
    |
    = help: the trait `Sub<f64>` is not implemented for `usize`

error[E0308]: mismatched types
   --> src/layouts/log_linear_layout.rs:331:28
    |
331 |             f64::from_bits((unsigned_value_bits & 0x000fffffffffffff) | 0x3ff0000000000000);
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `i64`
    |
help: you can convert an `i64` to a `u64` and panic if the converted value doesn't fit
    |
331 |             f64::from_bits(((unsigned_value_bits & 0x000fffffffffffff) | 0x3ff0000000000000).try_into().unwrap());
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: cannot add `i64` to `f64`
   --> src/layouts/log_linear_layout.rs:332:31
    |
332 |         return mantissa_plus1 + exponent;
    |                               ^ no implementation for `f64 + i64`
    |
    = help: the trait `Add<i64>` is not implemented for `f64`

error[E0308]: mismatched types
   --> src/layouts/log_linear_layout.rs:341:51
    |
341 |         return (factor_subnormal * f64::from_bits(unsigned_value_bits)) as usize;
    |                                                   ^^^^^^^^^^^^^^^^^^^ expected `u64`, found `i64`
    |
help: you can convert an `i64` to a `u64` and panic if the converted value doesn't fit
    |
341 |         return (factor_subnormal * f64::from_bits(unsigned_value_bits.try_into().unwrap())) as usize;
    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0061]: this function takes 5 arguments but 6 arguments were supplied
  --> src/layouts/log_optimal_layout.rs:50:21
   |
50 |         return self.map_to_bin_index_detail(&self,
   |                     ^^^^^^^^^^^^^^^^^^^^^^^ -----
   |                     |
   |                     expected 5 arguments
51 |             value,
   |             -----
52 |             self.factor_normal,
   |             ------------------
53 |             self.factor_subnormal,
   |             ---------------------
54 |             self.unsigned_value_bits_normal_limit,
   |             -------------------------------------
55 |             self.offset,
   |             ----------- supplied 6 arguments
   |
note: associated function defined here
  --> src/layouts/layout.rs:36:8
   |
36 |     fn map_to_bin_index_detail(&self,
   |        ^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/layouts/log_optimal_layout.rs:77:31
   |
77 |         let value_bits: i64 = value.to_bits();
   |                         ---   ^^^^^^^^^^^^^^^ expected `i64`, found `u64`
   |                         |
   |                         expected due to this
   |
help: you can convert a `u64` to an `i64` and panic if the converted value doesn't fit
   |
77 |         let value_bits: i64 = value.to_bits().try_into().unwrap();
   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/layouts/log_optimal_layout.rs:80:50
   |
80 |         let unsigned_value: f64 = f64::from_bits(unsigned_value_bits);
   |                                                  ^^^^^^^^^^^^^^^^^^^ expected `u64`, found `i64`
   |
help: you can convert an `i64` to a `u64` and panic if the converted value doesn't fit
   |
80 |         let unsigned_value: f64 = f64::from_bits(unsigned_value_bits.try_into().unwrap());
   |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/layouts/log_optimal_layout.rs:84:19
   |
84 |             idx = Self::calculate_normal_idx(unsigned_value, factor_normal, offset);
   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`

error[E0308]: mismatched types
  --> src/layouts/log_optimal_layout.rs:88:37
   |
88 |         return if value_bits >= 0 { idx } else { idx };
   |                                     ^^^ expected `usize`, found `i32`
   |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
   |
88 |         return if value_bits >= 0 { idx.try_into().unwrap() } else { idx };
   |                                     ^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/layouts/log_optimal_layout.rs:88:50
   |
88 |         return if value_bits >= 0 { idx } else { idx };
   |                                                  ^^^ expected `usize`, found `i32`
   |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
   |
88 |         return if value_bits >= 0 { idx } else { idx.try_into().unwrap() };
   |                                                  ^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: cannot multiply `i32` by `f64`
   --> src/layouts/log_optimal_layout.rs:111:26
    |
111 |         let x: f64 = idx * self.absolute_bin_width_limit;
    |                          ^ no implementation for `i32 * f64`
    |
    = help: the trait `Mul<f64>` is not implemented for `i32`

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:112:31
    |
112 |         if x < f64::from_bits(self.unsigned_value_bits_normal_limit) {
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `i64`
    |
help: you can convert an `i64` to a `u64` and panic if the converted value doesn't fit
    |
112 |         if x < f64::from_bits(self.unsigned_value_bits_normal_limit.try_into().unwrap()) {
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: cannot subtract `f64` from `i32`
   --> src/layouts/log_optimal_layout.rs:115:31
    |
115 |             let s: f64 = (idx - self.offset) / self.factor_normal + Self::LOG_MIN_VALUE;
    |                               ^ no implementation for `i32 - f64`
    |
    = help: the trait `Sub<f64>` is not implemented for `i32`

error[E0599]: no method named `read_unsigned_byte` found for reference `&DataInput` in the current scope
   --> src/layouts/log_optimal_layout.rs:124:73
    |
124 |         Self::check_serial_version(Self::SERIAL_VERSION_V0, &data_input.read_unsigned_byte());
    |                                                                         ^^^^^^^^^^^^^^^^^^ method not found in `&DataInput`

error[E0599]: no method named `read_double` found for reference `&DataInput` in the current scope
   --> src/layouts/log_optimal_layout.rs:125:60
    |
125 |         let absolute_bin_width_limit_tmp: f64 = data_input.read_double();
    |                                                            ^^^^^^^^^^^ method not found in `&DataInput`

error[E0599]: no method named `read_double` found for reference `&DataInput` in the current scope
   --> src/layouts/log_optimal_layout.rs:126:60
    |
126 |         let relative_bin_width_limit_tmp: f64 = data_input.read_double();
    |                                                            ^^^^^^^^^^^ method not found in `&DataInput`

error[E0599]: no function or associated item named `read_signed_var_int` found for struct `SeriateUtil` in the current scope
   --> src/layouts/log_optimal_layout.rs:127:57
    |
127 |         let underflow_bin_index_tmp: i32 = SeriateUtil::read_signed_var_int(&data_input);
    |                                                         ^^^^^^^^^^^^^^^^^^^ function or associated item not found in `SeriateUtil`
    |
   ::: src/seriate/mod.rs:26:1
    |
26  | pub struct SeriateUtil {}
    | ---------------------- function or associated item `read_signed_var_int` not found for this
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `Seriate` defines an item `read_signed_var_int`, perhaps you need to implement it
   --> src/seriate/mod.rs:301:1
    |
301 | pub trait Seriate {
    | ^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `read_signed_var_int` found for struct `SeriateUtil` in the current scope
   --> src/layouts/log_optimal_layout.rs:128:56
    |
128 |         let overflow_bin_index_tmp: i32 = SeriateUtil::read_signed_var_int(&data_input);
    |                                                        ^^^^^^^^^^^^^^^^^^^ function or associated item not found in `SeriateUtil`
    |
   ::: src/seriate/mod.rs:26:1
    |
26  | pub struct SeriateUtil {}
    | ---------------------- function or associated item `read_signed_var_int` not found for this
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `Seriate` defines an item `read_signed_var_int`, perhaps you need to implement it
   --> src/seriate/mod.rs:301:1
    |
301 | pub trait Seriate {
    | ^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:130:13
    |
129 |         let first_normal_idx_tmp: i32 =
    |                                   --- expected due to this
130 |             Self::calculate_first_normal_index(relative_bin_width_limit_tmp);
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
130 |             Self::calculate_first_normal_index(relative_bin_width_limit_tmp).try_into().unwrap();
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:137:17
    |
137 |                 first_normal_idx_tmp,
    |                 ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `i32`
    |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
137 |                 first_normal_idx_tmp.try_into().unwrap(),
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:142:13
    |
142 |             first_normal_idx_tmp,
    |             ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `i32`
    |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
142 |             first_normal_idx_tmp.try_into().unwrap(),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:147:13
    |
147 |             underflow_bin_index_tmp,
    |             ^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `i32`
    |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
147 |             underflow_bin_index_tmp.try_into().unwrap(),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:148:13
    |
148 |             overflow_bin_index_tmp,
    |             ^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `i32`
    |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
148 |             overflow_bin_index_tmp.try_into().unwrap(),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `write_byte` found for reference `&DataOutput` in the current scope
   --> src/layouts/log_optimal_layout.rs:158:21
    |
158 |         data_output.write_byte(Self::SERIAL_VERSION_V0);
    |                     ^^^^^^^^^^ method not found in `&DataOutput`

error[E0599]: no method named `write_double` found for reference `&DataOutput` in the current scope
   --> src/layouts/log_optimal_layout.rs:159:21
    |
159 |         data_output.write_double(self.absolute_bin_width_limit);
    |                     ^^^^^^^^^^^^ method not found in `&DataOutput`

error[E0599]: no method named `write_double` found for reference `&DataOutput` in the current scope
   --> src/layouts/log_optimal_layout.rs:160:21
    |
160 |         data_output.write_double(self.relative_bin_width_limit);
    |                     ^^^^^^^^^^^^ method not found in `&DataOutput`

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:161:36
    |
161 |         Self::write_signed_var_int(self.underflow_bin_index, &data_output);
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
161 |         Self::write_signed_var_int(self.underflow_bin_index.try_into().unwrap(), &data_output);
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:162:36
    |
162 |         Self::write_signed_var_int(self.overflow_bin_index, &data_output)
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
162 |         Self::write_signed_var_int(self.overflow_bin_index.try_into().unwrap(), &data_output)
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:194:37
    |
194 |         let first_normal_idx: i32 = Self::calculate_first_normal_index(relative_bin_width_limit);
    |                               ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |                               |
    |                               expected due to this
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
194 |         let first_normal_idx: i32 = Self::calculate_first_normal_index(relative_bin_width_limit).try_into().unwrap();
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:199:80
    |
199 |             Self::calculate_unsigned_value_bits_normal_limit(factor_subnormal, first_normal_idx);
    |                                                                                ^^^^^^^^^^^^^^^^ expected `usize`, found `i32`
    |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
199 |             Self::calculate_unsigned_value_bits_normal_limit(factor_subnormal, first_normal_idx.try_into().unwrap());
    |                                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:203:13
    |
203 |             first_normal_idx,
    |             ^^^^^^^^^^^^^^^^ expected `usize`, found `i32`
    |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
203 |             first_normal_idx.try_into().unwrap(),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0061]: this function takes 2 arguments but 5 arguments were supplied
   --> src/layouts/log_optimal_layout.rs:205:54
    |
205 |         let value_range_lower_bound_bin_index: i32 = Self::map_to_bin_index(
    |                                                      ^^^^^^^^^^^^^^^^^^^^^^ expected 2 arguments
206 |             value_range_lower_bound,
    |             -----------------------
207 |             factor_normal,
    |             -------------
208 |             factor_subnormal,
    |             ----------------
209 |             unsigned_value_bits_normal_limit,
    |             --------------------------------
210 |             offset,
    |             ------ supplied 5 arguments
    |
note: associated function defined here
   --> src/layouts/layout.rs:34:8
    |
34  |     fn map_to_bin_index(&self, value: f64) -> usize;
    |        ^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:205:54
    |
205 |           let value_range_lower_bound_bin_index: i32 = Self::map_to_bin_index(
    |  ________________________________________________---___^
    | |                                                |
    | |                                                expected due to this
206 | |             value_range_lower_bound,
207 | |             factor_normal,
208 | |             factor_subnormal,
209 | |             unsigned_value_bits_normal_limit,
210 | |             offset,
211 | |         );
    | |_________^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
205 |         let value_range_lower_bound_bin_index: i32 = Self::map_to_bin_index(
206 |             value_range_lower_bound,
207 |             factor_normal,
208 |             factor_subnormal,
209 |             unsigned_value_bits_normal_limit,
210 |             offset,
  ...

error[E0061]: this function takes 2 arguments but 5 arguments were supplied
   --> src/layouts/log_optimal_layout.rs:212:54
    |
212 |         let value_range_upper_bound_bin_index: i32 = Self::map_to_bin_index(
    |                                                      ^^^^^^^^^^^^^^^^^^^^^^ expected 2 arguments
213 |             value_range_upper_bound,
    |             -----------------------
214 |             factor_normal,
    |             -------------
215 |             factor_subnormal,
    |             ----------------
216 |             unsigned_value_bits_normal_limit,
    |             --------------------------------
217 |             offset,
    |             ------ supplied 5 arguments
    |
note: associated function defined here
   --> src/layouts/layout.rs:34:8
    |
34  |     fn map_to_bin_index(&self, value: f64) -> usize;
    |        ^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:212:54
    |
212 |           let value_range_upper_bound_bin_index: i32 = Self::map_to_bin_index(
    |  ________________________________________________---___^
    | |                                                |
    | |                                                expected due to this
213 | |             value_range_upper_bound,
214 | |             factor_normal,
215 | |             factor_subnormal,
216 | |             unsigned_value_bits_normal_limit,
217 | |             offset,
218 | |         );
    | |_________^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
212 |         let value_range_upper_bound_bin_index: i32 = Self::map_to_bin_index(
213 |             value_range_upper_bound,
214 |             factor_normal,
215 |             factor_subnormal,
216 |             unsigned_value_bits_normal_limit,
217 |             offset,
  ...

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:229:13
    |
229 |             underflow_bin_index,
    |             ^^^^^^^^^^^^^^^^^^^ expected `usize`, found `i32`
    |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
229 |             underflow_bin_index.try_into().unwrap(),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:230:13
    |
230 |             overflow_bin_index,
    |             ^^^^^^^^^^^^^^^^^^ expected `usize`, found `i32`
    |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
230 |             overflow_bin_index.try_into().unwrap(),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:247:10
    |
238 |     fn new(
    |        --- implicitly returns `()` as its body has no tail or `return` expression
...
247 |     ) -> LogOptimalLayout {
    |          ^^^^^^^^^^^^^^^^ expected struct `LogOptimalLayout`, found `()`

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:263:60
    |
263 |             Self::calculate_sub_normal_idx(&f64::from_bits(x), factor_subnormal) >= first_normal_idx
    |                                                            ^ expected `u64`, found `i32`
    |
help: you can convert an `i32` to a `u64` and panic if the converted value doesn't fit
    |
263 |             Self::calculate_sub_normal_idx(&f64::from_bits(x.try_into().unwrap()), factor_subnormal) >= first_normal_idx
    |                                                            ^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:263:44
    |
263 |             Self::calculate_sub_normal_idx(&f64::from_bits(x), factor_subnormal) >= first_normal_idx
    |                                            ^^^^^^^^^^^^^^^^^^ expected `f64`, found `&f64`
    |
help: consider removing the borrow
    |
263 |             Self::calculate_sub_normal_idx(f64::from_bits(x), factor_subnormal) >= first_normal_idx
    |                                           --

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:263:85
    |
263 |             Self::calculate_sub_normal_idx(&f64::from_bits(x), factor_subnormal) >= first_normal_idx
    |                                                                                     ^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
263 |             Self::calculate_sub_normal_idx(&f64::from_bits(x), factor_subnormal) >= first_normal_idx.try_into().unwrap()
    |                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `double_to_raw_long_bits` found for struct `LogOptimalLayout` in the current scope
   --> src/layouts/log_optimal_layout.rs:268:20
    |
29  | pub struct LogOptimalLayout {
    | --------------------------- function or associated item `double_to_raw_long_bits` not found for this
...
268 |             &Self::double_to_raw_long_bits(f64::INFINITY),
    |                    ^^^^^^^^^^^^^^^^^^^^^^^ function or associated item not found in `LogOptimalLayout`

error[E0631]: type mismatch in closure arguments
   --> src/layouts/log_optimal_layout.rs:265:16
    |
262 |         let predicate = |x: i32| {
    |                         -------- found signature of `fn(i32) -> _`
...
265 |         return Self::find_first_guess(
    |                ^^^^^^^^^^^^^^^^^^^^^^ expected signature of `fn(i64) -> _`
    |
note: required by `Algorithms::find_first_guess`
   --> src/utilities/algorithms.rs:209:5
    |
209 | /     fn find_first_guess<P>(predicate: P, min: i64, max: i64, initial_guess: i64) -> i64
210 | |     where
211 | |         P: Fn(i64) -> bool,
    | |___________________________^

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:271:17
    |
271 |                 first_normal_idx,
    |                 ^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
271 |                 first_normal_idx.try_into().unwrap(),
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:269:13
    |
269 | /             &Self::calculate_unsigned_value_bits_normal_limit_approximate(
270 | |                 factor_subnormal,
271 | |                 first_normal_idx,
272 | |             ),
    | |_____________^ expected `i64`, found `&i64`
    |
help: consider removing the borrow
    |
269 |             Self::calculate_unsigned_value_bits_normal_limit_approximate(
    |            --

error[E0277]: cannot divide `i32` by `f64`
   --> src/layouts/log_optimal_layout.rs:280:58
    |
280 |         return Self::map_double_to_long(first_normal_idx / factor_subnormal);
    |                                                          ^ no implementation for `i32 / f64`
    |
    = help: the trait `Div<f64>` is not implemented for `i32`

error[E0038]: the trait `Float` cannot be made into an object
   --> src/layouts/log_optimal_layout.rs:313:22
    |
313 |         return 1.0 / num::Float::log_1p(relative_bin_width_limit);
    |                      ^^^^^^^^^^ `Float` cannot be made into an object
    |
note: for a trait to be "object safe" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>
   --> /home/hedge/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.2.14/src/lib.rs:67:16
    |
67  | pub trait Num: PartialEq + Zero + One + NumOps {
    |                ^^^^^^^^^                ^^^^^^ the trait cannot be made into an object because it uses `Self` as a type parameter
    |                |
    |                the trait cannot be made into an object because it uses `Self` as a type parameter
    |
   ::: /home/hedge/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.2.14/src/float.rs:905:41
    |
905 | pub trait Float: Num + Copy + NumCast + PartialOrd + Neg<Output = Self> {
    |                                         ^^^^^^^^^^ the trait cannot be made into an object because it uses `Self` as a type parameter
    |
   ::: /home/hedge/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.2.14/src/identities.rs:12:25
    |
12  | pub trait Zero: Sized + Add<Self, Output = Self> {
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^
    |                         |         |
    |                         |         the trait cannot be made into an object because it uses `Self` as a type parameter
    |                         the trait cannot be made into an object because it uses `Self` as a type parameter
...
90  | pub trait One: Sized + Mul<Self, Output = Self> {
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^
    |                        |         |
    |                        |         the trait cannot be made into an object because it uses `Self` as a type parameter
    |                        the trait cannot be made into an object because it uses `Self` as a type parameter

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:325:57
    |
325 |         let unsigned_normal_limit: f64 = f64::from_bits(unsigned_value_bits_normal_limit);
    |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `i64`
    |
help: you can convert an `i64` to a `u64` and panic if the converted value doesn't fit
    |
325 |         let unsigned_normal_limit: f64 = f64::from_bits(unsigned_value_bits_normal_limit.try_into().unwrap());
    |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:329:17
    |
328 |             let bin_index: i32 =
    |                            --- expected due to this
329 |                 Self::calculate_normal_idx(unsigned_normal_limit, factor_normal, offset_candidate);
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
329 |                 Self::calculate_normal_idx(unsigned_normal_limit, factor_normal, offset_candidate).try_into().unwrap();
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:330:26
    |
330 |             bin_index >= first_normal_idx
    |                          ^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
330 |             bin_index >= first_normal_idx.try_into().unwrap()
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:334:13
    |
334 |             Self::NEGATIVE_INFINITY_MAPPED_TO_LONG,
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i64`, found `isize`
    |
help: you can convert an `isize` to an `i64` and panic if the converted value doesn't fit
    |
334 |             Self::NEGATIVE_INFINITY_MAPPED_TO_LONG.try_into().unwrap(),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:335:13
    |
335 |             Self::POSITIVE_INFINITY_MAPPED_TO_LONG,
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i64`, found `isize`
    |
help: you can convert an `isize` to an `i64` and panic if the converted value doesn't fit
    |
335 |             Self::POSITIVE_INFINITY_MAPPED_TO_LONG.try_into().unwrap(),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:336:39
    |
336 |               &Self::map_double_to_long(&Self::calculate_offset_approximate(
    |  _______________________________________^
337 | |                 unsigned_normal_limit,
338 | |                 factor_normal,
339 | |                 first_normal_idx,
340 | |             )),
    | |_____________^ expected `f64`, found `&f64`
    |
help: consider removing the borrow
    |
336 |             &Self::map_double_to_long(Self::calculate_offset_approximate(
    |                                      --

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:336:13
    |
336 | /             &Self::map_double_to_long(&Self::calculate_offset_approximate(
337 | |                 unsigned_normal_limit,
338 | |                 factor_normal,
339 | |                 first_normal_idx,
340 | |             )),
    | |______________^ expected `i64`, found `&i64`
    |
help: consider removing the borrow
    |
336 |             Self::map_double_to_long(&Self::calculate_offset_approximate(
    |            --

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:332:41
    |
332 |           return Self::map_long_to_double(&Self::find_first_guess(
    |  _________________________________________^
333 | |             predicate,
334 | |             Self::NEGATIVE_INFINITY_MAPPED_TO_LONG,
335 | |             Self::POSITIVE_INFINITY_MAPPED_TO_LONG,
...   |
340 | |             )),
341 | |         ));
    | |_________^ expected `i64`, found `&i64`
    |
help: consider removing the borrow
    |
332 |         return Self::map_long_to_double(Self::find_first_guess(
    |                                        --

error[E0277]: cannot subtract `f64` from `usize`
   --> src/layouts/log_optimal_layout.rs:350:13
    |
350 |             - factor_normal * Self::map_to_bin_index_helper(unsigned_normal_limit);
    |             ^ no implementation for `usize - f64`
    |
    = help: the trait `Sub<f64>` is not implemented for `usize`

error[E0308]: mismatched types
   --> src/layouts/log_optimal_layout.rs:366:16
    |
365 |     fn calculate_sub_normal_idx(unsigned_value: f64, factor_subnormal: f64) -> i32 {
    |                                                                                --- expected `i32` because of return type
366 |         return (factor_subnormal * unsigned_value) as usize;
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
366 |         return ((factor_subnormal * unsigned_value) as usize).try_into().unwrap();
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: cannot multiply `i32` by `f64`
  --> src/layouts/log_quadratic_layout.rs:53:26
   |
53 |         let x: f64 = idx * self.absolute_bin_width_limit;
   |                          ^ no implementation for `i32 * f64`
   |
   = help: the trait `Mul<f64>` is not implemented for `i32`

error[E0308]: mismatched types
  --> src/layouts/log_quadratic_layout.rs:54:31
   |
54 |         if x < f64::from_bits(self.unsigned_value_bits_normal_limit) {
   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `i64`
   |
help: you can convert an `i64` to a `u64` and panic if the converted value doesn't fit
   |
54 |         if x < f64::from_bits(self.unsigned_value_bits_normal_limit.try_into().unwrap()) {
   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: cannot subtract `f64` from `i32`
  --> src/layouts/log_quadratic_layout.rs:57:31
   |
57 |             let s: f64 = (idx - self.offset) / self.factor_normal;
   |                               ^ no implementation for `i32 - f64`
   |
   = help: the trait `Sub<f64>` is not implemented for `i32`

error[E0277]: cannot subtract `f64` from `i32`
  --> src/layouts/log_quadratic_layout.rs:61:58
   |
61 |             3.0 - num::integer::sqrt(exponent_mul3_plus4 - s);
   |                                                          ^ no implementation for `i32 - f64`
   |
   = help: the trait `Sub<f64>` is not implemented for `i32`

error[E0308]: mismatched types
  --> src/layouts/log_quadratic_layout.rs:65:49
   |
65 |             return mantissa_plus1 * i32::pow(2, exponent - 1023);
   |                                                 ^^^^^^^^^^^^^^^ expected `u32`, found `i32`
   |
help: you can convert an `i32` to a `u32` and panic if the converted value doesn't fit
   |
65 |             return mantissa_plus1 * i32::pow(2, (exponent - 1023).try_into().unwrap());
   |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: cannot multiply `f64` by `i32`
  --> src/layouts/log_quadratic_layout.rs:65:35
   |
65 |             return mantissa_plus1 * i32::pow(2, exponent - 1023);
   |                                   ^ no implementation for `f64 * i32`
   |
   = help: the trait `Mul<i32>` is not implemented for `f64`

error[E0061]: this function takes 5 arguments but 6 arguments were supplied
  --> src/layouts/log_quadratic_layout.rs:74:21
   |
74 |         return self.map_to_bin_index_detail(&self,
   |                     ^^^^^^^^^^^^^^^^^^^^^^^ -----
   |                     |
   |                     expected 5 arguments
75 |             value,
   |             -----
76 |             self.factor_normal,
   |             ------------------
77 |             self.factor_subnormal,
   |             ---------------------
78 |             self.unsigned_value_bits_normal_limit,
   |             -------------------------------------
79 |             self.offset,
   |             ----------- supplied 6 arguments
   |
note: associated function defined here
  --> src/layouts/layout.rs:36:8
   |
36 |     fn map_to_bin_index_detail(&self,
   |        ^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_quadratic_layout.rs:101:31
    |
101 |         let value_bits: i64 = value.to_bits();
    |                         ---   ^^^^^^^^^^^^^^^ expected `i64`, found `u64`
    |                         |
    |                         expected due to this
    |
help: you can convert a `u64` to an `i64` and panic if the converted value doesn't fit
    |
101 |         let value_bits: i64 = value.to_bits().try_into().unwrap();
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_quadratic_layout.rs:105:19
    |
105 |             idx = Self::calculate_normal_idx(unsigned_value_bits, factor_normal, offset);
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`

error[E0308]: mismatched types
   --> src/layouts/log_quadratic_layout.rs:107:19
    |
107 |             idx = Self::calculate_sub_normal_idx(unsigned_value_bits, factor_subnormal);
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`

error[E0308]: mismatched types
   --> src/layouts/log_quadratic_layout.rs:109:37
    |
109 |         return if value_bits >= 0 { idx } else { !idx };
    |                                     ^^^ expected `usize`, found `i32`
    |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
109 |         return if value_bits >= 0 { idx.try_into().unwrap() } else { !idx };
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_quadratic_layout.rs:109:50
    |
109 |         return if value_bits >= 0 { idx } else { !idx };
    |                                                  ^^^^ expected `usize`, found `i32`
    |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
109 |         return if value_bits >= 0 { idx } else { (!idx).try_into().unwrap() };
    |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `read_unsigned_byte` found for reference `&DataInput` in the current scope
   --> src/layouts/log_quadratic_layout.rs:124:73
    |
124 |         Self::check_serial_version(Self::SERIAL_VERSION_V0, &data_input.read_unsigned_byte());
    |                                                                         ^^^^^^^^^^^^^^^^^^ method not found in `&DataInput`

error[E0599]: no method named `read_double` found for reference `&DataInput` in the current scope
   --> src/layouts/log_quadratic_layout.rs:125:60
    |
125 |         let absolute_bin_width_limit_tmp: f64 = data_input.read_double();
    |                                                            ^^^^^^^^^^^ method not found in `&DataInput`

error[E0599]: no method named `read_double` found for reference `&DataInput` in the current scope
   --> src/layouts/log_quadratic_layout.rs:126:60
    |
126 |         let relative_bin_width_limit_tmp: f64 = data_input.read_double();
    |                                                            ^^^^^^^^^^^ method not found in `&DataInput`

error[E0599]: no function or associated item named `read_signed_var_int` found for struct `SeriateUtil` in the current scope
   --> src/layouts/log_quadratic_layout.rs:127:57
    |
127 |         let underflow_bin_index_tmp: i32 = SeriateUtil::read_signed_var_int(&data_input);
    |                                                         ^^^^^^^^^^^^^^^^^^^ function or associated item not found in `SeriateUtil`
    |
   ::: src/seriate/mod.rs:26:1
    |
26  | pub struct SeriateUtil {}
    | ---------------------- function or associated item `read_signed_var_int` not found for this
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `Seriate` defines an item `read_signed_var_int`, perhaps you need to implement it
   --> src/seriate/mod.rs:301:1
    |
301 | pub trait Seriate {
    | ^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `read_signed_var_int` found for struct `SeriateUtil` in the current scope
   --> src/layouts/log_quadratic_layout.rs:128:56
    |
128 |         let overflow_bin_index_tmp: i32 = SeriateUtil::read_signed_var_int(&data_input);
    |                                                        ^^^^^^^^^^^^^^^^^^^ function or associated item not found in `SeriateUtil`
    |
   ::: src/seriate/mod.rs:26:1
    |
26  | pub struct SeriateUtil {}
    | ---------------------- function or associated item `read_signed_var_int` not found for this
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `Seriate` defines an item `read_signed_var_int`, perhaps you need to implement it
   --> src/seriate/mod.rs:301:1
    |
301 | pub trait Seriate {
    | ^^^^^^^^^^^^^^^^^

error[E0599]: no method named `write_byte` found for reference `&DataOutput` in the current scope
   --> src/layouts/log_quadratic_layout.rs:157:21
    |
157 |         data_output.write_byte(Self::SERIAL_VERSION_V0);
    |                     ^^^^^^^^^^ method not found in `&DataOutput`

error[E0599]: no method named `write_double` found for reference `&DataOutput` in the current scope
   --> src/layouts/log_quadratic_layout.rs:158:21
    |
158 |         data_output.write_double(self.absolute_bin_width_limit);
    |                     ^^^^^^^^^^^^ method not found in `&DataOutput`

error[E0599]: no method named `write_double` found for reference `&DataOutput` in the current scope
   --> src/layouts/log_quadratic_layout.rs:159:21
    |
159 |         data_output.write_double(self.relative_bin_width_limit);
    |                     ^^^^^^^^^^^^ method not found in `&DataOutput`

error[E0308]: mismatched types
   --> src/layouts/log_quadratic_layout.rs:160:36
    |
160 |         Self::write_signed_var_int(self.underflow_bin_index, &data_output);
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
160 |         Self::write_signed_var_int(self.underflow_bin_index.try_into().unwrap(), &data_output);
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_quadratic_layout.rs:161:36
    |
161 |         Self::write_signed_var_int(self.overflow_bin_index, &data_output)
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
161 |         Self::write_signed_var_int(self.overflow_bin_index.try_into().unwrap(), &data_output)
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0061]: this function takes 2 arguments but 5 arguments were supplied
   --> src/layouts/log_quadratic_layout.rs:202:54
    |
202 |         let value_range_lower_bound_bin_index: i32 = Self::map_to_bin_index(
    |                                                      ^^^^^^^^^^^^^^^^^^^^^^ expected 2 arguments
203 |             value_range_lower_bound,
    |             -----------------------
204 |             factor_normal,
    |             -------------
205 |             factor_subnormal,
    |             ----------------
206 |             unsigned_value_bits_normal_limit,
    |             --------------------------------
207 |             offset,
    |             ------ supplied 5 arguments
    |
note: associated function defined here
   --> src/layouts/layout.rs:34:8
    |
34  |     fn map_to_bin_index(&self, value: f64) -> usize;
    |        ^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_quadratic_layout.rs:202:54
    |
202 |           let value_range_lower_bound_bin_index: i32 = Self::map_to_bin_index(
    |  ________________________________________________---___^
    | |                                                |
    | |                                                expected due to this
203 | |             value_range_lower_bound,
204 | |             factor_normal,
205 | |             factor_subnormal,
206 | |             unsigned_value_bits_normal_limit,
207 | |             offset,
208 | |         );
    | |_________^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
202 |         let value_range_lower_bound_bin_index: i32 = Self::map_to_bin_index(
203 |             value_range_lower_bound,
204 |             factor_normal,
205 |             factor_subnormal,
206 |             unsigned_value_bits_normal_limit,
207 |             offset,
  ...

error[E0061]: this function takes 2 arguments but 5 arguments were supplied
   --> src/layouts/log_quadratic_layout.rs:209:54
    |
209 |         let value_range_upper_bound_bin_index: i32 = Self::map_to_bin_index(
    |                                                      ^^^^^^^^^^^^^^^^^^^^^^ expected 2 arguments
210 |             value_range_upper_bound,
    |             -----------------------
211 |             factor_normal,
    |             -------------
212 |             factor_subnormal,
    |             ----------------
213 |             unsigned_value_bits_normal_limit,
    |             --------------------------------
214 |             offset,
    |             ------ supplied 5 arguments
    |
note: associated function defined here
   --> src/layouts/layout.rs:34:8
    |
34  |     fn map_to_bin_index(&self, value: f64) -> usize;
    |        ^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_quadratic_layout.rs:209:54
    |
209 |           let value_range_upper_bound_bin_index: i32 = Self::map_to_bin_index(
    |  ________________________________________________---___^
    | |                                                |
    | |                                                expected due to this
210 | |             value_range_upper_bound,
211 | |             factor_normal,
212 | |             factor_subnormal,
213 | |             unsigned_value_bits_normal_limit,
214 | |             offset,
215 | |         );
    | |_________^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
209 |         let value_range_upper_bound_bin_index: i32 = Self::map_to_bin_index(
210 |             value_range_upper_bound,
211 |             factor_normal,
212 |             factor_subnormal,
213 |             unsigned_value_bits_normal_limit,
214 |             offset,
  ...

error[E0308]: mismatched types
   --> src/layouts/log_quadratic_layout.rs:244:10
    |
235 |     fn new(
    |        --- implicitly returns `()` as its body has no tail or `return` expression
...
244 |     ) -> LogQuadraticLayout {
    |          ^^^^^^^^^^^^^^^^^^ expected struct `LogQuadraticLayout`, found `()`

error[E0308]: mismatched types
   --> src/layouts/log_quadratic_layout.rs:260:73
    |
260 |             |&x| Self::calculate_sub_normal_idx(x, factor_subnormal) >= first_normal_idx;
    |                                                                         ^^^^^^^^^^^^^^^^ expected `usize`, found `i32`
    |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
260 |             |&x| Self::calculate_sub_normal_idx(x, factor_subnormal) >= first_normal_idx.try_into().unwrap();
    |                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `double_to_raw_long_bits` found for struct `LogQuadraticLayout` in the current scope
   --> src/layouts/log_quadratic_layout.rs:264:20
    |
25  | pub struct LogQuadraticLayout {
    | ----------------------------- function or associated item `double_to_raw_long_bits` not found for this
...
264 |             &Self::double_to_raw_long_bits(f64::INFINITY),
    |                    ^^^^^^^^^^^^^^^^^^^^^^^ function or associated item not found in `LogQuadraticLayout`

error[E0631]: type mismatch in closure arguments
   --> src/layouts/log_quadratic_layout.rs:261:16
    |
260 |             |&x| Self::calculate_sub_normal_idx(x, factor_subnormal) >= first_normal_idx;
    |             ---------------------------------------------------------------------------- found signature of `fn(&i64) -> _`
261 |         return Self::find_first_guess(
    |                ^^^^^^^^^^^^^^^^^^^^^^ expected signature of `fn(i64) -> _`
    |
note: required by `Algorithms::find_first_guess`
   --> src/utilities/algorithms.rs:209:5
    |
209 | /     fn find_first_guess<P>(predicate: P, min: i64, max: i64, initial_guess: i64) -> i64
210 | |     where
211 | |         P: Fn(i64) -> bool,
    | |___________________________^

error[E0308]: mismatched types
   --> src/layouts/log_quadratic_layout.rs:265:13
    |
265 | /             &Self::calculate_unsigned_value_bits_normal_limit_approximate(
266 | |                 factor_subnormal,
267 | |                 first_normal_idx,
268 | |             ),
    | |_____________^ expected `i64`, found `&i64`
    |
help: consider removing the borrow
    |
265 |             Self::calculate_unsigned_value_bits_normal_limit_approximate(
    |            --

error[E0277]: cannot divide `i32` by `f64`
   --> src/layouts/log_quadratic_layout.rs:276:58
    |
276 |         return Self::map_double_to_long(first_normal_idx / factor_subnormal);
    |                                                          ^ no implementation for `i32 / f64`
    |
    = help: the trait `Div<f64>` is not implemented for `i32`

error[E0038]: the trait `Float` cannot be made into an object
   --> src/layouts/log_quadratic_layout.rs:284:23
    |
284 |         return 0.25 / num::Float::log_1p(relative_bin_width_limit);
    |                       ^^^^^^^^^^ `Float` cannot be made into an object
    |
note: for a trait to be "object safe" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>
   --> /home/hedge/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.2.14/src/lib.rs:67:16
    |
67  | pub trait Num: PartialEq + Zero + One + NumOps {
    |                ^^^^^^^^^                ^^^^^^ the trait cannot be made into an object because it uses `Self` as a type parameter
    |                |
    |                the trait cannot be made into an object because it uses `Self` as a type parameter
    |
   ::: /home/hedge/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.2.14/src/float.rs:905:41
    |
905 | pub trait Float: Num + Copy + NumCast + PartialOrd + Neg<Output = Self> {
    |                                         ^^^^^^^^^^ the trait cannot be made into an object because it uses `Self` as a type parameter
    |
   ::: /home/hedge/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.2.14/src/identities.rs:12:25
    |
12  | pub trait Zero: Sized + Add<Self, Output = Self> {
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^
    |                         |         |
    |                         |         the trait cannot be made into an object because it uses `Self` as a type parameter
    |                         the trait cannot be made into an object because it uses `Self` as a type parameter
...
90  | pub trait One: Sized + Mul<Self, Output = Self> {
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^
    |                        |         |
    |                        |         the trait cannot be made into an object because it uses `Self` as a type parameter
    |                        the trait cannot be made into an object because it uses `Self` as a type parameter

error[E0308]: mismatched types
   --> src/layouts/log_quadratic_layout.rs:298:34
    |
298 |               let bin_index: i32 = Self::calculate_normal_idx(
    |  ____________________________---___^
    | |                            |
    | |                            expected due to this
299 | |                 unsigned_value_bits_normal_limit,
300 | |                 factor_normal,
301 | |                 offset_candidate,
302 | |             );
    | |_____________^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
298 |             let bin_index: i32 = Self::calculate_normal_idx(
299 |                 unsigned_value_bits_normal_limit,
300 |                 factor_normal,
301 |                 offset_candidate,
302 |             ).try_into().unwrap();
    |

error[E0308]: mismatched types
   --> src/layouts/log_quadratic_layout.rs:307:13
    |
307 |             Self::NEGATIVE_INFINITY_MAPPED_TO_LONG,
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i64`, found `isize`
    |
help: you can convert an `isize` to an `i64` and panic if the converted value doesn't fit
    |
307 |             Self::NEGATIVE_INFINITY_MAPPED_TO_LONG.try_into().unwrap(),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_quadratic_layout.rs:308:13
    |
308 |             Self::POSITIVE_INFINITY_MAPPED_TO_LONG,
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i64`, found `isize`
    |
help: you can convert an `isize` to an `i64` and panic if the converted value doesn't fit
    |
308 |             Self::POSITIVE_INFINITY_MAPPED_TO_LONG.try_into().unwrap(),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0631]: type mismatch in closure arguments
   --> src/layouts/log_quadratic_layout.rs:305:42
    |
296 |         let predicate = |&x| {
    |                         ---- found signature of `fn(&i64) -> _`
...
305 |         return Self::map_long_to_double(&Self::find_first_guess(
    |                                          ^^^^^^^^^^^^^^^^^^^^^^ expected signature of `fn(i64) -> _`
    |
note: required by `Algorithms::find_first_guess`
   --> src/utilities/algorithms.rs:209:5
    |
209 | /     fn find_first_guess<P>(predicate: P, min: i64, max: i64, initial_guess: i64) -> i64
210 | |     where
211 | |         P: Fn(i64) -> bool,
    | |___________________________^

error[E0308]: mismatched types
   --> src/layouts/log_quadratic_layout.rs:309:39
    |
309 |               &Self::map_double_to_long(&Self::calculate_offset_approximate(
    |  _______________________________________^
310 | |                 unsigned_value_bits_normal_limit,
311 | |                 factor_normal,
312 | |                 first_normal_idx,
313 | |             )),
    | |_____________^ expected `f64`, found `&f64`
    |
help: consider removing the borrow
    |
309 |             &Self::map_double_to_long(Self::calculate_offset_approximate(
    |                                      --

error[E0308]: mismatched types
   --> src/layouts/log_quadratic_layout.rs:309:13
    |
309 | /             &Self::map_double_to_long(&Self::calculate_offset_approximate(
310 | |                 unsigned_value_bits_normal_limit,
311 | |                 factor_normal,
312 | |                 first_normal_idx,
313 | |             )),
    | |______________^ expected `i64`, found `&i64`
    |
help: consider removing the borrow
    |
309 |             Self::map_double_to_long(&Self::calculate_offset_approximate(
    |            --

error[E0308]: mismatched types
   --> src/layouts/log_quadratic_layout.rs:305:41
    |
305 |           return Self::map_long_to_double(&Self::find_first_guess(
    |  _________________________________________^
306 | |             predicate,
307 | |             Self::NEGATIVE_INFINITY_MAPPED_TO_LONG,
308 | |             Self::POSITIVE_INFINITY_MAPPED_TO_LONG,
...   |
313 | |             )),
314 | |         ));
    | |_________^ expected `i64`, found `&i64`
    |
help: consider removing the borrow
    |
305 |         return Self::map_long_to_double(Self::find_first_guess(
    |                                        --

error[E0277]: cannot subtract `f64` from `i32`
   --> src/layouts/log_quadratic_layout.rs:323:13
    |
323 |             - factor_normal * Self::map_to_bin_index_helper(unsigned_value_bits_normal_limit);
    |             ^ no implementation for `i32 - f64`
    |
    = help: the trait `Sub<f64>` is not implemented for `i32`

error[E0308]: mismatched types
   --> src/layouts/log_quadratic_layout.rs:333:34
    |
333 |         let exponent_mul3: f64 = exponent + (exponent << 1);
    |                            ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `i64`
    |                            |
    |                            expected due to this
    |
help: you can convert an `i64` to an `f64`, producing the floating point representation of the integer, rounded if necessary
    |
333 |         let exponent_mul3: f64 = (exponent + (exponent << 1)) as f64;
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_quadratic_layout.rs:335:28
    |
335 |             f64::from_bits((unsigned_value_bits & 0x000fffffffffffff) | 0x3ff0000000000000);
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `i64`
    |
help: you can convert an `i64` to a `u64` and panic if the converted value doesn't fit
    |
335 |             f64::from_bits(((unsigned_value_bits & 0x000fffffffffffff) | 0x3ff0000000000000).try_into().unwrap());
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/log_quadratic_layout.rs:345:51
    |
345 |         return (factor_subnormal * f64::from_bits(unsigned_value_bits)) as usize;
    |                                                   ^^^^^^^^^^^^^^^^^^^ expected `u64`, found `i64`
    |
help: you can convert an `i64` to a `u64` and panic if the converted value doesn't fit
    |
345 |         return (factor_subnormal * f64::from_bits(unsigned_value_bits.try_into().unwrap())) as usize;
    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: the trait bound `Self: Clone` is not satisfied
    --> src/layouts/open_telemetry_exponential_buckets_layout.rs:34:13
     |
34   | /             Self::new(
35   | |                 Self::MAX_PRECISION + 1
36   | |             );
     | |_____________^ the trait `Clone` is not implemented for `Self`
     |
    ::: /home/hedge/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:2296:21
     |
2296 |   pub fn from_elem<T: Clone>(elem: T, n: usize) -> Vec<T> {
     |                       ----- required by this bound in `from_elem`
     |
help: consider further restricting `Self`
     |
25   | pub(crate) trait OpenTelemetryLayout: Layout + Clone
     |                                              ^^^^^^^

error[E0308]: mismatched types
  --> src/layouts/open_telemetry_exponential_buckets_layout.rs:33:29
   |
33 |           std::sync::Arc::new(std::sync::Mutex::new(vec![
   |  _____________________________^
34 | |             Self::new(
35 | |                 Self::MAX_PRECISION + 1
36 | |             );
37 | |             1
38 | |         ]));
   | |__________^ expected struct `RwLock`, found struct `Mutex`
   |
   = note: expected struct `RwLock<Vec<Self>>`
              found struct `Mutex<Vec<Self>>`

error[E0277]: the type `[usize]` cannot be indexed by `i32`
  --> src/layouts/open_telemetry_exponential_buckets_layout.rs:43:16
   |
43 |         return Self::BOUNDARY_CONSTANTS[idx];
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`
   |
   = help: the trait `SliceIndex<[usize]>` is not implemented for `i32`
   = note: required because of the requirements on the impl of `Index<i32>` for `Vec<usize>`

error[E0599]: no method named `try_into` found for struct `Vec<T>` in the current scope
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:49:11
    |
49  |         v.try_into().unwrap_or_else(|v: Vec<T>| {
    |           ^^^^^^^^ method not found in `Vec<T>`
    |
   ::: /home/hedge/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:397:8
    |
397 |     fn try_into(self) -> Result<T, Self::Error>;
    |        -------- the method is available for `Vec<T>` here
    |
    = help: items from traits can only be used if the trait is in scope
    = note: the following trait is implemented but not in scope; perhaps add a `use` for it:
            `use std::convert::TryInto;`

error[E0308]: mismatched types
  --> src/layouts/open_telemetry_exponential_buckets_layout.rs:93:31
   |
93 |         let value_bits: i64 = value.to_bits();
   |                         ---   ^^^^^^^^^^^^^^^ expected `i64`, found `u64`
   |                         |
   |                         expected due to this
   |
help: you can convert a `u64` to an `i64` and panic if the converted value doesn't fit
   |
93 |         let value_bits: i64 = value.to_bits().try_into().unwrap();
   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/layouts/open_telemetry_exponential_buckets_layout.rs:96:13
   |
96 |             &self.indices,
   |             ^^^^^^^^^^^^^ expected `i32`, found `usize`
   |
   = note: expected reference `&Vec<i32>`
              found reference `&Vec<usize>`

error[E0308]: mismatched types
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:102:37
    |
102 |         return if value_bits >= 0 { index } else { -index };
    |                                     ^^^^^ expected `usize`, found `i32`
    |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
102 |         return if value_bits >= 0 { index.try_into().unwrap() } else { -index };
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:102:52
    |
102 |         return if value_bits >= 0 { index } else { -index };
    |                                                    ^^^^^^ expected `usize`, found `i32`
    |
    = note: `-index` cannot fit into type `usize`

error[E0308]: mismatched types
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:112:10
    |
105 |     fn map_to_bin_index_detail(
    |        ----------------------- implicitly returns `()` as its body has no tail or `return` expression
...
112 |     ) -> usize {
    |          ^^^^^ expected `usize`, found `()`

error[E0599]: no method named `read_unsigned_byte` found for reference `&DataInput` in the current scope
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:151:73
    |
151 |         Self::check_serial_version(Self::SERIAL_VERSION_V0, &data_input.read_unsigned_byte());
    |                                                                         ^^^^^^^^^^^^^^^^^^ method not found in `&DataInput`

error[E0599]: no method named `read_unsigned_byte` found for reference `&DataInput` in the current scope
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:152:41
    |
152 |         let precision: i32 = data_input.read_unsigned_byte();
    |                                         ^^^^^^^^^^^^^^^^^^ method not found in `&DataInput`

error[E0599]: no method named `write_byte` found for reference `&DataOutput` in the current scope
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:157:21
    |
157 |         data_output.write_byte(Self::SERIAL_VERSION_V0);
    |                     ^^^^^^^^^^ method not found in `&DataOutput`

error[E0599]: no method named `write_byte` found for reference `&DataOutput` in the current scope
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:158:21
    |
158 |         data_output.write_byte(self.precision);
    |                     ^^^^^^^^^^ method not found in `&DataOutput`

error[E0308]: mismatched types
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:156:50
    |
156 |     fn write(&self, data_output: &DataOutput) -> Result<(), std::rc::Rc<DynaHistError>> {
    |        -----                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Result`, found `()`
    |        |
    |        implicitly returns `()` as its body has no tail or `return` expression
    |
    = note:   expected enum `Result<(), Rc<DynaHistError>>`
            found unit type `()`

error[E0277]: can't compare `OpenTelemetryExponentialBucketsLayout` with `Option<_>`
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:173:18
    |
173 |             if x != None {
    |                  ^^ no implementation for `OpenTelemetryExponentialBucketsLayout == Option<_>`
    |
    = help: the trait `PartialEq<Option<_>>` is not implemented for `OpenTelemetryExponentialBucketsLayout`

error[E0223]: ambiguous associated type
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:181:16
    |
181 |         return Self::INSTANCES::update_and_get(precision, update_fn);
    |                ^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<OpenTelemetryExponentialBucketsLayout as Trait>::INSTANCES`

error[E0308]: mismatched types
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:202:28
    |
202 |             let nlz: i32 = mantissa.leading_zeros() - 12;
    |                      ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `u32`
    |                      |
    |                      expected due to this
    |
help: you can convert a `u32` to an `i32` and panic if the converted value doesn't fit
    |
202 |             let nlz: i32 = (mantissa.leading_zeros() - 12).try_into().unwrap();
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: the type `[i32]` cannot be indexed by `i32`
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:207:22
    |
207 |         let i: i32 = indices[(mantissa >> /* >>> */ (52 - precision)) as i32];
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`
    |
    = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
    = note: required because of the requirements on the impl of `Index<i32>` for `Vec<i32>`

error[E0277]: the type `[i64]` cannot be indexed by `i32`
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:209:31
    |
209 |             + (if mantissa >= boundaries[i] { 1 } else { 0 })
    |                               ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`
    |
    = help: the trait `SliceIndex<[i64]>` is not implemented for `i32`
    = note: required because of the requirements on the impl of `Index<i32>` for `Vec<i64>`

error[E0277]: the type `[i64]` cannot be indexed by `i32`
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:210:31
    |
210 |             + (if mantissa >= boundaries[i + 1] { 1 } else { 0 });
    |                               ^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`
    |
    = help: the trait `SliceIndex<[i64]>` is not implemented for `i32`
    = note: required because of the requirements on the impl of `Index<i32>` for `Vec<i64>`

error[E0308]: mismatched types
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:215:28
    |
215 |         if abs_bin_index < self.first_normal_value_bits {
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `i64`
    |
help: you can convert an `i64` to a `usize` and panic if the converted value doesn't fit
    |
215 |         if abs_bin_index < self.first_normal_value_bits.try_into().unwrap() {
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:216:35
    |
216 |             return f64::from_bits(abs_bin_index as i64);
    |                                   ^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `i64`
    |
help: you can convert an `i64` to a `u64` and panic if the converted value doesn't fit
    |
216 |             return f64::from_bits((abs_bin_index as i64).try_into().unwrap());
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:218:43
    |
218 |             let k: i32 = (abs_bin_index - self.index_offset) & (0xFFFFFFFF << self.precision);
    |                                           ^^^^^^^^^^^^^^^^^ expected `usize`, found `i32`

error[E0277]: cannot subtract `i32` from `usize`
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:218:41
    |
218 |             let k: i32 = (abs_bin_index - self.index_offset) & (0xFFFFFFFF << self.precision);
    |                                         ^ no implementation for `usize - i32`
    |
    = help: the trait `Sub<i32>` is not implemented for `usize`

error[E0308]: mismatched types
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:218:26
    |
218 |             let k: i32 = (abs_bin_index - self.index_offset) & (0xFFFFFFFF << self.precision);
    |                    ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |                    |
    |                    expected due to this
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
218 |             let k: i32 = ((abs_bin_index - self.index_offset) & (0xFFFFFFFF << self.precision)).try_into().unwrap();
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:219:54
    |
219 |             let mut exponent: i32 = (abs_bin_index - self.index_offset) >> self.precision;
    |                                                      ^^^^^^^^^^^^^^^^^ expected `usize`, found `i32`

error[E0277]: cannot subtract `i32` from `usize`
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:219:52
    |
219 |             let mut exponent: i32 = (abs_bin_index - self.index_offset) >> self.precision;
    |                                                    ^ no implementation for `usize - i32`
    |
    = help: the trait `Sub<i32>` is not implemented for `usize`

error[E0308]: mismatched types
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:219:37
    |
219 |             let mut exponent: i32 = (abs_bin_index - self.index_offset) >> self.precision;
    |                               ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |                               |
    |                               expected due to this
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
219 |             let mut exponent: i32 = ((abs_bin_index - self.index_offset) >> self.precision).try_into().unwrap();
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: the type `[i64]` cannot be indexed by `i32`
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:220:48
    |
220 |             let mut mantissa: i64 = if k > 0 { self.boundaries[k - 1] } else { 0 };
    |                                                ^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`
    |
    = help: the trait `SliceIndex<[i64]>` is not implemented for `i32`
    = note: required because of the requirements on the impl of `Index<i32>` for `Vec<i64>`

error[E0308]: mismatched types
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:228:35
    |
228 |             return f64::from_bits(mantissa | ((exponent as i64) << 52));
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `i64`
    |
help: you can convert an `i64` to a `u64` and panic if the converted value doesn't fit
    |
228 |             return f64::from_bits((mantissa | ((exponent as i64) << 52)).try_into().unwrap());
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0600]: cannot apply unary operator `-` to type `usize`
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:238:72
    |
238 |             let value = -self.get_bin_lower_bound_approximation_helper(-bin_index + 1);
    |                                                                        ^^^^^^^^^^ cannot apply unary operator `-`
    |
    = note: unsigned values cannot be negated

error[E0277]: a value of type `Vec<i64>` cannot be built from an iterator over elements of type `i32`
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:275:14
    |
275 |             .collect::<Vec<i64>>()
    |              ^^^^^^^ value of type `Vec<i64>` cannot be built from `std::iter::Iterator<Item=i32>`
    |
    = help: the trait `FromIterator<i32>` is not implemented for `Vec<i64>`

error[E0599]: no method named `try_into` found for struct `Vec<i64>` in the current scope
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:276:14
    |
276 |             .try_into()
    |              ^^^^^^^^ method not found in `Vec<i64>`
    |
   ::: /home/hedge/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:397:8
    |
397 |     fn try_into(self) -> Result<T, Self::Error>;
    |        -------- the method is available for `Vec<i64>` here
    |
    = help: items from traits can only be used if the trait is in scope
    = note: the following trait is implemented but not in scope; perhaps add a `use` for it:
            `use std::convert::TryInto;`

error[E0277]: the type `[_]` cannot be indexed by `i32`
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:289:9
    |
289 |         boundaries[length - 1] = 0x0010000000000000;
    |         ^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`
    |
    = help: the trait `SliceIndex<[_]>` is not implemented for `i32`
    = note: required because of the requirements on the impl of `Index<i32>` for `[_]`

error[E0277]: the type `[_]` cannot be indexed by `i32`
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:290:9
    |
290 |         boundaries[length] = 0x0010000000000000;
    |         ^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`
    |
    = help: the trait `SliceIndex<[_]>` is not implemented for `i32`
    = note: required because of the requirements on the impl of `Index<i32>` for `[_]`

error[E0308]: mismatched types
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:291:16
    |
271 |     fn calculate_boundaries(precision: i32) -> Vec<i64> {
    |                                                -------- expected `Vec<i64>` because of return type
...
291 |         return boundaries;
    |                ^^^^^^^^^^- help: try using a conversion method: `.to_vec()`
    |                |
    |                expected struct `Vec`, found array
    |
    = note: expected struct `Vec<i64>`
                found array `[_; _]`

error[E0599]: no method named `try_into` found for struct `Vec<i32>` in the current scope
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:299:14
    |
299 |             .try_into()
    |              ^^^^^^^^ method not found in `Vec<i32>`
    |
   ::: /home/hedge/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:397:8
    |
397 |     fn try_into(self) -> Result<T, Self::Error>;
    |        -------- the method is available for `Vec<i32>` here
    |
    = help: items from traits can only be used if the trait is in scope
    = note: the following trait is implemented but not in scope; perhaps add a `use` for it:
            `use std::convert::TryInto;`

error[E0277]: the type `[i64]` cannot be indexed by `i32`
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:307:27
    |
307 |                     while boundaries[c] <= mantissa_lower_bound {
    |                           ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`
    |
    = help: the trait `SliceIndex<[i64]>` is not implemented for `i32`
    = note: required because of the requirements on the impl of `Index<i32>` for `Vec<i64>`

error[E0308]: mismatched types
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:316:16
    |
294 |     fn calculate_indices(boundaries: &Vec<i64>, precision: i32) -> Vec<i32> {
    |                                                                    -------- expected `Vec<i32>` because of return type
...
316 |         return indices;
    |                ^^^^^^^- help: try using a conversion method: `.to_vec()`
    |                |
    |                expected struct `Vec`, found array
    |
    = note: expected struct `Vec<i32>`
                found array `[_; _]`

error[E0308]: mismatched types
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:328:17
    |
328 |                 next_value_bits,
    |                 ^^^^^^^^^^^^^^^
    |                 |
    |                 expected `i64`, found `i32`
    |                 help: you can convert an `i32` to an `i64`: `next_value_bits.into()`

error[E0061]: this function takes 2 arguments but 1 argument was supplied
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:343:34
    |
343 |         let overflow_bin_index = Self::map_to_bin_index(f64::MAX) + 1;
    |                                  ^^^^^^^^^^^^^^^^^^^^^^ -------- supplied 1 argument
    |                                  |
    |                                  expected 2 arguments
    |
note: associated function defined here
   --> src/layouts/layout.rs:34:8
    |
34  |     fn map_to_bin_index(&self, value: f64) -> usize;
    |        ^^^^^^^^^^^^^^^^

error[E0600]: cannot apply unary operator `-` to type `usize`
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:344:35
    |
344 |         let underflow_bin_index = -overflow_bin_index;
    |                                   ^^^^^^^^^^^^^^^^^^^ cannot apply unary operator `-`
    |
    = note: unsigned values cannot be negated

error[E0308]: mismatched types
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:347:13
    |
347 |             first_normal_value_bits,
    |             ^^^^^^^^^^^^^^^^^^^^^^^
    |             |
    |             expected `i64`, found `i32`
    |             help: you can convert an `i32` to an `i64`: `first_normal_value_bits: first_normal_value_bits.into()`

error[E0308]: mismatched types
   --> src/layouts/open_telemetry_exponential_buckets_layout.rs:350:13
    |
350 |             indices,
    |             ^^^^^^^ expected `usize`, found `i32`
    |
    = note: expected struct `Vec<usize>`
               found struct `Vec<i32>`

error[E0308]: mismatched types
  --> src/seriate/mod.rs:58:39
   |
57 |             |data_input: &DataInput| Histogram::read_as_static(layout, data_input);
   |             ---------------------------------------------------------------------- the found closure
58 |         let h = Self::from_byte_array(serialization_reader, serialized_histogram);
   |                                       ^^^^^^^^^^^^^^^^^^^^ expected struct `SerializationReader`, found closure
   |
   = note: expected struct `SerializationReader`
             found closure `[closure@src/seriate/mod.rs:57:13: 57:83]`

error[E0308]: mismatched types
  --> src/seriate/mod.rs:81:72
   |
81 |             |data_input: DataInput| Histogram::read_as_dynamic(layout, data_input);
   |                                                                        ^^^^^^^^^^
   |                                                                        |
   |                                                                        expected `&DataInput`, found struct `DataInput`
   |                                                                        help: consider borrowing here: `&data_input`

error[E0308]: mismatched types
  --> src/seriate/mod.rs:83:39
   |
81 |             |data_input: DataInput| Histogram::read_as_dynamic(layout, data_input);
   |             ---------------------------------------------------------------------- the found closure
82 | 
83 |         let h = Self::from_byte_array(serialization_reader, serialized_histogram);
   |                                       ^^^^^^^^^^^^^^^^^^^^ expected struct `SerializationReader`, found closure
   |
   = note: expected struct `SerializationReader`
             found closure `[closure@src/seriate/mod.rs:81:13: 81:83]`

error[E0308]: mismatched types
   --> src/seriate/mod.rs:106:77
    |
106 |             |data_input: DataInput| Histogram::read_as_preprocessed(layout, data_input);
    |                                                                             ^^^^^^^^^^
    |                                                                             |
    |                                                                             expected `&DataInput`, found struct `DataInput`
    |                                                                             help: consider borrowing here: `&data_input`

error[E0308]: mismatched types
   --> src/seriate/mod.rs:107:39
    |
106 |             |data_input: DataInput| Histogram::read_as_preprocessed(layout, data_input);
    |             --------------------------------------------------------------------------- the found closure
107 |         let h = Self::from_byte_array(serialization_reader, serialized_histogram);
    |                                       ^^^^^^^^^^^^^^^^^^^^ expected struct `SerializationReader`, found closure
    |
    = note: expected struct `SerializationReader`
              found closure `[closure@src/seriate/mod.rs:106:13: 106:88]`

error[E0220]: associated type `L` not found for `Self`
   --> src/seriate/mod.rs:127:41
    |
127 |         return Ok(Self::compress(&Self::L::write(histogram)));
    |                                         ^ associated type `L` not found

error[E0308]: mismatched types
   --> src/seriate/mod.rs:127:19
    |
127 |         return Ok(Self::compress(&Self::L::write(histogram)));
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found enum `Result`
    |
    = note: expected struct `Vec<_>`
                 found enum `Result<Vec<_>, Rc<DynaHistError>>`

error[E0308]: mismatched types
   --> src/seriate/mod.rs:151:68
    |
151 |         let h = Histogram::read_as_static(layout, Self::decompress(&serialized_histogram));
    |                                                                    ^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `&&Vec<i8>`
    |
    = note: expected struct `Vec<i8>`
            found reference `&&Vec<i8>`
help: try using a conversion method
    |
151 |         let h = Histogram::read_as_static(layout, Self::decompress((&serialized_histogram).to_vec()));
    |                                                                    ^                     ^^^^^^^^^^

error[E0308]: mismatched types
   --> src/seriate/mod.rs:151:51
    |
151 |         let h = Histogram::read_as_static(layout, Self::decompress(&serialized_histogram));
    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&DataInput`, found enum `Result`
    |
    = note: expected reference `&DataInput`
                    found enum `Result<Vec<i8>, Rc<DynaHistError>>`

error[E0308]: mismatched types
   --> src/seriate/mod.rs:174:69
    |
174 |         let h = Histogram::read_as_dynamic(layout, Self::decompress(&serialized_histogram));
    |                                                                     ^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `&&Vec<i8>`
    |
    = note: expected struct `Vec<i8>`
            found reference `&&Vec<i8>`
help: try using a conversion method
    |
174 |         let h = Histogram::read_as_dynamic(layout, Self::decompress((&serialized_histogram).to_vec()));
    |                                                                     ^                     ^^^^^^^^^^

error[E0308]: mismatched types
   --> src/seriate/mod.rs:174:52
    |
174 |         let h = Histogram::read_as_dynamic(layout, Self::decompress(&serialized_histogram));
    |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&DataInput`, found enum `Result`
    |
    = note: expected reference `&DataInput`
                    found enum `Result<Vec<i8>, Rc<DynaHistError>>`

error[E0308]: mismatched types
   --> src/seriate/mod.rs:199:74
    |
199 |         let h = Histogram::read_as_preprocessed(layout, Self::decompress(&serialized_histogram));
    |                                                                          ^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `&&Vec<i8>`
    |
    = note: expected struct `Vec<i8>`
            found reference `&&Vec<i8>`
help: try using a conversion method
    |
199 |         let h = Histogram::read_as_preprocessed(layout, Self::decompress((&serialized_histogram).to_vec()));
    |                                                                          ^                     ^^^^^^^^^^

error[E0308]: mismatched types
   --> src/seriate/mod.rs:199:57
    |
199 |         let h = Histogram::read_as_preprocessed(layout, Self::decompress(&serialized_histogram));
    |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&DataInput`, found enum `Result`
    |
    = note: expected reference `&DataInput`
                    found enum `Result<Vec<i8>, Rc<DynaHistError>>`

error[E0107]: missing generics for struct `flate2::write::DeflateEncoder`
   --> src/seriate/mod.rs:206:46
    |
206 |                 let deflater: flate2::write::DeflateEncoder =
    |                                              ^^^^^^^^^^^^^^ expected 1 generic argument
    |
note: struct defined here, with 1 generic parameter: `W`
   --> /home/hedge/.cargo/registry/src/github.com-1ecc6299db9ec823/flate2-1.0.22/src/deflate/write.rs:35:12
    |
35  | pub struct DeflateEncoder<W: Write> {
    |            ^^^^^^^^^^^^^^ -
help: add missing generic argument
    |
206 |                 let deflater: flate2::write::DeflateEncoder<W> =
    |                                              ^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/seriate/mod.rs:205:13
    |
204 |         match bytes::BytesMut::with_capacity(1024) {
    |               ------------------------------------ this expression has type `BytesMut`
205 |             Ok(buffer) => {
    |             ^^^^^^^^^^ expected struct `BytesMut`, found enum `Result`
    |
    = note: expected struct `BytesMut`
                 found enum `Result<_, _>`

error[E0308]: mismatched types
   --> src/seriate/mod.rs:213:13
    |
204 |         match bytes::BytesMut::with_capacity(1024) {
    |               ------------------------------------ this expression has type `BytesMut`
...
213 |             Err(e1) => return Err(e1),
    |             ^^^^^^^ expected struct `BytesMut`, found enum `Result`
    |
    = note: expected struct `BytesMut`
                 found enum `Result<_, _>`

error[E0277]: the trait bound `Vec<i8>: From<bytes::Bytes>` is not satisfied
   --> src/seriate/mod.rs:210:40
    |
210 |                 let v: Vec<i8> = bytes.into();
    |                                        ^^^^ the trait `From<bytes::Bytes>` is not implemented for `Vec<i8>`
    |
    = help: the following implementations were found:
              <Vec<T, A> as From<Box<[T], A>>>
              <Vec<T, A> as From<VecDeque<T, A>>>
              <Vec<T> as From<&[T]>>
              <Vec<T> as From<&mut [T]>>
            and 6 others
    = note: required because of the requirements on the impl of `Into<Vec<i8>>` for `bytes::Bytes`

error[E0277]: the trait bound `bytes::Bytes: From<Vec<i8>>` is not satisfied
   --> src/seriate/mod.rs:222:15
    |
222 |         match bytes::Bytes::from(data) {
    |               ^^^^^^^^^^^^^^^^^^ the trait `From<Vec<i8>>` is not implemented for `bytes::Bytes`
    |
    = help: the following implementations were found:
              <bytes::Bytes as From<&'static [u8]>>
              <bytes::Bytes as From<&'static str>>
              <bytes::Bytes as From<Box<[u8]>>>
              <bytes::Bytes as From<BytesMut>>
            and 2 others
note: required by `std::convert::From::from`
   --> /home/hedge/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:371:5
    |
371 |     fn from(_: T) -> Self;
    |     ^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/seriate/mod.rs:223:13
    |
222 |         match bytes::Bytes::from(data) {
    |               ------------------------ this expression has type `bytes::Bytes`
223 |             Ok(bytes) => match bytes.as_ref() {
    |             ^^^^^^^^^ expected struct `bytes::Bytes`, found enum `Result`
    |
    = note: expected struct `bytes::Bytes`
                 found enum `Result<_, _>`

error[E0308]: mismatched types
   --> src/seriate/mod.rs:233:13
    |
222 |         match bytes::Bytes::from(data) {
    |               ------------------------ this expression has type `bytes::Bytes`
...
233 |             Err(e1) => return Err(e1),
    |             ^^^^^^^ expected struct `bytes::Bytes`, found enum `Result`
    |
    = note: expected struct `bytes::Bytes`
                 found enum `Result<_, _>`

error[E0277]: the trait bound `Vec<i8>: std::io::Read` is not satisfied
   --> src/seriate/mod.rs:226:74
    |
226 |                     let mut inflater = flate2::read::DeflateDecoder::new(v);
    |                                                                          ^ the trait `std::io::Read` is not implemented for `Vec<i8>`
    |
note: required by `flate2::read::DeflateDecoder::<R>::new`
   --> /home/hedge/.cargo/registry/src/github.com-1ecc6299db9ec823/flate2-1.0.22/src/deflate/read.rs:175:5
    |
175 |     pub fn new(r: R) -> DeflateDecoder<R> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `write_all` found for struct `flate2::read::DeflateDecoder` in the current scope
   --> src/seriate/mod.rs:227:30
    |
227 |                     inflater.write_all(buffer)?;
    |                              ^^^^^^^^^ method not found in `flate2::read::DeflateDecoder<Vec<i8>>`

error[E0599]: no method named `finish` found for struct `flate2::read::DeflateDecoder` in the current scope
   --> src/seriate/mod.rs:228:34
    |
228 |                     v = inflater.finish()?;
    |                                  ^^^^^^ method not found in `flate2::read::DeflateDecoder<Vec<i8>>`

error[E0277]: the trait bound `bytes::Bytes: From<&Vec<i8>>` is not satisfied
   --> src/seriate/mod.rs:266:15
    |
266 |         match bytes::Bytes::from(&byte_array) {
    |               ^^^^^^^^^^^^^^^^^^ the trait `From<&Vec<i8>>` is not implemented for `bytes::Bytes`
    |
    = help: the following implementations were found:
              <bytes::Bytes as From<&'static [u8]>>
              <bytes::Bytes as From<&'static str>>
              <bytes::Bytes as From<Box<[u8]>>>
              <bytes::Bytes as From<BytesMut>>
            and 2 others
note: required by `std::convert::From::from`
   --> /home/hedge/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:371:5
    |
371 |     fn from(_: T) -> Self;
    |     ^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/seriate/mod.rs:267:13
    |
266 |         match bytes::Bytes::from(&byte_array) {
    |               ------------------------------- this expression has type `bytes::Bytes`
267 |             Ok(bytes) => match bytes.as_ref() {
    |             ^^^^^^^^^ expected struct `bytes::Bytes`, found enum `Result`
    |
    = note: expected struct `bytes::Bytes`
                 found enum `Result<_, _>`

error[E0308]: mismatched types
   --> src/seriate/mod.rs:271:13
    |
266 |         match bytes::Bytes::from(&byte_array) {
    |               ------------------------------- this expression has type `bytes::Bytes`
...
271 |             Err(e1) => return Err(e1),
    |             ^^^^^^^ expected struct `bytes::Bytes`, found enum `Result`
    |
    = note: expected struct `bytes::Bytes`
                 found enum `Result<_, _>`

error[E0599]: no method named `read` found for struct `SerializationReader` in the current scope
   --> src/seriate/mod.rs:268:62
    |
268 |                 Ok(buffer) => return Ok(serialization_reader.read(buffer)),
    |                                                              ^^^^ method not found in `SerializationReader`
    |
   ::: src/seriate/deserialization.rs:24:1
    |
24  | pub struct SerializationReader{
    | ------------------------------ method `read` not found for this
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `read`, perhaps you need to implement one of them:
            candidate #1: `SeriateRead`
            candidate #2: `std::io::Read`

error[E0308]: mismatched types
   --> src/seriate/mod.rs:290:13
    |
289 |         match bytes::BytesMut::with_capacity(1024) {
    |               ------------------------------------ this expression has type `BytesMut`
290 |             Ok(buffer) => {
    |             ^^^^^^^^^^ expected struct `BytesMut`, found enum `Result`
    |
    = note: expected struct `BytesMut`
                 found enum `Result<_, _>`

error[E0308]: mismatched types
   --> src/seriate/mod.rs:296:13
    |
289 |         match bytes::BytesMut::with_capacity(1024) {
    |               ------------------------------------ this expression has type `BytesMut`
...
296 |             Err(e1) => return Err(e1),
    |             ^^^^^^^ expected struct `BytesMut`, found enum `Result`
    |
    = note: expected struct `BytesMut`
                 found enum `Result<_, _>`

error[E0599]: no method named `write` found for struct `SerializationWriter` in the current scope
   --> src/seriate/mod.rs:291:38
    |
291 |                 serialization_writer.write(data, &buffer);
    |                                      ^^^^^ this is an associated function, not a method
    |
   ::: src/seriate/serialization.rs:24:1
    |
24  | pub struct SerializationWriter {
    | ------------------------------ method `write` not found for this
    |
    = note: found the following associated functions; to be used as methods, functions must have a `self` parameter
note: the candidate is defined in the trait `Seriate`
   --> src/seriate/mod.rs:436:5
    |
436 |     fn write(histogram: impl Histogram) -> Result<Vec<i8>, std::rc::Rc<DynaHistError>> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `write`, perhaps you need to implement one of them:
            candidate #1: `SeriateWrite`
            candidate #2: `Seriate`
            candidate #3: `AbstractMutableHistogram`
            candidate #4: `Histogram`
            candidate #5: `std::io::Write`
            candidate #6: `Hasher`
help: use associated function syntax instead
    |
291 |                 SerializationWriter::write(data, &buffer);
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for the candidate
    |
291 |                 Seriate::write(serialization_writer, data, &buffer);
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: the trait bound `Vec<i8>: From<bytes::Bytes>` is not satisfied
   --> src/seriate/mod.rs:293:40
    |
293 |                 let v: Vec<i8> = bytes.into();
    |                                        ^^^^ the trait `From<bytes::Bytes>` is not implemented for `Vec<i8>`
    |
    = help: the following implementations were found:
              <Vec<T, A> as From<Box<[T], A>>>
              <Vec<T, A> as From<VecDeque<T, A>>>
              <Vec<T> as From<&[T]>>
              <Vec<T> as From<&mut [T]>>
            and 6 others
    = note: required because of the requirements on the impl of `Into<Vec<i8>>` for `bytes::Bytes`

error[E0308]: mismatched types
   --> src/seriate/mod.rs:311:47
    |
311 |               return Err(DynaHistError::IOError(&dth_version_clash!(
    |  _______________________________________________^
312 | |                 expected_serial_version,
313 | |                 current_serial_version
314 | |             )));
    | |_____________^ expected struct `anyhow::Error`, found `&String`

error[E0308]: mismatched types
   --> src/seriate/mod.rs:311:24
    |
311 |               return Err(DynaHistError::IOError(&dth_version_clash!(
    |  ________________________^
312 | |                 expected_serial_version,
313 | |                 current_serial_version
314 | |             )));
    | |______________^ expected struct `Rc`, found enum `DynaHistError`
    |
    = note: expected struct `Rc<DynaHistError>`
                 found enum `DynaHistError`

error[E0308]: mismatched types
   --> src/seriate/mod.rs:333:49
    |
333 |       ) -> Result<(), std::rc::Rc<DynaHistError>> {
    |  _________________________________________________^
334 | |         Self::write_unsigned_var_int((value << 1) ^ (value >> 31), &data_output);
    | |                                                                                 - help: consider removing this semicolon
335 | |     }
    | |_____^ expected enum `Result`, found `()`
    |
    = note:   expected enum `Result<(), Rc<DynaHistError>>`
            found unit type `()`

error[E0599]: no method named `write_byte` found for reference `&DataOutput` in the current scope
   --> src/seriate/mod.rs:351:25
    |
351 |             data_output.write_byte((value & 0x7F) | 0x80);
    |                         ^^^^^^^^^^ method not found in `&DataOutput`

error[E0599]: no method named `write_byte` found for reference `&DataOutput` in the current scope
   --> src/seriate/mod.rs:354:21
    |
354 |         data_output.write_byte(value & 0x7F);
    |                     ^^^^^^^^^^ method not found in `&DataOutput`

error[E0308]: mismatched types
   --> src/seriate/mod.rs:349:49
    |
349 |       ) -> Result<(), std::rc::Rc<DynaHistError>> {
    |  _________________________________________________^
350 | |         while (value & 0xFFFFFF80) != 0 {
351 | |             data_output.write_byte((value & 0x7F) | 0x80);
352 | |             value >>= /* >>>= */ 7;
353 | |         }
354 | |         data_output.write_byte(value & 0x7F);
355 | |     }
    | |_____^ expected enum `Result`, found `()`
    |
    = note:   expected enum `Result<(), Rc<DynaHistError>>`
            found unit type `()`

error[E0599]: no method named `read_byte` found for reference `&DataInput` in the current scope
   --> src/seriate/mod.rs:371:32
    |
371 |         while ((b = data_input.read_byte()) & 0x80) != 0 {
    |                                ^^^^^^^^^ method not found in `&DataInput`

error[E0308]: mismatched types
   --> src/seriate/mod.rs:376:21
    |
376 |                     &Self::ENCOUNTERED_UNEXPECTED_DATA_MSG,
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `anyhow::Error`, found `&&'static str`

error[E0308]: mismatched types
   --> src/seriate/mod.rs:375:28
    |
375 |                   return Err(DynaHistError::IOError(
    |  ____________________________^
376 | |                     &Self::ENCOUNTERED_UNEXPECTED_DATA_MSG,
377 | |                 ));
    | |_________________^ expected struct `Rc`, found enum `DynaHistError`
    |
    = note: expected struct `Rc<DynaHistError>`
                 found enum `DynaHistError`

error[E0308]: mismatched types
   --> src/seriate/mod.rs:394:24
    |
394 |         let raw: i32 = Self::read_unsigned_var_int(&data_input);
    |                  ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found enum `Result`
    |                  |
    |                  expected due to this
    |
    = note: expected type `i32`
               found enum `Result<i32, Rc<DynaHistError>>`

error[E0599]: no method named `read_byte` found for reference `&DataInput` in the current scope
   --> src/seriate/mod.rs:411:32
    |
411 |         while ((b = data_input.read_byte()) & 0x80) != 0 {
    |                                ^^^^^^^^^ method not found in `&DataInput`

error[E0308]: mismatched types
   --> src/seriate/mod.rs:416:21
    |
416 |                     &Self::ENCOUNTERED_UNEXPECTED_DATA_MSG,
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `anyhow::Error`, found `&&'static str`

error[E0308]: mismatched types
   --> src/seriate/mod.rs:415:28
    |
415 |                   return Err(DynaHistError::IOError(
    |  ____________________________^
416 | |                     &Self::ENCOUNTERED_UNEXPECTED_DATA_MSG,
417 | |                 ));
    | |_________________^ expected struct `Rc`, found enum `DynaHistError`
    |
    = note: expected struct `Rc<DynaHistError>`
                 found enum `DynaHistError`

error[E0599]: no function or associated item named `to_byte_array` found for type parameter `Self` in the current scope
   --> src/seriate/mod.rs:437:25
    |
437 |         return Ok(Self::to_byte_array(Histogram::write, histogram));
    |                         ^^^^^^^^^^^^^ function or associated item not found in `Self`
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `to_byte_array`, perhaps you need to add a supertrait for it:
    |
301 | pub trait Seriate: SeriateHistogram {
    |                  ^^^^^^^^^^^^^^^^^^

error[E0277]: the size for values of type `Self` cannot be known at compilation time
  --> src/quantiles/quantile_estimation.rs:43:40
   |
43 |     fn new(alphap: f64, betap: f64) -> Self {
   |                                        ^^^^ doesn't have a size known at compile-time
   |
   = note: the return type of a function must have a statically known size
help: consider further restricting `Self`
   |
43 |     fn new(alphap: f64, betap: f64) -> Self where Self: Sized {
   |                                             ^^^^^^^^^^^^^^^^^

error[E0277]: the size for values of type `Self` cannot be known at compilation time
  --> src/quantiles/quantile_estimation.rs:44:9
   |
44 |         Self::create(alphap, betap)
   |         ^^^^^^^^^^^^ doesn't have a size known at compile-time
   |
   = note: the return type of a function must have a statically known size
help: consider further restricting `Self`
   |
43 |     fn new(alphap: f64, betap: f64) -> Self where Self: Sized {
   |                                             ^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `default` found for type parameter `Self` in the current scope
  --> src/quantiles/quantile_estimation.rs:66:21
   |
66 |             ..Self::default()
   |                     ^^^^^^^ function or associated item not found in `Self`
   |
   = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `default`, perhaps you need to add another supertrait for it:
   |
22 |     Preconditions + Algorithms + ValueEstimation + Default
   |                                                  ^^^^^^^^^

error[E0277]: the trait bound `QuantileEstimator: QuantileEstimation` is not satisfied
  --> src/quantiles/quantile_estimation.rs:68:50
   |
68 |         return self.get_quantile_from_qestimator(quantile_estimator);
   |                                                  ^^^^^^^^^^^^^^^^^^ the trait `QuantileEstimation` is not implemented for `QuantileEstimator`

error[E0609]: no field `vestimator` on type `impl QuantileEstimation`
  --> src/quantiles/quantile_estimation.rs:88:37
   |
88 |         let ve = quantile_estimator.vestimator;
   |                                     ^^^^^^^^^^

error[E0599]: no method named `get_value_from_estimator` found for reference `&Self` in the current scope
  --> src/quantiles/quantile_estimation.rs:89:35
   |
89 |         let rank_fn = |rank| self.get_value_from_estimator(rank, ve);
   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following traits define an item `get_value_from_estimator`, perhaps you need to add another supertrait for one of them:
   |
22 |     Preconditions + Algorithms + ValueEstimation + AbstractHistogram
   |                                                  ^^^^^^^^^^^^^^^^^^^
22 |     Preconditions + Algorithms + ValueEstimation + Histogram
   |                                                  ^^^^^^^^^^^
help: there is an associated function with a similar name
   |
89 |         let rank_fn = |rank| self.get_quantile_from_estimators(rank, ve);
   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0609]: no field `p` on type `impl QuantileEstimation`
  --> src/quantiles/quantile_estimation.rs:91:32
   |
91 |             quantile_estimator.p,
   |                                ^

error[E0599]: no function or associated item named `get_total_count` found for type parameter `Self` in the current scope
  --> src/quantiles/quantile_estimation.rs:93:20
   |
93 |             &Self::get_total_count(),
   |                    ^^^^^^^^^^^^^^^ function or associated item not found in `Self`
   |
   = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following traits define an item `get_total_count`, perhaps you need to add another supertrait for one of them:
   |
22 |     Preconditions + Algorithms + ValueEstimation + AbstractMutableHistogram
   |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^
22 |     Preconditions + Algorithms + ValueEstimation + Histogram
   |                                                  ^^^^^^^^^^^

error[E0599]: no associated item named `DEFAULT_QUANTILE_ESTIMATOR` found for type parameter `Self` in the current scope
   --> src/quantiles/quantile_estimation.rs:114:19
    |
114 |             Self::DEFAULT_QUANTILE_ESTIMATOR,
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^ associated item not found in `Self`

error[E0599]: no method named `estimate_quantile` found for type parameter `impl QuantileEstimation` in the current scope
   --> src/quantiles/quantile_estimation.rs:141:35
    |
141 |         return quantile_estimator.estimate_quantile(
    |                                   ^^^^^^^^^^^^^^^^^ method not found in `impl QuantileEstimation`

error[E0599]: no function or associated item named `get_total_count` found for type parameter `Self` in the current scope
   --> src/quantiles/quantile_estimation.rs:144:20
    |
144 |             &Self::get_total_count(),
    |                    ^^^^^^^^^^^^^^^ function or associated item not found in `Self`
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following traits define an item `get_total_count`, perhaps you need to add another supertrait for one of them:
    |
22  |     Preconditions + Algorithms + ValueEstimation + AbstractMutableHistogram
    |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^
22  |     Preconditions + Algorithms + ValueEstimation + Histogram
    |                                                  ^^^^^^^^^^^

error[E0599]: no method named `get_value_from_estimator` found for reference `&Self` in the current scope
   --> src/quantiles/quantile_estimation.rs:143:26
    |
143 |             |&rank| self.get_value_from_estimator(rank, value_estimator),
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following traits define an item `get_value_from_estimator`, perhaps you need to add another supertrait for one of them:
    |
22  |     Preconditions + Algorithms + ValueEstimation + AbstractHistogram
    |                                                  ^^^^^^^^^^^^^^^^^^^
22  |     Preconditions + Algorithms + ValueEstimation + Histogram
    |                                                  ^^^^^^^^^^^
help: there is an associated function with a similar name
    |
143 |             |&rank| self.get_quantile_from_estimators(rank, value_estimator),
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/quantiles/quantile_estimation.rs:176:50
    |
175 |         let rank_fn = |&rank| sorted_values[rank as usize];
    |                       ------------------------------------ the found closure
176 |         return self.estimate_quantile_from_fn(p, rank_fn, sorted_values.len());
    |                                                  ^^^^^^^ expected `&fn(u64) -> f64`, found closure
    |
    = note: expected reference `&fn(u64) -> f64`
                 found closure `[closure@src/quantiles/quantile_estimation.rs:175:23: 175:59]`

error[E0308]: mismatched types
   --> src/quantiles/quantile_estimation.rs:176:59
    |
176 |         return self.estimate_quantile_from_fn(p, rank_fn, sorted_values.len());
    |                                                           ^^^^^^^^^^^^^^^^^^^ expected `i64`, found `usize`
    |
help: you can convert a `usize` to an `i64` and panic if the converted value doesn't fit
    |
176 |         return self.estimate_quantile_from_fn(p, rank_fn, sorted_values.len().try_into().unwrap());
    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/quantiles/quantile_estimators.rs:25:9
   |
23 |     fn default() -> Self {
   |                     ---- expected `QEstimator` because of return type
24 |         // This default is used in SciPy 1.5.2
25 |         SciPyQuantileEstimator::create(0.4, 0.4)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `QEstimator`, found struct `SciPyQuantileEstimator`

error[E0308]: mismatched types
  --> src/quantiles/quantile_estimators.rs:31:9
   |
30 |     fn default() -> Self {
   |                     ---- expected `VEstimator` because of return type
31 |         ValueEstimatorUniform::new()
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `VEstimator`, found struct `value_estimators::ValueEstimatorUniform`

error[E0034]: multiple applicable items in scope
  --> src/quantiles/quantile_estimators.rs:86:22
   |
86 |         return Self::new(alphap, betap);
   |                      ^^^ multiple `new` found
   |
note: candidate #1 is defined in an impl of the trait `ValueEstimation` for the type `SciPyQuantileEstimator`
  --> src/values/value_estimation.rs:22:5
   |
22 |     fn new() -> Self;
   |     ^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl of the trait `QuantileEstimation` for the type `SciPyQuantileEstimator`
  --> src/quantiles/quantile_estimators.rs:98:5
   |
98 |     fn new(alphap: f64, betap: f64) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
   |
86 |         return ValueEstimation::new(alphap, betap);
   |                ^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
   |
86 |         return QuantileEstimation::new(alphap, betap);
   |                ^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `apply_as_double` found for reference `&fn(u64) -> f64` in the current scope
   --> src/quantiles/quantile_estimators.rs:111:28
    |
111 |             return rank_fn.apply_as_double(0);
    |                            ^^^^^^^^^^^^^^^ method not found in `&fn(u64) -> f64`
    |
    = note: `rank_fn` is a function, perhaps you wish to call it

error[E0308]: mismatched types
   --> src/quantiles/quantile_estimators.rs:113:43
    |
113 |         let z: f64 = Self::interpolate(p, 0, self.alphap - 1.0, 1, num_values - self.betap);
    |                                           ^
    |                                           |
    |                                           expected `f64`, found integer
    |                                           help: use a float literal: `0.0`

error[E0308]: mismatched types
   --> src/quantiles/quantile_estimators.rs:113:65
    |
113 |         let z: f64 = Self::interpolate(p, 0, self.alphap - 1.0, 1, num_values - self.betap);
    |                                                                 ^
    |                                                                 |
    |                                                                 expected `f64`, found integer
    |                                                                 help: use a float literal: `1.0`

error[E0277]: cannot subtract `f64` from `i64`
   --> src/quantiles/quantile_estimators.rs:113:79
    |
113 |         let z: f64 = Self::interpolate(p, 0, self.alphap - 1.0, 1, num_values - self.betap);
    |                                                                               ^ no implementation for `i64 - f64`
    |
    = help: the trait `Sub<f64>` is not implemented for `i64`

error[E0599]: no method named `apply_as_double` found for reference `&fn(u64) -> f64` in the current scope
   --> src/quantiles/quantile_estimators.rs:115:28
    |
115 |             return rank_fn.apply_as_double(0);
    |                            ^^^^^^^^^^^^^^^ method not found in `&fn(u64) -> f64`
    |
    = note: `rank_fn` is a function, perhaps you wish to call it

error[E0277]: cannot subtract `{float}` from `i64`
   --> src/quantiles/quantile_estimators.rs:117:28
    |
117 |         if z >= num_values - 1.0 {
    |                            ^ no implementation for `i64 - {float}`
    |
    = help: the trait `Sub<{float}>` is not implemented for `i64`

error[E0599]: no method named `apply_as_double` found for reference `&fn(u64) -> f64` in the current scope
   --> src/quantiles/quantile_estimators.rs:118:28
    |
118 |             return rank_fn.apply_as_double(num_values - 1);
    |                            ^^^^^^^^^^^^^^^ method not found in `&fn(u64) -> f64`
    |
    = note: `rank_fn` is a function, perhaps you wish to call it

error[E0277]: cannot subtract `i64` from `f64`
   --> src/quantiles/quantile_estimators.rs:121:38
    |
121 |         let z_fraction_part: f64 = z - z_int_part;
    |                                      ^ no implementation for `f64 - i64`
    |
    = help: the trait `Sub<i64>` is not implemented for `f64`

error[E0599]: no method named `apply_as_double` found for reference `&fn(u64) -> f64` in the current scope
   --> src/quantiles/quantile_estimators.rs:123:28
    |
123 |             return rank_fn.apply_as_double(z_int_part);
    |                            ^^^^^^^^^^^^^^^ method not found in `&fn(u64) -> f64`
    |
    = note: `rank_fn` is a function, perhaps you wish to call it

error[E0599]: no method named `apply_as_double` found for reference `&fn(u64) -> f64` in the current scope
   --> src/quantiles/quantile_estimators.rs:125:31
    |
125 |         let y1: f64 = rank_fn.apply_as_double(z_int_part);
    |                               ^^^^^^^^^^^^^^^ method not found in `&fn(u64) -> f64`
    |
    = note: `rank_fn` is a function, perhaps you wish to call it

error[E0599]: no method named `apply_as_double` found for reference `&fn(u64) -> f64` in the current scope
   --> src/quantiles/quantile_estimators.rs:126:31
    |
126 |         let y2: f64 = rank_fn.apply_as_double(z_int_part + 1);
    |                               ^^^^^^^^^^^^^^^ method not found in `&fn(u64) -> f64`
    |
    = note: `rank_fn` is a function, perhaps you wish to call it

error[E0308]: mismatched types
   --> src/quantiles/quantile_estimators.rs:127:51
    |
127 |         return Self::interpolate(z_fraction_part, 0, y1, 1, y2);
    |                                                   ^
    |                                                   |
    |                                                   expected `f64`, found integer
    |                                                   help: use a float literal: `0.0`

error[E0308]: mismatched types
   --> src/quantiles/quantile_estimators.rs:127:58
    |
127 |         return Self::interpolate(z_fraction_part, 0, y1, 1, y2);
    |                                                          ^
    |                                                          |
    |                                                          expected `f64`, found integer
    |                                                          help: use a float literal: `1.0`

error[E0277]: `?` couldn't convert the error to `DynaHistError`
   --> src/sketches/data.rs:42:49
    |
42  |             data: bool::read_from(buffer, order)?,
    |                                                 ^ the trait `From<std::io::Error>` is not implemented for `DynaHistError`
    |
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait
    = help: the following implementations were found:
              <DynaHistError as From<anyhow::Error>>
    = note: required because of the requirements on the impl of `FromResidual<Result<Infallible, std::io::Error>>` for `Result<DataInput, DynaHistError>`
note: required by `from_residual`
   --> /home/hedge/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/try_trait.rs:339:5
    |
339 |     fn from_residual(residual: R) -> Self;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0609]: no field `bar` on type `&DataOutput`
  --> src/sketches/data.rs:53:14
   |
53 |         self.bar.write_to(buffer, order)?;
   |              ^^^ unknown field
   |
   = note: available fields are: `data`

error[E0599]: no method named `quantiles` found for reference `&Quantiles<T>` in the current scope
  --> src/histograms/abstract_histogram.rs:73:14
   |
73 |         self.quantiles().next()
   |              ^^^^^^^^^ method not found in `&Quantiles<T>`

error[E0308]: mismatched types
   --> src/histograms/abstract_histogram.rs:105:27
    |
105 |     fn into_iter(self) -> std::slice::Iter<'a, T> { /* ... */
    |        ---------          ^^^^^^^^^^^^^^^^^^^^^^^ expected struct `std::slice::Iter`, found `()`
    |        |
    |        implicitly returns `()` as its body has no tail or `return` expression
    |
    = note: expected struct `std::slice::Iter<'a, T>`
            found unit type `()`

error[E0308]: mismatched types
   --> src/histograms/abstract_histogram.rs:119:27
    |
119 |     fn into_iter(self) -> std::slice::IterMut<'a, T> { /* ... */
    |        ---------          ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `std::slice::IterMut`, found `()`
    |        |
    |        implicitly returns `()` as its body has no tail or `return` expression
    |
    = note: expected struct `std::slice::IterMut<'a, T>`
            found unit type `()`

error[E0308]: mismatched types
   --> src/histograms/abstract_histogram.rs:134:31
    |
124 | impl<T> IntoIterator for Quantiles<T>
    |      - this type parameter
...
134 |     fn into_iter(mut self) -> <T as std::iter::IntoIterator>::IntoIter { /* ... */
    |        ---------              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`
    |        |
    |        implicitly returns `()` as its body has no tail or `return` expression
    |
    = note: expected type parameter `T`
                    found unit type `()`

error[E0609]: no field `0` on type `&mut Percentiles<T>`
   --> src/histograms/abstract_histogram.rs:194:17
    |
194 |         if self.0 < self.1 {
    |                 ^ unknown field
    |
    = note: available fields are: `_marker`

error[E0609]: no field `1` on type `&mut Percentiles<T>`
   --> src/histograms/abstract_histogram.rs:194:26
    |
194 |         if self.0 < self.1 {
    |                          ^ unknown field
    |
    = note: available fields are: `_marker`

error[E0609]: no field `0` on type `&mut Percentiles<T>`
   --> src/histograms/abstract_histogram.rs:195:26
    |
195 |             let v = self.0.clone();
    |                          ^ unknown field
    |
    = note: available fields are: `_marker`

error[E0609]: no field `0` on type `&mut Percentiles<T>`
   --> src/histograms/abstract_histogram.rs:196:18
    |
196 |             self.0 = &v + &self.2;
    |                  ^ unknown field
    |
    = note: available fields are: `_marker`

error[E0609]: no field `2` on type `&mut Percentiles<T>`
   --> src/histograms/abstract_histogram.rs:196:33
    |
196 |             self.0 = &v + &self.2;
    |                                 ^ unknown field
    |
    = note: available fields are: `_marker`

error[E0277]: the size for values of type `Self` cannot be known at compilation time
   --> src/histograms/abstract_histogram.rs:296:36
    |
296 |     fn new(layout: impl Layout) -> Self {
    |                                    ^^^^ doesn't have a size known at compile-time
    |
    = note: the return type of a function must have a statically known size
help: consider further restricting `Self`
    |
296 |     fn new(layout: impl Layout) -> Self where Self: Sized {
    |                                         ^^^^^^^^^^^^^^^^^

error[E0277]: the trait bound `Self: Default` is not satisfied
   --> src/histograms/abstract_histogram.rs:297:9
    |
297 |         Default::default()
    |         ^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `Self`
    |
note: required by `std::default::Default::default`
   --> /home/hedge/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/default.rs:116:5
    |
116 |     fn default() -> Self;
    |     ^^^^^^^^^^^^^^^^^^^^^
help: consider further restricting `Self`
    |
296 |     fn new(layout: impl Layout) -> Self where Self: Default {
    |                                         ^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/abstract_histogram.rs:301:9
    |
301 |         ValueEstimatorUniform::new()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found struct `value_estimators::ValueEstimatorUniform`
    |
help: consider using a semicolon here
    |
301 |         ValueEstimatorUniform::new();
    |                                     ^
help: try adding a return type
    |
300 |     fn default_value_estimator()-> value_estimators::ValueEstimatorUniform {
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0609]: no field `layout` on type `&Self`
   --> src/histograms/abstract_histogram.rs:375:21
    |
264 | / pub trait AbstractHistogram: Histogram + Probability {
265 | |     //type L: Layout;
266 | |     type H: Histogram;
267 | |     type B: BinIterator + BinSketch + std::iter::Iterator;
...   |
375 | |         return self.layout;
    | |                     ^^^^^^
...   |
463 | |     }
464 | | }
    | |_- type parameter 'Self' declared here

error[E0221]: ambiguous associated type `B` in bounds of `Self`
   --> src/histograms/abstract_histogram.rs:382:27
    |
267 |     type B: BinIterator + BinSketch + std::iter::Iterator;
    |     ------------------------------------------------------ ambiguous `B` from `AbstractHistogram`
...
382 |         let bin_iterator: Self::B;
    |                           ^^^^^^^ ambiguous associated type `B`
    |
   ::: src/histograms/histogram.rs:22:5
    |
22  |     type B: BinIterator + BinSketch + Iterator;
    |     ------------------------------------------- ambiguous `B` from `Histogram`
    |
help: use fully qualified syntax to disambiguate
    |
382 |         let bin_iterator: <Self as Histogram>::B;
    |                           ^^^^^^^^^^^^^^^^^^^^^^
help: use fully qualified syntax to disambiguate
    |
382 |         let bin_iterator: <Self as AbstractHistogram>::B;
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0061]: this function takes 1 argument but 0 arguments were supplied
   --> src/histograms/abstract_histogram.rs:379:32
    |
379 |         let total_count: i64 = Self::get_total_count();
    |                                ^^^^^^^^^^^^^^^^^^^^^-- supplied 0 arguments
    |                                |
    |                                expected 1 argument
    |
note: associated function defined here
   --> src/histograms/histogram.rs:105:8
    |
105 |     fn get_total_count(&self) -> i64;
    |        ^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `check_argument` found for type parameter `Self` in the current scope
   --> src/histograms/abstract_histogram.rs:380:15
    |
380 |         Self::check_argument(rank >= 0);
    |               ^^^^^^^^^^^^^^ function or associated item not found in `Self`
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `check_argument`, perhaps you need to add another supertrait for it:
    |
264 | pub trait AbstractHistogram: Histogram + Probability + Preconditions {
    |                                                      ^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `check_argument` found for type parameter `Self` in the current scope
   --> src/histograms/abstract_histogram.rs:381:15
    |
381 |         Self::check_argument(rank < total_count);
    |               ^^^^^^^^^^^^^^ function or associated item not found in `Self`
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `check_argument`, perhaps you need to add another supertrait for it:
    |
264 | pub trait AbstractHistogram: Histogram + Probability + Preconditions {
    |                                                      ^^^^^^^^^^^^^^^

error[E0061]: this function takes 1 argument but 0 arguments were supplied
   --> src/histograms/abstract_histogram.rs:384:28
    |
384 |             bin_iterator = Self::get_first_non_empty_bin();
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-- supplied 0 arguments
    |                            |
    |                            expected 1 argument
    |
note: associated function defined here
   --> src/histograms/histogram.rs:42:8
    |
42  |     fn get_first_non_empty_bin(&self) -> &Self::B;
    |        ^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/abstract_histogram.rs:384:28
    |
384 |             bin_iterator = Self::get_first_non_empty_bin();
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected associated type, found reference
    |
    = note: expected associated type `<Self as Histogram>::B`
                     found reference `&<Self as Histogram>::B`
    = help: consider constraining the associated type `<Self as Histogram>::B` to `&<Self as Histogram>::B` or calling a method that returns `<Self as Histogram>::B`
    = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html

error[E0061]: this function takes 1 argument but 0 arguments were supplied
   --> src/histograms/abstract_histogram.rs:389:28
    |
389 |             bin_iterator = Self::get_last_non_empty_bin();
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^-- supplied 0 arguments
    |                            |
    |                            expected 1 argument
    |
note: associated function defined here
   --> src/histograms/histogram.rs:55:8
    |
55  |     fn get_last_non_empty_bin(&self) -> &Self::B;
    |        ^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/abstract_histogram.rs:389:28
    |
389 |             bin_iterator = Self::get_last_non_empty_bin();
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected associated type, found reference
    |
    = note: expected associated type `<Self as Histogram>::B`
                     found reference `&<Self as Histogram>::B`
    = help: consider constraining the associated type `<Self as Histogram>::B` to `&<Self as Histogram>::B` or calling a method that returns `<Self as Histogram>::B`
    = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html

error[E0308]: mismatched types
   --> src/histograms/abstract_histogram.rs:394:16
    |
378 |     fn get_bin_by_rank(&self, rank: i64) -> <Self as AbstractHistogram>::B {
    |                                             ------------------------------ expected `<Self as AbstractHistogram>::B` because of return type
...
394 |         return bin_iterator;
    |                ^^^^^^^^^^^^ expected AbstractHistogram::B, found Histogram::B
    |
    = note: expected associated type `<Self as AbstractHistogram>::B`
               found associated type `<Self as Histogram>::B`

error[E0061]: this function takes 1 argument but 0 arguments were supplied
   --> src/histograms/abstract_histogram.rs:398:16
    |
398 |         return Self::get_total_count() == 0;
    |                ^^^^^^^^^^^^^^^^^^^^^-- supplied 0 arguments
    |                |
    |                expected 1 argument
    |
note: associated function defined here
   --> src/histograms/histogram.rs:105:8
    |
105 |     fn get_total_count(&self) -> i64;
    |        ^^^^^^^^^^^^^^^

error[E0277]: the trait bound `&Self: Histogram` is not satisfied
   --> src/histograms/abstract_histogram.rs:402:51
    |
402 |         return value_estimator.get_value_estimate(self, rank);
    |                                                   ^^^^ the trait `Histogram` is not implemented for `&Self`

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_histogram.rs:406:21
    |
406 |         return self.get_value_from_estimator(rank, Self::default_value_estimator());
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^ multiple `get_value_from_estimator` found
    |
note: candidate #1 is defined in the trait `AbstractHistogram`
   --> src/histograms/abstract_histogram.rs:401:5
    |
401 |     fn get_value_from_estimator(&self, rank: i64, value_estimator: impl ValueEstimation) -> f64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:173:5
    |
173 |     fn get_value_from_estimator(&self, rank: i64, value_estimator: &Self::V) -> f64;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
406 |         return AbstractHistogram::get_value_from_estimator(&self, rank, Self::default_value_estimator());
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
406 |         return Histogram::get_value_from_estimator(&self, rank, Self::default_value_estimator());
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0624]: associated function `of` is private
   --> src/histograms/abstract_histogram.rs:410:39
    |
410 |         return PreprocessedHistogram::of(self);
    |                                       ^^ private associated function
    |
   ::: src/histograms/preprocessed_histogram.rs:128:5
    |
128 |     fn of( histogram: impl Histogram) -> Self {
    |     ----------------------------------------- private associated function defined here

error[E0277]: the trait bound `&Self: Histogram` is not satisfied
   --> src/histograms/abstract_histogram.rs:410:42
    |
410 |         return PreprocessedHistogram::of(self);
    |                                          ^^^^ the trait `Histogram` is not implemented for `&Self`
    |
   ::: src/histograms/preprocessed_histogram.rs:128:28
    |
128 |     fn of( histogram: impl Histogram) -> Self {
    |                            --------- required by this bound in `PreprocessedHistogram::of`

error[E0308]: mismatched types
   --> src/histograms/abstract_histogram.rs:420:50
    |
420 |         return self.add_histogram_from_estimator(histogram, Self::default_value_estimator());
    |                                                  ^^^^^^^^^ expected `&Self`, found associated type
    |
    = note:    expected reference `&Self`
            found associated type `<Self as AbstractHistogram>::H`
    = help: consider constraining the associated type `<Self as AbstractHistogram>::H` to `&Self`
    = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html

error[E0308]: mismatched types
   --> src/histograms/abstract_histogram.rs:420:61
    |
420 |         return self.add_histogram_from_estimator(histogram, Self::default_value_estimator());
    |                                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected reference, found `()`
    |
    = note: expected reference `&<Self as Histogram>::V`
               found unit type `()`

error[E0308]: mismatched types
   --> src/histograms/abstract_histogram.rs:420:16
    |
264 | / pub trait AbstractHistogram: Histogram + Probability {
265 | |     //type L: Layout;
266 | |     type H: Histogram;
267 | |     type B: BinIterator + BinSketch + std::iter::Iterator;
...   |
419 | |     fn add_histogram(&self, histogram: Self::H) -> Self::H {
    | |                                                    ------- expected `<Self as AbstractHistogram>::H` because of return type
420 | |         return self.add_histogram_from_estimator(histogram, Self::default_value_estimator());
    | |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected associated type, found type parameter `Self`
...   |
463 | |     }
464 | | }
    | |_- this type parameter
    |
    = note: expected associated type `<Self as AbstractHistogram>::H`
                found type parameter `Self`
    = note: you might be missing a type parameter or trait bound

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_histogram.rs:424:17
    |
424 |         if self.is_empty() {
    |                 ^^^^^^^^ multiple `is_empty` found
    |
note: candidate #1 is defined in the trait `AbstractHistogram`
   --> src/histograms/abstract_histogram.rs:397:5
    |
397 |     fn is_empty(&self) -> bool {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:126:5
    |
126 |     fn is_empty(&self) -> bool;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
424 |         if AbstractHistogram::is_empty(&self) {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
424 |         if Histogram::is_empty(&self) {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/abstract_histogram.rs:425:20
    |
423 |     fn non_empty_bins_ascending(&self) -> &<Self as AbstractHistogram>::B {
    |                                           ------------------------------- expected `&<Self as AbstractHistogram>::B` because of return type
424 |         if self.is_empty() {
425 |             return vec![];
    |                    ^^^^^^ expected reference, found struct `Vec`
    |
    = note: expected reference `&<Self as AbstractHistogram>::B`
                  found struct `Vec<_>`
    = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0317]: `if` may be missing an `else` clause
   --> src/histograms/abstract_histogram.rs:424:9
    |
424 | /         if self.is_empty() {
425 | |             return vec![];
426 | |         }
    | |_________^ expected `()`, found reference
    |
    = note: expected unit type `()`
               found reference `&<Self as AbstractHistogram>::B`
    = note: `if` expressions without `else` evaluate to `()`
    = help: consider adding an `else` block that evaluates to the expected type

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_histogram.rs:445:17
    |
445 |         if self.is_empty() {
    |                 ^^^^^^^^ multiple `is_empty` found
    |
note: candidate #1 is defined in the trait `AbstractHistogram`
   --> src/histograms/abstract_histogram.rs:397:5
    |
397 |     fn is_empty(&self) -> bool {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:126:5
    |
126 |     fn is_empty(&self) -> bool;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
445 |         if AbstractHistogram::is_empty(&self) {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
445 |         if Histogram::is_empty(&self) {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no associated item named `B` found for type parameter `Self` in the current scope
   --> src/histograms/abstract_histogram.rs:446:32
    |
446 |             return &vec![Self::B];
    |                                ^ associated item not found in `Self`

error[E0308]: mismatched types
  --> src/histograms/abstract_mutable_histogram.rs:57:84
   |
57 |     fn new(bin_count: i64, less_count: i64, greater_count: i64, bin_index: i32) -> BinCopyImpl {
   |        --- implicitly returns `()` as its body has no tail or `return` expression  ^^^^^^^^^^^ expected struct `abstract_mutable_histogram::BinCopyImpl`, found `()`

error[E0308]: mismatched types
  --> src/histograms/abstract_mutable_histogram.rs:95:80
   |
95 |     fn new(bin_index: i32, less_count: i64, greater_count: i64, count: i64) -> BinIteratorImpl {
   |        ---                                                                     ^^^^^^^^^^^^^^^ expected struct `abstract_mutable_histogram::BinIteratorImpl`, found `()`
   |        |
   |        implicitly returns `()` as its body has no tail or `return` expression

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:116:20
    |
114 |     fn next(&self) {
    |                    - expected `()` because of default return type
115 |         if self.greater_count <= 0 {
116 |             return Err(DynaHistError::NoSuchElementError);
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found enum `Result`
    |
    = note: expected unit type `()`
                    found enum `Result<_, fn(anyhow::Error) -> DynaHistError {DynaHistError::NoSuchElementError}>`

error[E0599]: no method named `get_overflow_count` found for reference `&abstract_mutable_histogram::BinIteratorImpl` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:119:39
    |
119 |         if self.greater_count != self.get_overflow_count() {
    |                                       ^^^^^^^^^^^^^^^^^^ method not found in `&abstract_mutable_histogram::BinIteratorImpl`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `get_overflow_count`, perhaps you need to implement one of them:
            candidate #1: `AbstractMutableHistogram`
            candidate #2: `Histogram`

error[E0599]: no function or associated item named `get_layout` found for struct `abstract_mutable_histogram::BinIteratorImpl` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:120:40
    |
85  | pub struct BinIteratorImpl {
    | -------------------------- function or associated item `get_layout` not found for this
...
120 |             if self.bin_index == Self::get_layout().get_underflow_bin_index() {
    |                                        ^^^^^^^^^^ function or associated item not found in `abstract_mutable_histogram::BinIteratorImpl`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `get_layout`, perhaps you need to implement one of them:
            candidate #1: `AbstractHistogram`
            candidate #2: `Histogram`

error[E0599]: no method named `min_allocated_bin_index_inclusive` found for reference `&abstract_mutable_histogram::BinIteratorImpl` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:121:39
    |
121 |                 self.bin_index = self.min_allocated_bin_index_inclusive() - 1;
    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&abstract_mutable_histogram::BinIteratorImpl`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `AbstractMutableHistogram` defines an item `min_allocated_bin_index_inclusive`, perhaps you need to implement it
   --> src/histograms/abstract_mutable_histogram.rs:184:1
    |
184 | pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `get_allocated_bin_count` found for reference `&abstract_mutable_histogram::BinIteratorImpl` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:126:39
    |
126 |                     self.count = self.get_allocated_bin_count(self.bin_index);
    |                                       ^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&abstract_mutable_histogram::BinIteratorImpl`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `AbstractMutableHistogram` defines an item `get_allocated_bin_count`, perhaps you need to implement it
   --> src/histograms/abstract_mutable_histogram.rs:184:1
    |
184 | pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `get_layout` found for struct `abstract_mutable_histogram::BinIteratorImpl` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:134:36
    |
85  | pub struct BinIteratorImpl {
    | -------------------------- function or associated item `get_layout` not found for this
...
134 |             self.bin_index = Self::get_layout().get_overflow_bin_index();
    |                                    ^^^^^^^^^^ function or associated item not found in `abstract_mutable_histogram::BinIteratorImpl`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `get_layout`, perhaps you need to implement one of them:
            candidate #1: `AbstractHistogram`
            candidate #2: `Histogram`

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:142:20
    |
140 |     fn previous(&self) {
    |                        - expected `()` because of default return type
141 |         if self.less_count <= 0 {
142 |             return Err(DynaHistError::NoSuchElementError);
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found enum `Result`
    |
    = note: expected unit type `()`
                    found enum `Result<_, fn(anyhow::Error) -> DynaHistError {DynaHistError::NoSuchElementError}>`

error[E0599]: no method named `get_underflow_count` found for reference `&abstract_mutable_histogram::BinIteratorImpl` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:145:36
    |
145 |         if self.less_count != self.get_underflow_count() {
    |                                    ^^^^^^^^^^^^^^^^^^^ method not found in `&abstract_mutable_histogram::BinIteratorImpl`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `get_underflow_count`, perhaps you need to implement one of them:
            candidate #1: `AbstractMutableHistogram`
            candidate #2: `Histogram`

error[E0599]: no function or associated item named `get_layout` found for struct `abstract_mutable_histogram::BinIteratorImpl` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:146:40
    |
85  | pub struct BinIteratorImpl {
    | -------------------------- function or associated item `get_layout` not found for this
...
146 |             if self.bin_index == Self::get_layout().get_overflow_bin_index() {
    |                                        ^^^^^^^^^^ function or associated item not found in `abstract_mutable_histogram::BinIteratorImpl`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `get_layout`, perhaps you need to implement one of them:
            candidate #1: `AbstractHistogram`
            candidate #2: `Histogram`

error[E0599]: no method named `max_allocated_bin_index_exclusive` found for reference `&abstract_mutable_histogram::BinIteratorImpl` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:147:39
    |
147 |                 self.bin_index = self.max_allocated_bin_index_exclusive();
    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&abstract_mutable_histogram::BinIteratorImpl`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `AbstractMutableHistogram` defines an item `max_allocated_bin_index_exclusive`, perhaps you need to implement it
   --> src/histograms/abstract_mutable_histogram.rs:184:1
    |
184 | pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `get_allocated_bin_count` found for reference `&abstract_mutable_histogram::BinIteratorImpl` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:152:39
    |
152 |                     self.count = self.get_allocated_bin_count(self.bin_index);
    |                                       ^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&abstract_mutable_histogram::BinIteratorImpl`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `AbstractMutableHistogram` defines an item `get_allocated_bin_count`, perhaps you need to implement it
   --> src/histograms/abstract_mutable_histogram.rs:184:1
    |
184 | pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `get_layout` found for struct `abstract_mutable_histogram::BinIteratorImpl` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:160:36
    |
85  | pub struct BinIteratorImpl {
    | -------------------------- function or associated item `get_layout` not found for this
...
160 |             self.bin_index = Self::get_layout().get_underflow_bin_index();
    |                                    ^^^^^^^^^^ function or associated item not found in `abstract_mutable_histogram::BinIteratorImpl`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `get_layout`, perhaps you need to implement one of them:
            candidate #1: `AbstractHistogram`
            candidate #2: `Histogram`

error[E0277]: the size for values of type `(dyn BinSketch + 'static)` cannot be known at compilation time
   --> src/histograms/abstract_mutable_histogram.rs:166:31
    |
166 |     fn get_bin_copy(&self) -> dyn BinSketch {
    |                               ^^^^^^^^^^^^^ doesn't have a size known at compile-time
    |
    = help: the trait `Sized` is not implemented for `(dyn BinSketch + 'static)`
    = note: the return type of a function must have a statically known size

error[E0277]: the size for values of type `Self` cannot be known at compilation time
   --> src/histograms/abstract_mutable_histogram.rs:188:36
    |
188 |     fn new(layout: impl Layout) -> Self {
    |                                    ^^^^ doesn't have a size known at compile-time
    |
    = note: the return type of a function must have a statically known size
help: consider further restricting `Self`
    |
188 |     fn new(layout: impl Layout) -> Self where Self: Sized {
    |                                         ^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:188:41
    |
184 |  / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 |  |     type BIter: BinIterator + BinSketch + Iterator;
186 |  |     type VIter: ValueIterator + ValueSketch + Iterator;
187 |  |
188 |  |     fn new(layout: impl Layout) -> Self {
    |  |_________________________________________^
189 | ||         Default::default();
    | ||                           - help: consider removing this semicolon
190 | ||     }
    | ||_____^ expected type parameter `Self`, found `()`
...    |
830 |  |     }
831 |  | }
    |  |_- this type parameter
    |
    = note: expected type parameter `Self`
                    found unit type `()`

error[E0609]: no field `underflow_count` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:194:14
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
194 | |         self.underflow_count += count;
    | |              ^^^^^^^^^^^^^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0609]: no field `overflow_count` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:198:14
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
198 | |         self.overflow_count += count;
    | |              ^^^^^^^^^^^^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0609]: no field `total_count` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:202:14
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
202 | |         self.total_count += count;
    | |              ^^^^^^^^^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0609]: no field `min` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:210:24
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
210 | |         if min <= self.min && (min < self.min || (min.to_bits() == 0x8000000000000000)) {
    | |                        ^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0609]: no field `min` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:210:43
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
210 | |         if min <= self.min && (min < self.min || (min.to_bits() == 0x8000000000000000)) {
    | |                                           ^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0609]: no field `min` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:211:18
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
211 | |             self.min = min;
    | |                  ^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0609]: no field `max` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:213:24
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
213 | |         if max >= self.max && (max > self.max || (max.to_bits() == 0x0000000000000000)) {
    | |                        ^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0609]: no field `max` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:213:43
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
213 | |         if max >= self.max && (max > self.max || (max.to_bits() == 0x0000000000000000)) {
    | |                                           ^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0609]: no field `max` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:214:18
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
214 | |             self.max = max;
    | |                  ^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:224:20
    |
222 |     ) -> Self::H {
    |          ------- expected `<Self as AbstractHistogram>::H` because of return type
223 |         if histogram.is_empty() {
224 |             return self;
    |                    ^^^^ expected associated type, found `&Self`
    |
    = note: expected associated type `<Self as AbstractHistogram>::H`
                     found reference `&Self`
help: a method is available that returns `<Self as AbstractHistogram>::H`
   --> src/histograms/abstract_histogram.rs:419:5
    |
419 |     fn add_histogram(&self, histogram: Self::H) -> Self::H {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ consider calling `AbstractHistogram::add_histogram`

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:226:58
    |
226 |         if histogram.get_total_count() > i64::MAX - self.get_total_count() {
    |                                                          ^^^^^^^^^^^^^^^ multiple `get_total_count` found
    |
note: candidate #1 is defined in the trait `AbstractMutableHistogram`
   --> src/histograms/abstract_mutable_histogram.rs:764:5
    |
764 |     fn get_total_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:105:5
    |
105 |     fn get_total_count(&self) -> i64;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
226 |         if histogram.get_total_count() > i64::MAX - AbstractMutableHistogram::get_total_count(&self) {
    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
226 |         if histogram.get_total_count() > i64::MAX - Histogram::get_total_count(&self) {
    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:227:55
    |
227 |             return Err(DynaHistError::ArithmeticError(&Self::OVERFLOW_MSG));
    |                                                       ^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&&'static str`
    |
help: try using a conversion method
    |
227 |             return Err(DynaHistError::ArithmeticError((&Self::OVERFLOW_MSG).to_string()));
    |                                                       ^                   ^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:229:31
    |
229 |         let layout: Self::L = histogram.get_layout();
    |                     -------   ^^^^^^^^^^^^^^^^^^^^^^ expected associated type, found reference
    |                     |
    |                     expected due to this
    |
    = note: expected associated type `<Self as Histogram>::L`
                     found reference `&<<Self as AbstractHistogram>::H as Histogram>::L`
    = help: consider constraining the associated type `<Self as Histogram>::L` to `&<<Self as AbstractHistogram>::H as Histogram>::L` or calling a method that returns `<Self as Histogram>::L`
    = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:230:18
    |
230 |         if Self::get_layout().equals(layout) {
    |                  ^^^^^^^^^^ multiple `get_layout` found
    |
note: candidate #1 is defined in the trait `AbstractHistogram`
   --> src/histograms/abstract_histogram.rs:374:5
    |
374 |     fn get_layout(&self) -> Sketch {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:28:5
    |
28  |     fn get_layout(&self) -> &Self::L {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
230 |         if AbstractHistogram::get_layout().equals(layout) {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
230 |         if Histogram::get_layout().equals(layout) {
    |            ^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:231:53
    |
231 |             let first_non_empty_bin: Self::BIter  = histogram.get_first_non_empty_bin();
    |                                      -----------    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected associated type, found reference
    |                                      |
    |                                      expected due to this
    |
    = note: expected associated type `<Self as AbstractMutableHistogram>::BIter`
                     found reference `&<<Self as AbstractHistogram>::H as Histogram>::B`
help: some methods are available that return `<Self as AbstractMutableHistogram>::BIter`
   --> src/histograms/abstract_mutable_histogram.rs:686:5
    |
686 |     fn get_first_non_empty_bin(&self) ->  Self::BIter {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ consider calling `AbstractMutableHistogram::get_first_non_empty_bin`
...
721 |     fn get_last_non_empty_bin(&self) ->  Self::BIter {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ consider calling `AbstractMutableHistogram::get_last_non_empty_bin`

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:232:52
    |
232 |             let last_non_empty_bin:  Self::BIter = histogram.get_last_non_empty_bin();
    |                                      -----------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected associated type, found reference
    |                                      |
    |                                      expected due to this
    |
    = note: expected associated type `<Self as AbstractMutableHistogram>::BIter`
                     found reference `&<<Self as AbstractHistogram>::H as Histogram>::B`
help: some methods are available that return `<Self as AbstractMutableHistogram>::BIter`
   --> src/histograms/abstract_mutable_histogram.rs:686:5
    |
686 |     fn get_first_non_empty_bin(&self) ->  Self::BIter {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ consider calling `AbstractMutableHistogram::get_first_non_empty_bin`
...
721 |     fn get_last_non_empty_bin(&self) ->  Self::BIter {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ consider calling `AbstractMutableHistogram::get_last_non_empty_bin`

error[E0061]: this function takes 3 arguments but 2 arguments were supplied
   --> src/histograms/abstract_mutable_histogram.rs:234:17
    |
234 |                 Self::add_values(&histogram.get_min(), histogram.get_total_count() - 1);
    |                 ^^^^^^^^^^^^^^^^ --------------------  ------------------------------- supplied 2 arguments
    |                 |
    |                 expected 3 arguments
    |
note: associated function defined here
   --> src/histograms/histogram.rs:233:8
    |
233 |     fn add_values(&self, value: f64, count: i64) -> Self;
    |        ^^^^^^^^^^

error[E0061]: this function takes 2 arguments but 1 argument was supplied
   --> src/histograms/abstract_mutable_histogram.rs:235:17
    |
235 |                 Self::add_value(&histogram.get_max());
    |                 ^^^^^^^^^^^^^^^ -------------------- supplied 1 argument
    |                 |
    |                 expected 2 arguments
    |
note: associated function defined here
   --> src/histograms/histogram.rs:207:8
    |
207 |     fn add_value(&self, value: f64) -> Self {
    |        ^^^^^^^^^ -----  ----------

error[E0061]: this function takes 3 arguments but 2 arguments were supplied
   --> src/histograms/abstract_mutable_histogram.rs:237:17
    |
237 |                 Self::add_values(
    |                 ^^^^^^^^^^^^^^^^ expected 3 arguments
238 |                     &last_non_empty_bin.get_upper_bound(),
    |                     -------------------------------------
239 |                     &last_non_empty_bin.get_bin_count(),
    |                     ----------------------------------- supplied 2 arguments
    |
note: associated function defined here
   --> src/histograms/histogram.rs:233:8
    |
233 |     fn add_values(&self, value: f64, count: i64) -> Self;
    |        ^^^^^^^^^^

error[E0061]: this function takes 3 arguments but 2 arguments were supplied
   --> src/histograms/abstract_mutable_histogram.rs:245:29
    |
245 | ...                   Self::add_values(
    |                       ^^^^^^^^^^^^^^^^ expected 3 arguments
246 | ...                       &bin_iterator.get_lower_bound(),
    |                           -------------------------------
247 | ...                       &bin_iterator.get_bin_count(),
    |                           ----------------------------- supplied 2 arguments
    |
note: associated function defined here
   --> src/histograms/histogram.rs:233:8
    |
233 |     fn add_values(&self, value: f64, count: i64) -> Self;
    |        ^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:260:79
    |
221 |         value_estimator: impl ValueEstimation,
    |                          -------------------- this type parameter
...
260 |                 |&rank| preprocessed_histogram.get_value_from_estimator(rank, value_estimator);
    |                                                                               ^^^^^^^^^^^^^^^ expected reference, found type parameter `impl ValueEstimation`
    |
    = note:   expected reference `&<<Self as AbstractHistogram>::H as Histogram>::V`
            found type parameter `impl ValueEstimation`

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:261:25
    |
261 |             return self.add_ascending_sequence(
    |                         ^^^^^^^^^^^^^^^^^^^^^^ multiple `add_ascending_sequence` found
    |
note: candidate #1 is defined in the trait `AbstractMutableHistogram`
   --> src/histograms/abstract_mutable_histogram.rs:790:5
    |
790 | /     fn add_ascending_sequence<F: Fn(i64) -> f64>(
791 | |         &self,
792 | |         ascending_sequence: &F,
793 | |         length: i64,
794 | |     ) -> Self::H {
    | |________________^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:308:5
    |
308 | /     fn add_ascending_sequence<F: Fn(i64) -> f64>(
309 | |         &self,
310 | |         ascending_sequence: &F,
311 | |         length: i64,
312 | |     ) -> Self;
    | |______________^
help: disambiguate the associated function for candidate #1
    |
261 |             return AbstractMutableHistogram::add_ascending_sequence(&self, ascending_sequence, preprocessed_histogram.get_total_count());
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
261 |             return Histogram::add_ascending_sequence(&self, ascending_sequence, preprocessed_histogram.get_total_count());
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: the size for values of type `Self` cannot be known at compilation time
   --> src/histograms/abstract_mutable_histogram.rs:234:17
    |
234 |                 Self::add_values(&histogram.get_min(), histogram.get_total_count() - 1);
    |                 ^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
    |
    = note: the return type of a function must have a statically known size
help: consider further restricting `Self`
    |
222 |     ) -> Self::H where Self: Sized {
    |                  ^^^^^^^^^^^^^^^^^

error[E0061]: this function takes 1 argument but 0 arguments were supplied
   --> src/histograms/abstract_mutable_histogram.rs:270:13
    |
270 |         3 * usize::to_be_bytes() + // min, max
    |             ^^^^^^^^^^^^^^^^^^-- supplied 0 arguments
    |             |
    |             expected 1 argument
    |
note: associated function defined here
   --> /home/hedge/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/mod.rs:745:5
    |
745 | /     uint_impl! { usize, u64, 64, 18446744073709551615, 12, "0xaa00000000006e1", "0x6e10aa",
746 | |     "0x1234567890123456", "0x5634129078563412", "0x6a2c48091e6a2c48",
747 | |     "[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]",
748 | |      "[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]",
749 | |     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }
    | |______________________________________________________________________^
    = note: this error originates in the macro `uint_impl` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: cannot multiply `{integer}` by `[u8; 8]`
   --> src/histograms/abstract_mutable_histogram.rs:270:11
    |
270 |         3 * usize::to_be_bytes() + // min, max
    |           ^ no implementation for `{integer} * [u8; 8]`
    |
    = help: the trait `Mul<[u8; 8]>` is not implemented for `{integer}`

error[E0061]: this function takes 1 argument but 0 arguments were supplied
   --> src/histograms/abstract_mutable_histogram.rs:271:13
    |
271 |         2 * f64::to_be_bytes() + Self::get_estimated_footprint_in_bytes();
    |             ^^^^^^^^^^^^^^^^-- supplied 0 arguments
    |             |
    |             expected 1 argument
    |
note: associated function defined here
   --> /home/hedge/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/f64.rs:822:18
    |
822 |     pub const fn to_be_bytes(self) -> [u8; 8] {
    |                  ^^^^^^^^^^^

error[E0277]: cannot multiply `{integer}` by `[u8; 8]`
   --> src/histograms/abstract_mutable_histogram.rs:271:11
    |
271 |         2 * f64::to_be_bytes() + Self::get_estimated_footprint_in_bytes();
    |           ^ no implementation for `{integer} * [u8; 8]`
    |
    = help: the trait `Mul<[u8; 8]>` is not implemented for `{integer}`

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:271:40
    |
271 |         2 * f64::to_be_bytes() + Self::get_estimated_footprint_in_bytes();
    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ multiple `get_estimated_footprint_in_bytes` found
    |
note: candidate #1 is defined in the trait `AbstractHistogram`
   --> src/histograms/abstract_histogram.rs:413:5
    |
413 |     fn get_estimated_footprint_in_bytes(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `AbstractMutableHistogram`
   --> src/histograms/abstract_mutable_histogram.rs:268:5
    |
268 |     fn get_estimated_footprint_in_bytes(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #3 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:333:5
    |
333 |     fn get_estimated_footprint_in_bytes(&self) -> i64;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
271 |         2 * f64::to_be_bytes() + AbstractHistogram::get_estimated_footprint_in_bytes();
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
271 |         2 * f64::to_be_bytes() + AbstractMutableHistogram::get_estimated_footprint_in_bytes();
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #3
    |
271 |         2 * f64::to_be_bytes() + Histogram::get_estimated_footprint_in_bytes();
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:287:31
    |
287 |         if bin_index <= Self::get_layout().get_underflow_bin_index() {
    |                               ^^^^^^^^^^ multiple `get_layout` found
    |
note: candidate #1 is defined in the trait `AbstractHistogram`
   --> src/histograms/abstract_histogram.rs:374:5
    |
374 |     fn get_layout(&self) -> Sketch {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:28:5
    |
28  |     fn get_layout(&self) -> &Self::L {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
287 |         if bin_index <= AbstractHistogram::get_layout().get_underflow_bin_index() {
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
287 |         if bin_index <= Histogram::get_layout().get_underflow_bin_index() {
    |                         ^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:288:25
    |
288 |             return self.get_underflow_count();
    |                         ^^^^^^^^^^^^^^^^^^^ multiple `get_underflow_count` found
    |
note: candidate #1 is defined in the trait `AbstractMutableHistogram`
   --> src/histograms/abstract_mutable_histogram.rs:756:5
    |
756 |     fn get_underflow_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:90:5
    |
90  |     fn get_underflow_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
288 |             return AbstractMutableHistogram::get_underflow_count(&self);
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
288 |             return Histogram::get_underflow_count(&self);
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:293:37
    |
293 |         } else if bin_index < Self::get_layout().get_overflow_bin_index() {
    |                                     ^^^^^^^^^^ multiple `get_layout` found
    |
note: candidate #1 is defined in the trait `AbstractHistogram`
   --> src/histograms/abstract_histogram.rs:374:5
    |
374 |     fn get_layout(&self) -> Sketch {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:28:5
    |
28  |     fn get_layout(&self) -> &Self::L {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
293 |         } else if bin_index < AbstractHistogram::get_layout().get_overflow_bin_index() {
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
293 |         } else if bin_index < Histogram::get_layout().get_overflow_bin_index() {
    |                               ^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:296:25
    |
296 |             return self.get_overflow_count();
    |                         ^^^^^^^^^^^^^^^^^^ multiple `get_overflow_count` found
    |
note: candidate #1 is defined in the trait `AbstractMutableHistogram`
   --> src/histograms/abstract_mutable_histogram.rs:760:5
    |
760 |     fn get_overflow_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:75:5
    |
75  |     fn get_overflow_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
296 |             return AbstractMutableHistogram::get_overflow_count(&self);
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
296 |             return Histogram::get_overflow_count(&self);
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `write_byte` found for reference `&DataOutput` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:320:21
    |
320 |         data_output.write_byte(Self::SERIAL_VERSION_V0);
    |                     ^^^^^^^^^^ method not found in `&DataOutput`

error[E0609]: no field `total_count` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:321:17
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
321 | |         if self.total_count <= 1 {
    | |                 ^^^^^^^^^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:323:21
    |
323 |             if self.is_empty() {
    |                     ^^^^^^^^ multiple `is_empty` found
    |
note: candidate #1 is defined in the trait `AbstractHistogram`
   --> src/histograms/abstract_histogram.rs:397:5
    |
397 |     fn is_empty(&self) -> bool {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:126:5
    |
126 |     fn is_empty(&self) -> bool;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
323 |             if AbstractHistogram::is_empty(&self) {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
323 |             if Histogram::is_empty(&self) {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `write_byte` found for reference `&DataOutput` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:325:29
    |
325 |                 data_output.write_byte(info_byte);
    |                             ^^^^^^^^^^ method not found in `&DataOutput`

error[E0599]: no method named `write_byte` found for reference `&DataOutput` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:328:29
    |
328 |                 data_output.write_byte(info_byte);
    |                             ^^^^^^^^^^ method not found in `&DataOutput`

error[E0599]: no method named `write_double` found for reference `&DataOutput` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:329:29
    |
329 |                 data_output.write_double(self.min);
    |                             ^^^^^^^^^^^^ method not found in `&DataOutput`

error[E0609]: no field `min` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:329:47
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
329 | |                 data_output.write_double(self.min);
    | |                                               ^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0069]: `return;` in a function whose return type is not `()`
   --> src/histograms/abstract_mutable_histogram.rs:331:13
    |
318 |     fn write(&self, data_output: &DataOutput) -> Result<(), std::rc::Rc<DynaHistError>> {
    |                                                  -------------------------------------- expected `Result<(), std::rc::Rc<DynaHistError>>` because of this return type
...
331 |             return;
    |             ^^^^^^ return type is not `()`

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:333:37
    |
333 |         let layout: Self::L = Self::get_layout();
    |                                     ^^^^^^^^^^ multiple `get_layout` found
    |
note: candidate #1 is defined in the trait `AbstractHistogram`
   --> src/histograms/abstract_histogram.rs:374:5
    |
374 |     fn get_layout(&self) -> Sketch {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:28:5
    |
28  |     fn get_layout(&self) -> &Self::L {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
333 |         let layout: Self::L = AbstractHistogram::get_layout();
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
333 |         let layout: Self::L = Histogram::get_layout();
    |                               ^^^^^^^^^^^^^^^^^^^^^

error[E0609]: no field `underflow_count` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:338:52
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
338 | |         let effective_under_flow_count: i64 = self.underflow_count
    | |                                                    ^^^^^^^^^^^^^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0609]: no field `underflow_count` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:339:24
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
339 | |             - (if self.underflow_count > 0 { 1 } else { 0 })
    | |                        ^^^^^^^^^^^^^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0609]: no field `underflow_count` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:340:24
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
340 | |             - (if self.underflow_count == self.total_count {
    | |                        ^^^^^^^^^^^^^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0609]: no field `total_count` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:340:48
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
340 | |             - (if self.underflow_count == self.total_count {
    | |                                                ^^^^^^^^^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0609]: no field `overflow_count` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:345:51
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
345 | |         let effective_over_flow_count: i64 = self.overflow_count
    | |                                                   ^^^^^^^^^^^^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0609]: no field `overflow_count` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:346:24
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
346 | |             - (if self.overflow_count > 0 { 1 } else { 0 })
    | |                        ^^^^^^^^^^^^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0609]: no field `overflow_count` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:347:24
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
347 | |             - (if self.overflow_count == self.total_count {
    | |                        ^^^^^^^^^^^^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0609]: no field `total_count` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:347:47
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
347 | |             - (if self.overflow_count == self.total_count {
    | |                                               ^^^^^^^^^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0609]: no field `total_count` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:352:47
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
352 | |         let effective_total_count: i64 = self.total_count - 2;
    | |                                               ^^^^^^^^^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0609]: no field `min` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:361:50
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
361 | |         let is_min_smaller_than_max: bool = self.min < self.max;
    | |                                                  ^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0609]: no field `max` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:361:61
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
361 | |         let is_min_smaller_than_max: bool = self.min < self.max;
    | |                                                             ^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:364:21
    |
364 |         info_byte = mode + 1;
    |                     ^^^^^^^^ expected `i32`, found `i8`

error[E0599]: no method named `write_byte` found for reference `&DataOutput` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:379:21
    |
379 |         data_output.write_byte(info_byte);
    |                     ^^^^^^^^^^ method not found in `&DataOutput`

error[E0599]: no method named `write_double` found for reference `&DataOutput` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:381:21
    |
381 |         data_output.write_double(self.min);
    |                     ^^^^^^^^^^^^ method not found in `&DataOutput`

error[E0609]: no field `min` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:381:39
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
381 | |         data_output.write_double(self.min);
    | |                                       ^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0599]: no method named `write_double` found for reference `&DataOutput` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:383:25
    |
383 |             data_output.write_double(self.max);
    |                         ^^^^^^^^^^^^ method not found in `&DataOutput`

error[E0609]: no field `max` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:383:43
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
383 | |             data_output.write_double(self.max);
    | |                                           ^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:387:43
    |
387 |             Self::write_unsigned_var_long(effective_under_flow_count - 1, &data_output);
    |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `i64`
    |
help: you can convert an `i64` to a `u64` and panic if the converted value doesn't fit
    |
387 |             Self::write_unsigned_var_long((effective_under_flow_count - 1).try_into().unwrap(), &data_output);
    |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:390:43
    |
390 |             Self::write_unsigned_var_long(effective_over_flow_count - 1, &data_output);
    |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `i64`
    |
help: you can convert an `i64` to a `u64` and panic if the converted value doesn't fit
    |
390 |             Self::write_unsigned_var_long((effective_over_flow_count - 1).try_into().unwrap(), &data_output);
    |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0609]: no field `min` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:393:67
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
393 | |             let min_bin_index: i32 = layout.map_to_bin_index(self.min);
    | |                                                                   ^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:393:38
    |
393 |             let min_bin_index: i32 = layout.map_to_bin_index(self.min);
    |                                ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |                                |
    |                                expected due to this
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
393 |             let min_bin_index: i32 = layout.map_to_bin_index(self.min).try_into().unwrap();
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0609]: no field `max` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:394:67
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
394 | |             let max_bin_index: i32 = layout.map_to_bin_index(self.max);
    | |                                                                   ^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:394:38
    |
394 |             let max_bin_index: i32 = layout.map_to_bin_index(self.max);
    |                                ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |                                |
    |                                expected due to this
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
394 |             let max_bin_index: i32 = layout.map_to_bin_index(self.max).try_into().unwrap();
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:397:26
    |
397 |                 i32::max(&self.min_allocated_bin_index_inclusive(), min_bin_index);
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&i32`
    |
help: consider removing the borrow
    |
397 |                 i32::max(self.min_allocated_bin_index_inclusive(), min_bin_index);
    |                         --

error[E0599]: no function or associated item named `write_signed_var_int` found for type parameter `Self` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:413:19
    |
413 |             Self::write_signed_var_int(first_regular_effectively_non_zero_bin_index, &data_output);
    |                   ^^^^^^^^^^^^^^^^^^^^ function or associated item not found in `Self`
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `write_signed_var_int`, perhaps you need to add another supertrait for it:
    |
184 | pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions + Seriate {
    |                                                                                   ^^^^^^^^^
help: there is an associated function with a similar name
    |
413 |             Self::write_unsigned_var_long(first_regular_effectively_non_zero_bin_index, &data_output);
    |                   ^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `write_signed_var_int` found for type parameter `Self` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:433:23
    |
433 |                 Self::write_signed_var_int(
    |                       ^^^^^^^^^^^^^^^^^^^^ function or associated item not found in `Self`
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `write_signed_var_int`, perhaps you need to add another supertrait for it:
    |
184 | pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions + Seriate {
    |                                                                                   ^^^^^^^^^
help: there is an associated function with a similar name
    |
433 |                 Self::write_unsigned_var_long(
    |                       ^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `write_byte` found for reference `&DataOutput` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:473:41
    |
473 | ...                   data_output.write_byte(b);
    |                                   ^^^^^^^^^^ method not found in `&DataOutput`

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:444:25
    |
318 |       fn write(&self, data_output: &DataOutput) -> Result<(), std::rc::Rc<DynaHistError>> {
    |                                                    -------------------------------------- expected `Result<(), Rc<DynaHistError>>` because of return type
...
444 | /                         while bin_index <= last_regular_effectively_non_zero_bin_index {
445 | |                             let mut b: i32 = 0;
446 | |                             {
447 | |                                 let mut i: i32 = 0;
...   |
473 | |                             data_output.write_byte(b);
474 | |                         }
    | |_________________________^ expected enum `Result`, found `()`
    |
    = note:   expected enum `Result<(), Rc<DynaHistError>>`
            found unit type `()`
help: try using a variant of the expected enum
    |
444 |                         Ok(while bin_index <= last_regular_effectively_non_zero_bin_index {
445 |                             let mut b: i32 = 0;
446 |                             {
447 |                                 let mut i: i32 = 0;
448 |                                 while i < counts_per_byte {
449 |                                     {
  ...

error[E0599]: no method named `write_byte` found for reference `&DataOutput` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:488:53
    |
488 | ...                   data_output.write_byte(b);
    |                                   ^^^^^^^^^^ method not found in `&DataOutput`

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:478:25
    |
318 |       fn write(&self, data_output: &DataOutput) -> Result<(), std::rc::Rc<DynaHistError>> {
    |                                                    -------------------------------------- expected `Result<(), Rc<DynaHistError>>` because of return type
...
478 | /                         while bin_index <= last_regular_effectively_non_zero_bin_index {
479 | |                             let bin_count: i64 = self.get_allocated_bin_count(bin_index)
480 | |                                 - (if min_bin_index == bin_index { 1 } else { 0 })
481 | |                                 - (if max_bin_index == bin_index { 1 } else { 0 });
...   |
492 | |                             }
493 | |                         }
    | |_________________________^ expected enum `Result`, found `()`
    |
    = note:   expected enum `Result<(), Rc<DynaHistError>>`
            found unit type `()`
help: try using a variant of the expected enum
    |
478 |                         Ok(while bin_index <= last_regular_effectively_non_zero_bin_index {
479 |                             let bin_count: i64 = self.get_allocated_bin_count(bin_index)
480 |                                 - (if min_bin_index == bin_index { 1 } else { 0 })
481 |                                 - (if max_bin_index == bin_index { 1 } else { 0 });
482 |                             bin_index += 1;
483 |                             {
  ...

error[E0599]: no method named `write_byte` found for reference `&DataOutput` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:512:25
    |
512 |             data_output.write_byte((value as i32 & 0x7F) | 0x80);
    |                         ^^^^^^^^^^ method not found in `&DataOutput`

error[E0599]: no method named `write_byte` found for reference `&DataOutput` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:515:21
    |
515 |         data_output.write_byte(value as i32 & 0x7F);
    |                     ^^^^^^^^^^ method not found in `&DataOutput`

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:533:30
    |
533 |         Self::check_argument(&histogram.is_empty());
    |                              ^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `&bool`
    |
help: consider removing the borrow
    |
533 |         Self::check_argument(histogram.is_empty());
    |                             --

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:534:31
    |
534 |         let layout: Self::L = histogram.get_layout();
    |                     -------   ^^^^^^^^^^^^^^^^^^^^^^ expected associated type, found reference
    |                     |
    |                     expected due to this
    |
    = note: expected associated type `<Self as Histogram>::L`
                     found reference `&<T as Histogram>::L`
    = help: consider constraining the associated type `<Self as Histogram>::L` to `&<T as Histogram>::L` or calling a method that returns `<Self as Histogram>::L`
    = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html

error[E0599]: no function or associated item named `check_serial_version` found for struct `SeriateUtil` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:536:22
    |
536 |         SeriateUtil::check_serial_version(
    |                      ^^^^^^^^^^^^^^^^^^^^ function or associated item not found in `SeriateUtil`
    |
   ::: src/seriate/mod.rs:26:1
    |
26  | pub struct SeriateUtil {}
    | ---------------------- function or associated item `check_serial_version` not found for this
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `Seriate` defines an item `check_serial_version`, perhaps you need to implement it
   --> src/seriate/mod.rs:301:1
    |
301 | pub trait Seriate {
    | ^^^^^^^^^^^^^^^^^

error[E0599]: no method named `read_unsigned_byte` found for reference `&DataInput` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:538:25
    |
538 |             &data_input.read_unsigned_byte(),
    |                         ^^^^^^^^^^^^^^^^^^ method not found in `&DataInput`

error[E0599]: no method named `read_unsigned_byte` found for reference `&DataInput` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:541:41
    |
541 |         let info_byte: i32 = data_input.read_unsigned_byte();
    |                                         ^^^^^^^^^^^^^^^^^^ method not found in `&DataInput`

error[E0599]: no method named `read_double` found for reference `&DataInput` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:545:49
    |
545 |                 histogram.add_value(&data_input.read_double());
    |                                                 ^^^^^^^^^^^ method not found in `&DataInput`

error[E0069]: `return;` in a function whose return type is not `()`
   --> src/histograms/abstract_mutable_histogram.rs:547:13
    |
529 |     ) -> Result<(), std::rc::Rc<DynaHistError>>
    |          -------------------------------------- expected `Result<(), std::rc::Rc<DynaHistError>>` because of this return type
...
547 |             return;
    |             ^^^^^^ return type is not `()`

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:551:50
    |
551 |         let effective_regular_total_count: i64 = (info_byte >> /* >>> */ 4) & 0x03;
    |                                            ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |                                            |     |
    |                                            |     expected `i64`, found `i32`
    |                                            |     help: you can convert an `i32` to an `i64`: `((info_byte >> /* >>> */ 4) & 0x03).into()`
    |                                            expected due to this

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:552:47
    |
552 |         let effective_under_flow_count: i64 = (info_byte >> /* >>> */ 6) & 0x01;
    |                                         ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |                                         |     |
    |                                         |     expected `i64`, found `i32`
    |                                         |     help: you can convert an `i32` to an `i64`: `((info_byte >> /* >>> */ 6) & 0x01).into()`
    |                                         expected due to this

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:553:46
    |
553 |         let effective_over_flow_count: i64 = (info_byte >> /* >>> */ 7) & 0x01;
    |                                        ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |                                        |     |
    |                                        |     expected `i64`, found `i32`
    |                                        |     help: you can convert an `i32` to an `i64`: `((info_byte >> /* >>> */ 7) & 0x01).into()`
    |                                        expected due to this

error[E0599]: no method named `read_double` found for reference `&DataInput` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:555:35
    |
555 |         let min: f64 = data_input.read_double();
    |                                   ^^^^^^^^^^^ method not found in `&DataInput`

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:556:34
    |
556 |         let min_bin_index: i32 = layout.map_to_bin_index(min);
    |                            ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |                            |
    |                            expected due to this
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
556 |         let min_bin_index: i32 = layout.map_to_bin_index(min).try_into().unwrap();
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `read_double` found for reference `&DataInput` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:560:30
    |
560 |             max = data_input.read_double();
    |                              ^^^^^^^^^^^ method not found in `&DataInput`

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:561:29
    |
561 |             max_bin_index = layout.map_to_bin_index(max);
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`

error[E0599]: no function or associated item named `read_unsigned_var_long` found for struct `SeriateUtil` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:568:56
    |
568 |             effective_under_flow_count += SeriateUtil::read_unsigned_var_long(&data_input);
    |                                                        ^^^^^^^^^^^^^^^^^^^^^^ function or associated item not found in `SeriateUtil`
    |
   ::: src/seriate/mod.rs:26:1
    |
26  | pub struct SeriateUtil {}
    | ---------------------- function or associated item `read_unsigned_var_long` not found for this
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `Seriate` defines an item `read_unsigned_var_long`, perhaps you need to implement it
   --> src/seriate/mod.rs:301:1
    |
301 | pub trait Seriate {
    | ^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `read_unsigned_var_long` found for struct `SeriateUtil` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:571:55
    |
571 |             effective_over_flow_count += SeriateUtil::read_unsigned_var_long(&data_input);
    |                                                       ^^^^^^^^^^^^^^^^^^^^^^ function or associated item not found in `SeriateUtil`
    |
   ::: src/seriate/mod.rs:26:1
    |
26  | pub struct SeriateUtil {}
    | ---------------------- function or associated item `read_unsigned_var_long` not found for this
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `Seriate` defines an item `read_unsigned_var_long`, perhaps you need to implement it
   --> src/seriate/mod.rs:301:1
    |
301 | pub trait Seriate {
    | ^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `read_signed_var_int` found for struct `SeriateUtil` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:577:30
    |
577 |                 SeriateUtil::read_signed_var_int(&data_input);
    |                              ^^^^^^^^^^^^^^^^^^^ function or associated item not found in `SeriateUtil`
    |
   ::: src/seriate/mod.rs:26:1
    |
26  | pub struct SeriateUtil {}
    | ---------------------- function or associated item `read_signed_var_int` not found for this
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `Seriate` defines an item `read_signed_var_int`, perhaps you need to implement it
   --> src/seriate/mod.rs:301:1
    |
301 | pub trait Seriate {
    | ^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `read_signed_var_int` found for struct `SeriateUtil` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:582:34
    |
582 |                     SeriateUtil::read_signed_var_int(&data_input);
    |                                  ^^^^^^^^^^^^^^^^^^^ function or associated item not found in `SeriateUtil`
    |
   ::: src/seriate/mod.rs:26:1
    |
26  | pub struct SeriateUtil {}
    | ---------------------- function or associated item `read_signed_var_int` not found for this
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `Seriate` defines an item `read_signed_var_int`, perhaps you need to implement it
   --> src/seriate/mod.rs:301:1
    |
301 | pub trait Seriate {
    | ^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:589:37
    |
589 |                 if min_bin_index <= layout.get_underflow_bin_index() {
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
589 |                 if min_bin_index <= layout.get_underflow_bin_index().try_into().unwrap() {
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:597:37
    |
597 |                 if max_bin_index >= layout.get_overflow_bin_index() {
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
597 |                 if max_bin_index >= layout.get_overflow_bin_index().try_into().unwrap() {
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `clip` found for type parameter `Self` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:603:58
    |
603 |                 let min_allocated_bin_index: i32 = Self::clip(
    |                                                          ^^^^ function or associated item not found in `Self`
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `clip`, perhaps you need to add another supertrait for it:
    |
184 | pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions + Algorithms {
    |                                                                                   ^^^^^^^^^^^^

error[E0599]: no function or associated item named `clip` found for type parameter `Self` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:608:58
    |
608 |                 let max_allocated_bin_index: i32 = Self::clip(
    |                                                          ^^^^ function or associated item not found in `Self`
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `clip`, perhaps you need to add another supertrait for it:
    |
184 | pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions + Algorithms {
    |                                                                                   ^^^^^^^^^^^^

error[E0599]: no method named `ensure_count_array` found for reference `&T` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:613:27
    |
613 |                 histogram.ensure_count_array(
    |                           ^^^^^^^^^^^^^^^^^^ method not found in `&T`
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `ensure_count_array`, perhaps you need to restrict type parameter `T` with it:
    |
526 |     fn deserialize<T: AbstractMutableHistogram>(
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `read_unsigned_byte` found for reference `&DataInput` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:630:60
    |
630 | ...                   read_bits = data_input.read_unsigned_byte();
    |                                              ^^^^^^^^^^^^^^^^^^ method not found in `&DataInput`

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:635:37
    |
634 | ...                   let bin_count: i64 =
    |                                      --- expected due to this
635 | ...                       (read_bits >> /* >>> */ available_bit_count) & bit_mask;
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |                           |
    |                           expected `i64`, found `i32`
    |                           help: you can convert an `i32` to an `i64`: `((read_bits >> /* >>> */ available_bit_count) & bit_mask).into()`

error[E0599]: no method named `increase_count` found for reference `&T` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:636:43
    |
636 | ...                   histogram.increase_count(bin_index, bin_count);
    |                                 ^^^^^^^^^^^^^^ method not found in `&T`
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `increase_count`, perhaps you need to restrict type parameter `T` with it:
    |
526 |     fn deserialize<T: AbstractMutableHistogram>(
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `read_unsigned_byte` found for reference `&DataInput` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:654:69
    |
654 | ...                   bin_count += data_input.read_unsigned_byte();
    |                                               ^^^^^^^^^^^^^^^^^^ method not found in `&DataInput`

error[E0599]: no method named `increase_count` found for reference `&T` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:660:43
    |
660 | ...                   histogram.increase_count(bin_index, bin_count);
    |                                 ^^^^^^^^^^^^^^ method not found in `&T`
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `increase_count`, perhaps you need to restrict type parameter `T` with it:
    |
526 |     fn deserialize<T: AbstractMutableHistogram>(
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `increase_count` found for reference `&T` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:668:27
    |
668 |                 histogram.increase_count(first_regular_effectively_non_zero_bin_index, 1);
    |                           ^^^^^^^^^^^^^^ method not found in `&T`
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `increase_count`, perhaps you need to restrict type parameter `T` with it:
    |
526 |     fn deserialize<T: AbstractMutableHistogram>(
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `increase_count` found for reference `&T` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:671:31
    |
671 |                     histogram.increase_count(last_regular_effectively_non_zero_bin_index, 1);
    |                               ^^^^^^^^^^^^^^ method not found in `&T`
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `increase_count`, perhaps you need to restrict type parameter `T` with it:
    |
526 |     fn deserialize<T: AbstractMutableHistogram>(
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `updates_min_max` found for reference `&T` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:676:19
    |
676 |         histogram.updates_min_max(min, max);
    |                   ^^^^^^^^^^^^^^^ method not found in `&T`
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `updates_min_max`, perhaps you need to restrict type parameter `T` with it:
    |
526 |     fn deserialize<T: AbstractMutableHistogram>(
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `increase_count` found for reference `&T` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:677:19
    |
677 |         histogram.increase_count(min_bin_index, 1);
    |                   ^^^^^^^^^^^^^^ method not found in `&T`
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `increase_count`, perhaps you need to restrict type parameter `T` with it:
    |
526 |     fn deserialize<T: AbstractMutableHistogram>(
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `increase_count` found for reference `&T` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:678:19
    |
678 |         histogram.increase_count(max_bin_index, 1);
    |                   ^^^^^^^^^^^^^^ method not found in `&T`
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `increase_count`, perhaps you need to restrict type parameter `T` with it:
    |
526 |     fn deserialize<T: AbstractMutableHistogram>(
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `increment_underflow_count` found for reference `&T` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:679:19
    |
679 |         histogram.increment_underflow_count(effective_under_flow_count);
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `increment_underflow_count`, perhaps you need to restrict type parameter `T` with it:
    |
526 |     fn deserialize<T: AbstractMutableHistogram>(
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: there is an associated function with a similar name
    |
679 |         histogram.get_underflow_count(effective_under_flow_count);
    |                   ^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `increment_overflow_count` found for reference `&T` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:680:19
    |
680 |         histogram.increment_overflow_count(effective_over_flow_count);
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `increment_overflow_count`, perhaps you need to restrict type parameter `T` with it:
    |
526 |     fn deserialize<T: AbstractMutableHistogram>(
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: there is an associated function with a similar name
    |
680 |         histogram.get_overflow_count(effective_over_flow_count);
    |                   ^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `increment_total_count` found for reference `&T` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:681:19
    |
681 |         histogram.increment_total_count(total_count);
    |                   ^^^^^^^^^^^^^^^^^^^^^
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `increment_total_count`, perhaps you need to restrict type parameter `T` with it:
    |
526 |     fn deserialize<T: AbstractMutableHistogram>(
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: there is an associated function with a similar name
    |
681 |         histogram.get_total_count(total_count);
    |                   ^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:532:5
    |
532 | /     {
533 | |         Self::check_argument(&histogram.is_empty());
534 | |         let layout: Self::L = histogram.get_layout();
535 | |         // 0. write serial version and mode
...   |
681 | |         histogram.increment_total_count(total_count);
682 | |     }
    | |_____^ expected enum `Result`, found `()`
    |
    = note:   expected enum `Result<(), Rc<DynaHistError>>`
            found unit type `()`

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:687:17
    |
687 |         if self.is_empty() {
    |                 ^^^^^^^^ multiple `is_empty` found
    |
note: candidate #1 is defined in the trait `AbstractHistogram`
   --> src/histograms/abstract_histogram.rs:397:5
    |
397 |     fn is_empty(&self) -> bool {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:126:5
    |
126 |     fn is_empty(&self) -> bool;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
687 |         if AbstractHistogram::is_empty(&self) {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
687 |         if Histogram::is_empty(&self) {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:688:20
    |
686 |     fn get_first_non_empty_bin(&self) ->  Self::BIter {
    |                                           ----------- expected `<Self as AbstractMutableHistogram>::BIter` because of return type
687 |         if self.is_empty() {
688 |             return Err(DynaHistError::NoSuchElementError);
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected associated type, found enum `Result`
    |
    = note: expected associated type `<Self as AbstractMutableHistogram>::BIter`
                          found enum `Result<_, fn(anyhow::Error) -> DynaHistError {DynaHistError::NoSuchElementError}>`
help: a method is available that returns `<Self as AbstractMutableHistogram>::BIter`
   --> src/histograms/abstract_mutable_histogram.rs:721:5
    |
721 |     fn get_last_non_empty_bin(&self) ->  Self::BIter {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ consider calling `AbstractMutableHistogram::get_last_non_empty_bin`

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:694:17
    |
694 |         if self.get_underflow_count() > 0 {
    |                 ^^^^^^^^^^^^^^^^^^^ multiple `get_underflow_count` found
    |
note: candidate #1 is defined in the trait `AbstractMutableHistogram`
   --> src/histograms/abstract_mutable_histogram.rs:756:5
    |
756 |     fn get_underflow_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:90:5
    |
90  |     fn get_underflow_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
694 |         if AbstractMutableHistogram::get_underflow_count(&self) > 0 {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
694 |         if Histogram::get_underflow_count(&self) > 0 {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:695:36
    |
695 |             absolute_index = Self::get_layout().get_underflow_bin_index();
    |                                    ^^^^^^^^^^ multiple `get_layout` found
    |
note: candidate #1 is defined in the trait `AbstractHistogram`
   --> src/histograms/abstract_histogram.rs:374:5
    |
374 |     fn get_layout(&self) -> Sketch {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:28:5
    |
28  |     fn get_layout(&self) -> &Self::L {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
695 |             absolute_index = AbstractHistogram::get_layout().get_underflow_bin_index();
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
695 |             absolute_index = Histogram::get_layout().get_underflow_bin_index();
    |                              ^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:696:26
    |
696 |             count = self.get_underflow_count();
    |                          ^^^^^^^^^^^^^^^^^^^ multiple `get_underflow_count` found
    |
note: candidate #1 is defined in the trait `AbstractMutableHistogram`
   --> src/histograms/abstract_mutable_histogram.rs:756:5
    |
756 |     fn get_underflow_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:90:5
    |
90  |     fn get_underflow_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
696 |             count = AbstractMutableHistogram::get_underflow_count(&self);
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
696 |             count = Histogram::get_underflow_count(&self);
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:697:34
    |
697 |             greater_count = self.get_total_count() - self.get_underflow_count();
    |                                  ^^^^^^^^^^^^^^^ multiple `get_total_count` found
    |
note: candidate #1 is defined in the trait `AbstractMutableHistogram`
   --> src/histograms/abstract_mutable_histogram.rs:764:5
    |
764 |     fn get_total_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:105:5
    |
105 |     fn get_total_count(&self) -> i64;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
697 |             greater_count = AbstractMutableHistogram::get_total_count(&self) - self.get_underflow_count();
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
697 |             greater_count = Histogram::get_total_count(&self) - self.get_underflow_count();
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:697:59
    |
697 |             greater_count = self.get_total_count() - self.get_underflow_count();
    |                                                           ^^^^^^^^^^^^^^^^^^^ multiple `get_underflow_count` found
    |
note: candidate #1 is defined in the trait `AbstractMutableHistogram`
   --> src/histograms/abstract_mutable_histogram.rs:756:5
    |
756 |     fn get_underflow_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:90:5
    |
90  |     fn get_underflow_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
697 |             greater_count = self.get_total_count() - AbstractMutableHistogram::get_underflow_count(&self);
    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
697 |             greater_count = self.get_total_count() - Histogram::get_underflow_count(&self);
    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:698:24
    |
698 |         } else if self.get_overflow_count() == self.get_total_count() {
    |                        ^^^^^^^^^^^^^^^^^^ multiple `get_overflow_count` found
    |
note: candidate #1 is defined in the trait `AbstractMutableHistogram`
   --> src/histograms/abstract_mutable_histogram.rs:760:5
    |
760 |     fn get_overflow_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:75:5
    |
75  |     fn get_overflow_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
698 |         } else if AbstractMutableHistogram::get_overflow_count(&self) == self.get_total_count() {
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
698 |         } else if Histogram::get_overflow_count(&self) == self.get_total_count() {
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:698:53
    |
698 |         } else if self.get_overflow_count() == self.get_total_count() {
    |                                                     ^^^^^^^^^^^^^^^ multiple `get_total_count` found
    |
note: candidate #1 is defined in the trait `AbstractMutableHistogram`
   --> src/histograms/abstract_mutable_histogram.rs:764:5
    |
764 |     fn get_total_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:105:5
    |
105 |     fn get_total_count(&self) -> i64;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
698 |         } else if self.get_overflow_count() == AbstractMutableHistogram::get_total_count(&self) {
    |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
698 |         } else if self.get_overflow_count() == Histogram::get_total_count(&self) {
    |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:699:36
    |
699 |             absolute_index = Self::get_layout().get_overflow_bin_index();
    |                                    ^^^^^^^^^^ multiple `get_layout` found
    |
note: candidate #1 is defined in the trait `AbstractHistogram`
   --> src/histograms/abstract_histogram.rs:374:5
    |
374 |     fn get_layout(&self) -> Sketch {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:28:5
    |
28  |     fn get_layout(&self) -> &Self::L {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
699 |             absolute_index = AbstractHistogram::get_layout().get_overflow_bin_index();
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
699 |             absolute_index = Histogram::get_layout().get_overflow_bin_index();
    |                              ^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:700:26
    |
700 |             count = self.get_overflow_count();
    |                          ^^^^^^^^^^^^^^^^^^ multiple `get_overflow_count` found
    |
note: candidate #1 is defined in the trait `AbstractMutableHistogram`
   --> src/histograms/abstract_mutable_histogram.rs:760:5
    |
760 |     fn get_overflow_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:75:5
    |
75  |     fn get_overflow_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
700 |             count = AbstractMutableHistogram::get_overflow_count(&self);
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
700 |             count = Histogram::get_overflow_count(&self);
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:716:34
    |
716 |             greater_count = self.get_total_count() - c;
    |                                  ^^^^^^^^^^^^^^^ multiple `get_total_count` found
    |
note: candidate #1 is defined in the trait `AbstractMutableHistogram`
   --> src/histograms/abstract_mutable_histogram.rs:764:5
    |
764 |     fn get_total_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:105:5
    |
105 |     fn get_total_count(&self) -> i64;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
716 |             greater_count = AbstractMutableHistogram::get_total_count(&self) - c;
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
716 |             greater_count = Histogram::get_total_count(&self) - c;
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:722:17
    |
722 |         if self.is_empty() {
    |                 ^^^^^^^^ multiple `is_empty` found
    |
note: candidate #1 is defined in the trait `AbstractHistogram`
   --> src/histograms/abstract_histogram.rs:397:5
    |
397 |     fn is_empty(&self) -> bool {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:126:5
    |
126 |     fn is_empty(&self) -> bool;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
722 |         if AbstractHistogram::is_empty(&self) {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
722 |         if Histogram::is_empty(&self) {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:723:20
    |
721 |     fn get_last_non_empty_bin(&self) ->  Self::BIter {
    |                                          ----------- expected `<Self as AbstractMutableHistogram>::BIter` because of return type
722 |         if self.is_empty() {
723 |             return Err(DynaHistError::NoSuchElementError);
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected associated type, found enum `Result`
    |
    = note: expected associated type `<Self as AbstractMutableHistogram>::BIter`
                          found enum `Result<_, fn(anyhow::Error) -> DynaHistError {DynaHistError::NoSuchElementError}>`
help: a method is available that returns `<Self as AbstractMutableHistogram>::BIter`
   --> src/histograms/abstract_mutable_histogram.rs:686:5
    |
686 |     fn get_first_non_empty_bin(&self) ->  Self::BIter {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ consider calling `AbstractMutableHistogram::get_first_non_empty_bin`

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:729:17
    |
729 |         if self.get_overflow_count() > 0 {
    |                 ^^^^^^^^^^^^^^^^^^ multiple `get_overflow_count` found
    |
note: candidate #1 is defined in the trait `AbstractMutableHistogram`
   --> src/histograms/abstract_mutable_histogram.rs:760:5
    |
760 |     fn get_overflow_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:75:5
    |
75  |     fn get_overflow_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
729 |         if AbstractMutableHistogram::get_overflow_count(&self) > 0 {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
729 |         if Histogram::get_overflow_count(&self) > 0 {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:730:36
    |
730 |             absolute_index = Self::get_layout().get_overflow_bin_index();
    |                                    ^^^^^^^^^^ multiple `get_layout` found
    |
note: candidate #1 is defined in the trait `AbstractHistogram`
   --> src/histograms/abstract_histogram.rs:374:5
    |
374 |     fn get_layout(&self) -> Sketch {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:28:5
    |
28  |     fn get_layout(&self) -> &Self::L {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
730 |             absolute_index = AbstractHistogram::get_layout().get_overflow_bin_index();
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
730 |             absolute_index = Histogram::get_layout().get_overflow_bin_index();
    |                              ^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:731:26
    |
731 |             count = self.get_overflow_count();
    |                          ^^^^^^^^^^^^^^^^^^ multiple `get_overflow_count` found
    |
note: candidate #1 is defined in the trait `AbstractMutableHistogram`
   --> src/histograms/abstract_mutable_histogram.rs:760:5
    |
760 |     fn get_overflow_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:75:5
    |
75  |     fn get_overflow_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
731 |             count = AbstractMutableHistogram::get_overflow_count(&self);
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
731 |             count = Histogram::get_overflow_count(&self);
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:732:31
    |
732 |             less_count = self.get_total_count() - self.get_overflow_count();
    |                               ^^^^^^^^^^^^^^^ multiple `get_total_count` found
    |
note: candidate #1 is defined in the trait `AbstractMutableHistogram`
   --> src/histograms/abstract_mutable_histogram.rs:764:5
    |
764 |     fn get_total_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:105:5
    |
105 |     fn get_total_count(&self) -> i64;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
732 |             less_count = AbstractMutableHistogram::get_total_count(&self) - self.get_overflow_count();
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
732 |             less_count = Histogram::get_total_count(&self) - self.get_overflow_count();
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:732:56
    |
732 |             less_count = self.get_total_count() - self.get_overflow_count();
    |                                                        ^^^^^^^^^^^^^^^^^^ multiple `get_overflow_count` found
    |
note: candidate #1 is defined in the trait `AbstractMutableHistogram`
   --> src/histograms/abstract_mutable_histogram.rs:760:5
    |
760 |     fn get_overflow_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:75:5
    |
75  |     fn get_overflow_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
732 |             less_count = self.get_total_count() - AbstractMutableHistogram::get_overflow_count(&self);
    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
732 |             less_count = self.get_total_count() - Histogram::get_overflow_count(&self);
    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:733:24
    |
733 |         } else if self.get_total_count() == self.get_underflow_count() {
    |                        ^^^^^^^^^^^^^^^ multiple `get_total_count` found
    |
note: candidate #1 is defined in the trait `AbstractMutableHistogram`
   --> src/histograms/abstract_mutable_histogram.rs:764:5
    |
764 |     fn get_total_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:105:5
    |
105 |     fn get_total_count(&self) -> i64;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
733 |         } else if AbstractMutableHistogram::get_total_count(&self) == self.get_underflow_count() {
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
733 |         } else if Histogram::get_total_count(&self) == self.get_underflow_count() {
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:733:50
    |
733 |         } else if self.get_total_count() == self.get_underflow_count() {
    |                                                  ^^^^^^^^^^^^^^^^^^^ multiple `get_underflow_count` found
    |
note: candidate #1 is defined in the trait `AbstractMutableHistogram`
   --> src/histograms/abstract_mutable_histogram.rs:756:5
    |
756 |     fn get_underflow_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:90:5
    |
90  |     fn get_underflow_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
733 |         } else if self.get_total_count() == AbstractMutableHistogram::get_underflow_count(&self) {
    |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
733 |         } else if self.get_total_count() == Histogram::get_underflow_count(&self) {
    |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:734:36
    |
734 |             absolute_index = Self::get_layout().get_underflow_bin_index();
    |                                    ^^^^^^^^^^ multiple `get_layout` found
    |
note: candidate #1 is defined in the trait `AbstractHistogram`
   --> src/histograms/abstract_histogram.rs:374:5
    |
374 |     fn get_layout(&self) -> Sketch {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:28:5
    |
28  |     fn get_layout(&self) -> &Self::L {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
734 |             absolute_index = AbstractHistogram::get_layout().get_underflow_bin_index();
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
734 |             absolute_index = Histogram::get_layout().get_underflow_bin_index();
    |                              ^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:735:26
    |
735 |             count = self.get_underflow_count();
    |                          ^^^^^^^^^^^^^^^^^^^ multiple `get_underflow_count` found
    |
note: candidate #1 is defined in the trait `AbstractMutableHistogram`
   --> src/histograms/abstract_mutable_histogram.rs:756:5
    |
756 |     fn get_underflow_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:90:5
    |
90  |     fn get_underflow_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
735 |             count = AbstractMutableHistogram::get_underflow_count(&self);
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
735 |             count = Histogram::get_underflow_count(&self);
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:751:31
    |
751 |             less_count = self.get_total_count() - c;
    |                               ^^^^^^^^^^^^^^^ multiple `get_total_count` found
    |
note: candidate #1 is defined in the trait `AbstractMutableHistogram`
   --> src/histograms/abstract_mutable_histogram.rs:764:5
    |
764 |     fn get_total_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:105:5
    |
105 |     fn get_total_count(&self) -> i64;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
751 |             less_count = AbstractMutableHistogram::get_total_count(&self) - c;
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
751 |             less_count = Histogram::get_total_count(&self) - c;
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0609]: no field `underflow_count` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:757:21
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
757 | |         return self.underflow_count;
    | |                     ^^^^^^^^^^^^^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0609]: no field `overflow_count` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:761:21
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
761 | |         return self.overflow_count;
    | |                     ^^^^^^^^^^^^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0609]: no field `total_count` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:765:21
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
765 | |         return self.total_count;
    | |                     ^^^^^^^^^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0609]: no field `min` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:769:21
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
769 | |         return self.min;
    | |                     ^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0609]: no field `max` on type `&Self`
   --> src/histograms/abstract_mutable_histogram.rs:773:21
    |
184 | / pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
185 | |     type BIter: BinIterator + BinSketch + Iterator;
186 | |     type VIter: ValueIterator + ValueSketch + Iterator;
187 | |
...   |
773 | |         return self.max;
    | |                     ^^^
...   |
830 | |     }
831 | | }
    | |_- type parameter 'Self' declared here

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:777:37
    |
777 |         let layout: Self::L = Self::get_layout();
    |                                     ^^^^^^^^^^ multiple `get_layout` found
    |
note: candidate #1 is defined in the trait `AbstractHistogram`
   --> src/histograms/abstract_histogram.rs:374:5
    |
374 |     fn get_layout(&self) -> Sketch {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:28:5
    |
28  |     fn get_layout(&self) -> &Self::L {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
777 |         let layout: Self::L = AbstractHistogram::get_layout();
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
777 |         let layout: Self::L = Histogram::get_layout();
    |                               ^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:778:24
    |
778 |         let idx: i32 = layout.map_to_bin_index(value);
    |                  ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |                  |
    |                  expected due to this
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
778 |         let idx: i32 = layout.map_to_bin_index(value).try_into().unwrap();
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:779:41
    |
779 |         let under_flow_bin_index: i32 = layout.get_underflow_bin_index();
    |                                   ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |                                   |
    |                                   expected due to this
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
779 |         let under_flow_bin_index: i32 = layout.get_underflow_bin_index().try_into().unwrap();
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:783:40
    |
783 |         let over_flow_bin_index: i32 = layout.get_overflow_bin_index();
    |                                  ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |                                  |
    |                                  expected due to this
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
783 |         let over_flow_bin_index: i32 = layout.get_overflow_bin_index().try_into().unwrap();
    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:796:20
    |
794 |     ) -> Self::H {
    |          ------- expected `<Self as AbstractHistogram>::H` because of return type
795 |         if length == 0 {
796 |             return self;
    |                    ^^^^ expected associated type, found `&Self`
    |
    = note: expected associated type `<Self as AbstractHistogram>::H`
                     found reference `&Self`
help: a method is available that returns `<Self as AbstractHistogram>::H`
   --> src/histograms/abstract_histogram.rs:419:5
    |
419 |     fn add_histogram(&self, histogram: Self::H) -> Self::H {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ consider calling `AbstractHistogram::add_histogram`

error[E0034]: multiple applicable items in scope
   --> src/histograms/abstract_mutable_histogram.rs:799:37
    |
799 |         if length > i64::MAX - self.get_total_count() {
    |                                     ^^^^^^^^^^^^^^^ multiple `get_total_count` found
    |
note: candidate #1 is defined in the trait `AbstractMutableHistogram`
   --> src/histograms/abstract_mutable_histogram.rs:764:5
    |
764 |     fn get_total_count(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in the trait `Histogram`
   --> src/histograms/histogram.rs:105:5
    |
105 |     fn get_total_count(&self) -> i64;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
799 |         if length > i64::MAX - AbstractMutableHistogram::get_total_count(&self) {
    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
799 |         if length > i64::MAX - Histogram::get_total_count(&self) {
    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/abstract_mutable_histogram.rs:800:55
    |
800 |             return Err(DynaHistError::ArithmeticError(&Self::OVERFLOW_MSG));
    |                                                       ^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&&'static str`
    |
help: try using a conversion method
    |
800 |             return Err(DynaHistError::ArithmeticError((&Self::OVERFLOW_MSG).to_string()));
    |                                                       ^                   ^^^^^^^^^^^^^

error[E0599]: no method named `apply_as_double` found for reference `&F` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:803:50
    |
803 |         let last_value: f64 = ascending_sequence.apply_as_double(length - 1);
    |                                                  ^^^^^^^^^^^^^^^ method not found in `&F`
    |
    = note: `ascending_sequence` is a function, perhaps you wish to call it

error[E0061]: this function takes 2 arguments but 1 argument was supplied
   --> src/histograms/abstract_mutable_histogram.rs:804:9
    |
804 |         Self::add_value(last_value);
    |         ^^^^^^^^^^^^^^^ ---------- supplied 1 argument
    |         |
    |         expected 2 arguments
    |
note: associated function defined here
   --> src/histograms/histogram.rs:207:8
    |
207 |     fn add_value(&self, value: f64) -> Self {
    |        ^^^^^^^^^ -----  ----------

error[E0599]: no method named `apply_as_double` found for reference `&F` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:809:49
    |
809 |             let value: f64 = ascending_sequence.apply_as_double(val_index);
    |                                                 ^^^^^^^^^^^^^^^ method not found in `&F`
    |
    = note: `ascending_sequence` is a function, perhaps you wish to call it

error[E0599]: no function or associated item named `find_first` found for type parameter `Self` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:811:45
    |
811 |             let next_val_index: i64 = Self::find_first(
    |                                             ^^^^^^^^^^ function or associated item not found in `Self`
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `find_first`, perhaps you need to add another supertrait for it:
    |
184 | pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions + Algorithms {
    |                                                                                   ^^^^^^^^^^^^

error[E0599]: no method named `apply_as_double` found for reference `&F` in the current scope
   --> src/histograms/abstract_mutable_histogram.rs:814:70
    |
814 |                         || self.map_to_bin_index(&ascending_sequence.apply_as_double(i)) > bin_index
    |                                                                      ^^^^^^^^^^^^^^^ method not found in `&F`
    |
    = note: `ascending_sequence` is a function, perhaps you wish to call it

error[E0061]: this function takes 3 arguments but 2 arguments were supplied
   --> src/histograms/abstract_mutable_histogram.rs:820:13
    |
820 |             Self::add_values(value, next_val_index - val_index);
    |             ^^^^^^^^^^^^^^^^ -----  -------------------------- supplied 2 arguments
    |             |
    |             expected 3 arguments
    |
note: associated function defined here
   --> src/histograms/histogram.rs:233:8
    |
233 |     fn add_values(&self, value: f64, count: i64) -> Self;
    |        ^^^^^^^^^^

error[E0277]: the size for values of type `Self` cannot be known at compilation time
   --> src/histograms/abstract_mutable_histogram.rs:804:9
    |
804 |         Self::add_value(last_value);
    |         ^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
    |
    = note: the return type of a function must have a statically known size
help: consider further restricting `Self`
    |
794 |     ) -> Self::H where Self: Sized {
    |                  ^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/histograms/histogram.rs:28:38
   |
28 |     fn get_layout(&self) -> &Self::L {}
   |                                      ^^ expected reference, found `()`
   |
   = note: expected reference `&<Self as Histogram>::L`
              found unit type `()`

error[E0277]: the size for values of type `Self` cannot be known at compilation time
   --> src/histograms/histogram.rs:207:40
    |
207 |     fn add_value(&self, value: f64) -> Self {
    |                                        ^^^^ doesn't have a size known at compile-time
    |
    = note: the return type of a function must have a statically known size
help: consider further restricting `Self`
    |
207 |     fn add_value(&self, value: f64) -> Self where Self: Sized {
    |                                             ^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `new` found for struct `DynamicHistogram` in the current scope
   --> src/histograms/histogram.rs:351:34
    |
351 |         return DynamicHistogram::new(layout);
    |                                  ^^^ function or associated item not found in `DynamicHistogram`
    |
   ::: src/histograms/dynamic_histogram.rs:24:1
    |
24  | pub struct DynamicHistogram {
    | --------------------------- function or associated item `new` not found for this
    |
    = help: items from traits can only be used if the trait is in scope
    = note: the following traits are implemented but not in scope; perhaps add a `use` for one of them:
            candidate #1: `use crate::values::value_estimation::ValueEstimation;`
            candidate #2: `use crate::layouts::open_telemetry_exponential_buckets_layout::OpenTelemetryLayout;`
            candidate #3: `use crate::quantiles::quantile_estimation::QuantileEstimation;`
            candidate #4: `use crate::histograms::abstract_histogram::AbstractHistogram;`
            and 2 others

error[E0277]: the size for values of type `Self` cannot be known at compilation time
   --> src/histograms/histogram.rs:350:47
    |
350 |     fn create_dynamic(layout: impl Layout) -> Self {
    |                                               ^^^^ doesn't have a size known at compile-time
    |
    = note: the return type of a function must have a statically known size
help: consider further restricting `Self`
    |
350 |     fn create_dynamic(layout: impl Layout) -> Self where Self: Sized {
    |                                                    ^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `new` found for struct `StaticHistogram` in the current scope
   --> src/histograms/histogram.rs:363:33
    |
363 |         return StaticHistogram::new(layout);
    |                                 ^^^ function or associated item not found in `StaticHistogram`
    |
   ::: src/histograms/fixed.rs:21:1
    |
21  | pub struct StaticHistogram {
    | -------------------------- function or associated item `new` not found for this
    |
    = help: items from traits can only be used if the trait is in scope
    = note: the following traits are implemented but not in scope; perhaps add a `use` for one of them:
            candidate #1: `use crate::values::value_estimation::ValueEstimation;`
            candidate #2: `use crate::layouts::open_telemetry_exponential_buckets_layout::OpenTelemetryLayout;`
            candidate #3: `use crate::quantiles::quantile_estimation::QuantileEstimation;`
            candidate #4: `use crate::histograms::abstract_histogram::AbstractHistogram;`
            and 2 others

error[E0277]: the size for values of type `Self` cannot be known at compilation time
   --> src/histograms/histogram.rs:362:46
    |
362 |     fn create_static(layout: impl Layout) -> Self {
    |                                              ^^^^ doesn't have a size known at compile-time
    |
    = note: the return type of a function must have a statically known size
help: consider further restricting `Self`
    |
362 |     fn create_static(layout: impl Layout) -> Self where Self: Sized {
    |                                                   ^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/histogram.rs:387:19
    |
20  | / pub trait Histogram {
21  | |     type L: Layout + Preconditions + Algorithms;
22  | |     type B: BinIterator + BinSketch + Iterator;
23  | |     type Q: QuantileEstimation;
...   |
387 | |         return Ok(DynamicHistogram::read(layout, &data_input));
    | |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `Self`, found enum `Result`
...   |
445 | |     fn non_empty_bins_descending(&self) -> &Self::B;
446 | | }
    | |_- this type parameter
    |
    = note: expected type parameter `Self`
                         found enum `Result<DynamicHistogram, Rc<DynaHistError>>`

error[E0624]: associated function `read` is private
   --> src/histograms/histogram.rs:411:36
    |
411 |           return Ok(StaticHistogram::read(layout, &data_input));
    |                                      ^^^^ private associated function
    |
   ::: src/histograms/fixed.rs:26:5
    |
26  | /     fn read(
27  | |         layout: impl Layout,
28  | |         data_input: &DataInput,
29  | |     ) -> Result<Self, std::rc::Rc<DynaHistError>> {
    | |_________________________________________________- private associated function defined here

error[E0308]: mismatched types
   --> src/histograms/histogram.rs:411:19
    |
20  | / pub trait Histogram {
21  | |     type L: Layout + Preconditions + Algorithms;
22  | |     type B: BinIterator + BinSketch + Iterator;
23  | |     type Q: QuantileEstimation;
...   |
411 | |         return Ok(StaticHistogram::read(layout, &data_input));
    | |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `Self`, found enum `Result`
...   |
445 | |     fn non_empty_bins_descending(&self) -> &Self::B;
446 | | }
    | |_- this type parameter
    |
    = note: expected type parameter `Self`
                         found enum `Result<StaticHistogram, Rc<DynaHistError>>`

error[E0599]: no method named `get_preprocessed_copy` found for enum `Result` in the current scope
   --> src/histograms/histogram.rs:436:29
    |
436 |         return Ok(histogram.get_preprocessed_copy());
    |                             ^^^^^^^^^^^^^^^^^^^^^ method not found in `Result<DynamicHistogram, Rc<DynaHistError>>`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `get_preprocessed_copy`, perhaps you need to implement one of them:
            candidate #1: `AbstractHistogram`
            candidate #2: `Histogram`

error[E0034]: multiple applicable items in scope
   --> src/histograms/fixed.rs:30:37
    |
30  |         let histogram: Self = Self::new(layout);
    |                                     ^^^ multiple `new` found
    |
note: candidate #1 is defined in an impl of the trait `AbstractHistogram` for the type `StaticHistogram`
   --> src/histograms/abstract_histogram.rs:296:5
    |
296 |     fn new(layout: impl Layout) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl of the trait `AbstractMutableHistogram` for the type `StaticHistogram`
   --> src/histograms/fixed.rs:77:5
    |
77  |     fn new(layout: impl Layout) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #3 is defined in the trait `ValueEstimation`
   --> src/values/value_estimation.rs:22:5
    |
22  |     fn new() -> Self;
    |     ^^^^^^^^^^^^^^^^^
note: candidate #4 is defined in the trait `QuantileEstimation`
   --> src/quantiles/quantile_estimation.rs:43:5
    |
43  |     fn new(alphap: f64, betap: f64) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
30  |         let histogram: Self = AbstractHistogram::new(layout);
    |                               ^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
30  |         let histogram: Self = AbstractMutableHistogram::new(layout);
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #3
    |
30  |         let histogram: Self = ValueEstimation::new(layout);
    |                               ^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #4
    |
30  |         let histogram: Self = QuantileEstimation::new(layout);
    |                               ^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/histograms/fixed.rs:31:27
   |
31 |         Self::deserialize(histogram, &data_input);
   |                           ^^^^^^^^^
   |                           |
   |                           expected reference, found struct `StaticHistogram`
   |                           help: consider borrowing here: `&histogram`
   |
   = note: expected reference `&_`
                 found struct `StaticHistogram`

error[E0609]: no field `total_count` on type `&StaticHistogram`
  --> src/histograms/fixed.rs:42:21
   |
42 |             if self.total_count + count >= 0 {
   |                     ^^^^^^^^^^^ unknown field
   |
   = note: available fields are: `counts`

error[E0609]: no field `total_count` on type `&StaticHistogram`
  --> src/histograms/fixed.rs:43:22
   |
43 |                 self.total_count += count;
   |                      ^^^^^^^^^^^ unknown field
   |
   = note: available fields are: `counts`

error[E0061]: this function takes 2 arguments but 1 argument was supplied
   --> src/histograms/fixed.rs:44:17
    |
44  |                 Self::update_min_max(value);
    |                 ^^^^^^^^^^^^^^^^^^^^ ----- supplied 1 argument
    |                 |
    |                 expected 2 arguments
    |
note: associated function defined here
   --> src/histograms/abstract_mutable_histogram.rs:205:8
    |
205 |     fn update_min_max(&self, value: f64) {
    |        ^^^^^^^^^^^^^^ -----  ----------

error[E0034]: multiple applicable items in scope
   --> src/histograms/fixed.rs:45:44
    |
45  |                 let array_idx: i32 = Self::get_layout().map_to_bin_index(value)
    |                                            ^^^^^^^^^^ multiple `get_layout` found
    |
note: candidate #1 is defined in an impl of the trait `Histogram` for the type `StaticHistogram`
   --> src/histograms/histogram.rs:28:5
    |
28  |     fn get_layout(&self) -> &Self::L {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl of the trait `AbstractHistogram` for the type `StaticHistogram`
   --> src/histograms/abstract_histogram.rs:374:5
    |
374 |     fn get_layout(&self) -> Sketch {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
45  |                 let array_idx: i32 = Histogram::get_layout().map_to_bin_index(value)
    |                                      ^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
45  |                 let array_idx: i32 = AbstractHistogram::get_layout().map_to_bin_index(value)
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/fixed.rs:46:29
    |
46  |                     - Self::get_layout().get_underflow_bin_index()
    |                             ^^^^^^^^^^ multiple `get_layout` found
    |
note: candidate #1 is defined in an impl of the trait `Histogram` for the type `StaticHistogram`
   --> src/histograms/histogram.rs:28:5
    |
28  |     fn get_layout(&self) -> &Self::L {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl of the trait `AbstractHistogram` for the type `StaticHistogram`
   --> src/histograms/abstract_histogram.rs:374:5
    |
374 |     fn get_layout(&self) -> Sketch {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
46  |                     - Histogram::get_layout().get_underflow_bin_index()
    |                       ^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
46  |                     - AbstractHistogram::get_layout().get_underflow_bin_index()
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/histograms/fixed.rs:48:50
   |
48 |                 if array_idx >= 0 && array_idx < self.counts.len() {
   |                                                  ^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
   |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
   |
48 |                 if array_idx >= 0 && array_idx < self.counts.len().try_into().unwrap() {
   |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: the type `[i64]` cannot be indexed by `i32`
  --> src/histograms/fixed.rs:49:21
   |
49 |                     self.counts[array_idx] += count;
   |                     ^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`
   |
   = help: the trait `SliceIndex<[i64]>` is not implemented for `i32`
   = note: required because of the requirements on the impl of `Index<i32>` for `Vec<i64>`

error[E0061]: this function takes 2 arguments but 1 argument was supplied
   --> src/histograms/fixed.rs:52:25
    |
52  |                         Self::increment_underflow_count(count);
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ----- supplied 1 argument
    |                         |
    |                         expected 2 arguments
    |
note: associated function defined here
   --> src/histograms/abstract_mutable_histogram.rs:193:8
    |
193 |     fn increment_underflow_count(&self, count: i64) {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^ -----  ----------

error[E0061]: this function takes 2 arguments but 1 argument was supplied
   --> src/histograms/fixed.rs:54:25
    |
54  |                         Self::increment_overflow_count(count);
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ----- supplied 1 argument
    |                         |
    |                         expected 2 arguments
    |
note: associated function defined here
   --> src/histograms/abstract_mutable_histogram.rs:197:8
    |
197 |     fn increment_overflow_count(&self, count: i64) {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^ -----  ----------

error[E0609]: no field `total_count` on type `&StaticHistogram`
  --> src/histograms/fixed.rs:57:26
   |
57 |                     self.total_count -= count;
   |                          ^^^^^^^^^^^ unknown field
   |
   = note: available fields are: `counts`

error[E0308]: mismatched types
  --> src/histograms/fixed.rs:59:33
   |
59 |                         source: Self::NAN_VALUE_MSG,
   |                                 ^^^^^^^^^^^^^^^^^^^ expected struct `std::io::Error`, found `&str`

error[E0308]: mismatched types
  --> src/histograms/fixed.rs:58:28
   |
40 |       fn add_values(&self, value: f64, count: i64) -> Self {
   |                                                       ---- expected `StaticHistogram` because of return type
...
58 |                       return Err(DynaHistError::IllegalArgumentError {
   |  ____________________________^
59 | |                         source: Self::NAN_VALUE_MSG,
60 | |                     });
   | |______________________^ expected struct `StaticHistogram`, found enum `Result`
   |
   = note: expected struct `StaticHistogram`
                found enum `Result<_, DynaHistError>`

error[E0308]: mismatched types
  --> src/histograms/fixed.rs:63:59
   |
63 |                 return Err(DynaHistError::ArithmeticError(Self::OVERFLOW_MSG));
   |                                                           ^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`
   |                                                           |
   |                                                           expected struct `String`, found `&str`

error[E0308]: mismatched types
  --> src/histograms/fixed.rs:67:62
   |
67 |             return Err(DynaHistError::IllegalArgumentError { source });
   |                                                              ^^^^^^ expected struct `std::io::Error`, found struct `String`

error[E0599]: no associated item named `BYTES` found for type `i64` in the current scope
  --> src/histograms/fixed.rs:86:50
   |
86 | ...   return ((self.counts.len() as i64 * i64::BYTES) + Self::ESTIMATED_OBJECT_HEADER_FOOTPRINT_IN_BYTES + Self::ESTIMATED_REFERENCE_FOOT...
   |                                                ^^^^^ associated item not found in `i64`

error[E0599]: no associated item named `BYTES` found for type `i32` in the current scope
  --> src/histograms/fixed.rs:87:14
   |
87 |         i32::BYTES)
   |              ^^^^^ associated item not found in `i32`

error[E0034]: multiple applicable items in scope
   --> src/histograms/fixed.rs:88:20
    |
88  |             + self.get_estimated_footprint_in_bytes();
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ multiple `get_estimated_footprint_in_bytes` found
    |
note: candidate #1 is defined in an impl of the trait `Histogram` for the type `StaticHistogram`
   --> src/histograms/histogram.rs:333:5
    |
333 |     fn get_estimated_footprint_in_bytes(&self) -> i64;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl of the trait `AbstractHistogram` for the type `StaticHistogram`
   --> src/histograms/abstract_histogram.rs:413:5
    |
413 |     fn get_estimated_footprint_in_bytes(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #3 is defined in an impl of the trait `AbstractMutableHistogram` for the type `StaticHistogram`
   --> src/histograms/fixed.rs:85:5
    |
85  |     fn get_estimated_footprint_in_bytes(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
88  |             + Histogram::get_estimated_footprint_in_bytes(&self);
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
88  |             + AbstractHistogram::get_estimated_footprint_in_bytes(&self);
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #3
    |
88  |             + AbstractMutableHistogram::get_estimated_footprint_in_bytes(&self);
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/fixed.rs:92:21
    |
92  |         return self.get_layout().get_underflow_bin_index() + 1;
    |                     ^^^^^^^^^^ multiple `get_layout` found
    |
note: candidate #1 is defined in an impl of the trait `Histogram` for the type `StaticHistogram`
   --> src/histograms/histogram.rs:28:5
    |
28  |     fn get_layout(&self) -> &Self::L {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl of the trait `AbstractHistogram` for the type `StaticHistogram`
   --> src/histograms/abstract_histogram.rs:374:5
    |
374 |     fn get_layout(&self) -> Sketch {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
92  |         return Histogram::get_layout(&self).get_underflow_bin_index() + 1;
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
92  |         return AbstractHistogram::get_layout(&self).get_underflow_bin_index() + 1;
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/fixed.rs:96:21
    |
96  |         return self.get_layout().get_overflow_bin_index();
    |                     ^^^^^^^^^^ multiple `get_layout` found
    |
note: candidate #1 is defined in an impl of the trait `Histogram` for the type `StaticHistogram`
   --> src/histograms/histogram.rs:28:5
    |
28  |     fn get_layout(&self) -> &Self::L {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl of the trait `AbstractHistogram` for the type `StaticHistogram`
   --> src/histograms/abstract_histogram.rs:374:5
    |
374 |     fn get_layout(&self) -> Sketch {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
96  |         return Histogram::get_layout(&self).get_overflow_bin_index();
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
96  |         return AbstractHistogram::get_layout(&self).get_overflow_bin_index();
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: the type `[i64]` cannot be indexed by `i32`
   --> src/histograms/fixed.rs:100:16
    |
100 |         return self.counts[bin_index - self.min_allocated_bin_index_inclusive()];
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`
    |
    = help: the trait `SliceIndex<[i64]>` is not implemented for `i32`
    = note: required because of the requirements on the impl of `Index<i32>` for `Vec<i64>`

error[E0308]: mismatched types
   --> src/histograms/fixed.rs:107:23
    |
107 |             while i < self.counts.len() {
    |                       ^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
107 |             while i < self.counts.len().try_into().unwrap() {
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: the type `[i64]` cannot be indexed by `i32`
   --> src/histograms/fixed.rs:109:26
    |
109 |                     c |= self.counts[i];
    |                          ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`
    |
    = help: the trait `SliceIndex<[i64]>` is not implemented for `i32`
    = note: required because of the requirements on the impl of `Index<i32>` for `Vec<i64>`

error[E0599]: no method named `determine_required_mode` found for reference `&StaticHistogram` in the current scope
   --> src/histograms/fixed.rs:115:21
    |
115 |         return self.determine_required_mode(c);
    |                     ^^^^^^^^^^^^^^^^^^^^^^^ this is an associated function, not a method
    |
    = note: found the following associated functions; to be used as methods, functions must have a `self` parameter
note: the candidate is defined in the trait `AbstractMutableHistogram`
   --> src/histograms/abstract_mutable_histogram.rs:300:5
    |
300 |     fn determine_required_mode(value: i64) -> i8 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
note: `AbstractMutableHistogram` defines an item `determine_required_mode`, perhaps you need to implement it
   --> src/histograms/abstract_mutable_histogram.rs:184:1
    |
184 | pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: use associated function syntax instead
    |
115 |         return StaticHistogram::determine_required_mode(c);
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for the candidate
    |
115 |         return AbstractMutableHistogram::determine_required_mode(&self, c);
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/fixed.rs:128:35
    |
128 |         if absolute_index <= self.get_layout().get_underflow_bin_index() {
    |                                   ^^^^^^^^^^ multiple `get_layout` found
    |
note: candidate #1 is defined in an impl of the trait `Histogram` for the type `StaticHistogram`
   --> src/histograms/histogram.rs:28:5
    |
28  |     fn get_layout(&self) -> &Self::L {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl of the trait `AbstractHistogram` for the type `StaticHistogram`
   --> src/histograms/abstract_histogram.rs:374:5
    |
374 |     fn get_layout(&self) -> Sketch {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
128 |         if absolute_index <= Histogram::get_layout(&self).get_underflow_bin_index() {
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
128 |         if absolute_index <= AbstractHistogram::get_layout(&self).get_underflow_bin_index() {
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/fixed.rs:130:42
    |
130 |         } else if absolute_index >= self.get_layout().get_overflow_bin_index() {
    |                                          ^^^^^^^^^^ multiple `get_layout` found
    |
note: candidate #1 is defined in an impl of the trait `Histogram` for the type `StaticHistogram`
   --> src/histograms/histogram.rs:28:5
    |
28  |     fn get_layout(&self) -> &Self::L {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl of the trait `AbstractHistogram` for the type `StaticHistogram`
   --> src/histograms/abstract_histogram.rs:374:5
    |
374 |     fn get_layout(&self) -> Sketch {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
130 |         } else if absolute_index >= Histogram::get_layout(&self).get_overflow_bin_index() {
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
130 |         } else if absolute_index >= AbstractHistogram::get_layout(&self).get_overflow_bin_index() {
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/fixed.rs:133:47
    |
133 |             self.counts[absolute_index - self.get_layout().get_underflow_bin_index() - 1] += count;
    |                                               ^^^^^^^^^^ multiple `get_layout` found
    |
note: candidate #1 is defined in an impl of the trait `Histogram` for the type `StaticHistogram`
   --> src/histograms/histogram.rs:28:5
    |
28  |     fn get_layout(&self) -> &Self::L {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl of the trait `AbstractHistogram` for the type `StaticHistogram`
   --> src/histograms/abstract_histogram.rs:374:5
    |
374 |     fn get_layout(&self) -> Sketch {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
133 |             self.counts[absolute_index - Histogram::get_layout(&self).get_underflow_bin_index() - 1] += count;
    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
133 |             self.counts[absolute_index - AbstractHistogram::get_layout(&self).get_underflow_bin_index() - 1] += count;
    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: the type `[i64]` cannot be indexed by `i32`
   --> src/histograms/fixed.rs:133:13
    |
133 |             self.counts[absolute_index - self.get_layout().get_underflow_bin_index() - 1] += count;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`
    |
    = help: the trait `SliceIndex<[i64]>` is not implemented for `i32`
    = note: required because of the requirements on the impl of `Index<i32>` for `Vec<i64>`

error[E0599]: no method named `get_count_of_non_empty_bin` found for reference `&preprocessed_histogram::BinCopyImpl` in the current scope
  --> src/histograms/preprocessed_histogram.rs:29:21
   |
29 |         return self.get_count_of_non_empty_bin(&self.get_non_empty_index());
   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&preprocessed_histogram::BinCopyImpl`

error[E0609]: no field `accumulated_counts` on type `&preprocessed_histogram::BinCopyImpl`
  --> src/histograms/preprocessed_histogram.rs:33:58
   |
33 |         return  if self.get_non_empty_index() > 0 { self.accumulated_counts[self.get_non_empty_index() - 1] } else { 0 };
   |                                                          ^^^^^^^^^^^^^^^^^^ unknown field
   |
   = note: available fields are: `non_empty_bin_index`

error[E0599]: no method named `get_total_count` found for reference `&preprocessed_histogram::BinCopyImpl` in the current scope
  --> src/histograms/preprocessed_histogram.rs:37:21
   |
37 |         return self.get_total_count() - self.accumulated_counts[self.get_non_empty_index()];
   |                     ^^^^^^^^^^^^^^^ method not found in `&preprocessed_histogram::BinCopyImpl`
   |
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following traits define an item `get_total_count`, perhaps you need to implement one of them:
           candidate #1: `AbstractMutableHistogram`
           candidate #2: `Histogram`

error[E0609]: no field `accumulated_counts` on type `&preprocessed_histogram::BinCopyImpl`
  --> src/histograms/preprocessed_histogram.rs:37:46
   |
37 |         return self.get_total_count() - self.accumulated_counts[self.get_non_empty_index()];
   |                                              ^^^^^^^^^^^^^^^^^^ unknown field
   |
   = note: available fields are: `non_empty_bin_index`

error[E0609]: no field `non_empty_bin_indices` on type `&preprocessed_histogram::BinCopyImpl`
  --> src/histograms/preprocessed_histogram.rs:41:21
   |
41 |         return self.non_empty_bin_indices[self.get_non_empty_index()];
   |                     ^^^^^^^^^^^^^^^^^^^^^ help: a field with a similar name exists: `non_empty_bin_index`

error[E0609]: no field `histogram` on type `&preprocessed_histogram::BinCopyImpl`
  --> src/histograms/preprocessed_histogram.rs:49:21
   |
49 |         return self.histogram;
   |                     ^^^^^^^^^ unknown field
   |
   = note: available fields are: `non_empty_bin_index`

error[E0609]: no field `accumulated_counts` on type `&preprocessed_histogram::BinIteratorImpl`
  --> src/histograms/preprocessed_histogram.rs:91:49
   |
91 |         if self.non_empty_bin_index + 1 >= self.accumulated_counts.len() {
   |                                                 ^^^^^^^^^^^^^^^^^^ unknown field
   |
   = note: available fields are: `non_empty_bin_index`

error[E0308]: mismatched types
  --> src/histograms/preprocessed_histogram.rs:92:20
   |
90 |     fn next(&self) {
   |                    - expected `()` because of default return type
91 |         if self.non_empty_bin_index + 1 >= self.accumulated_counts.len() {
92 |             return Err(DynaHistError::NoSuchElementError);
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found enum `Result`
   |
   = note: expected unit type `()`
                   found enum `Result<_, fn(anyhow::Error) -> DynaHistError {DynaHistError::NoSuchElementError}>`

error[E0308]: mismatched types
  --> src/histograms/preprocessed_histogram.rs:99:20
   |
97 |     fn previous(&self) {
   |                        - expected `()` because of default return type
98 |         if self.non_empty_bin_index <= 0 {
99 |             return Err(DynaHistError::NoSuchElementError);
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found enum `Result`
   |
   = note: expected unit type `()`
                   found enum `Result<_, fn(anyhow::Error) -> DynaHistError {DynaHistError::NoSuchElementError}>`

error[E0308]: mismatched types
   --> src/histograms/preprocessed_histogram.rs:105:16
    |
104 |     fn get_bin_copy(&self) -> Self {
    |                               ---- expected `preprocessed_histogram::BinIteratorImpl` because of return type
105 |         return BinCopyImpl::new(self.non_empty_bin_index);
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `preprocessed_histogram::BinIteratorImpl`, found struct `preprocessed_histogram::BinCopyImpl`

error[E0609]: no field `histogram_type` on type `impl Histogram`
   --> src/histograms/preprocessed_histogram.rs:129:22
    |
129 |         if histogram.histogram_type == "PreprocessedHistogram".to_string() {
    |                      ^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/preprocessed_histogram.rs:130:20
    |
128 |     fn of( histogram: impl Histogram) -> Self {
    |                       --------------     ---- expected `PreprocessedHistogram` because of return type
    |                       |
    |                       this type parameter
129 |         if histogram.histogram_type == "PreprocessedHistogram".to_string() {
130 |             return histogram;
    |                    ^^^^^^^^^ expected struct `PreprocessedHistogram`, found type parameter `impl Histogram`
    |
    = note:      expected struct `PreprocessedHistogram`
            found type parameter `impl Histogram`

error[E0191]: the value of the associated type `B` (from trait `BinIterator`) must be specified
   --> src/histograms/preprocessed_histogram.rs:153:36
    |
153 |              let bin_iterator: dyn BinIterator = first_non_empty_bin;
    |                                    ^^^^^^^^^^^ help: specify the associated type: `BinIterator<B = Type>`
    |
   ::: src/bins/bin_iterator.rs:16:5
    |
16  |     type B: BinSketch;
    |     ------------------ `B` defined here

error[E0609]: no field `min` on type `&&<impl Histogram as Histogram>::L`
   --> src/histograms/preprocessed_histogram.rs:138:16
    |
138 |         layout.min = histogram.get_min();
    |                ^^^

error[E0609]: no field `max` on type `&&<impl Histogram as Histogram>::L`
   --> src/histograms/preprocessed_histogram.rs:139:16
    |
139 |         layout.max = histogram.get_max();
    |                ^^^

error[E0609]: no field `non_empty_bin_indices` on type `&&<impl Histogram as Histogram>::L`
   --> src/histograms/preprocessed_histogram.rs:141:20
    |
141 |             layout.non_empty_bin_indices = Self::EMPTY_BIN_INDICES;
    |                    ^^^^^^^^^^^^^^^^^^^^^

error[E0609]: no field `accumulated_counts` on type `&&<impl Histogram as Histogram>::L`
   --> src/histograms/preprocessed_histogram.rs:142:20
    |
142 |             layout.accumulated_counts = Self::EMPTY_ACCUMULATED_COUNTS;
    |                    ^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/preprocessed_histogram.rs:140:33
    |
140 |           if histogram.is_empty() {
    |  _________________________________^
141 | |             layout.non_empty_bin_indices = Self::EMPTY_BIN_INDICES;
142 | |             layout.accumulated_counts = Self::EMPTY_ACCUMULATED_COUNTS;
143 | |         } else {
    | |_________^ expected struct `PreprocessedHistogram`, found `()`

error[E0308]: mismatched types
   --> src/histograms/preprocessed_histogram.rs:149:56
    |
149 |              let non_empty_bin_indices_tmp_v = vec![0; bin_index_range];
    |                                                        ^^^^^^^^^^^^^^^ expected `usize`, found `i32`
    |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
149 |              let non_empty_bin_indices_tmp_v = vec![0; bin_index_range.try_into().unwrap()];
    |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/preprocessed_histogram.rs:151:53
    |
151 |              let accumulated_counts_tmp_v = vec![0; bin_index_range];
    |                                                     ^^^^^^^^^^^^^^^ expected `usize`, found `i32`
    |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
151 |              let accumulated_counts_tmp_v = vec![0; bin_index_range.try_into().unwrap()];
    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/preprocessed_histogram.rs:153:50
    |
153 |              let bin_iterator: dyn BinIterator = first_non_empty_bin;
    |                                ---------------   ^^^^^^^^^^^^^^^^^^^ expected trait object `dyn BinIterator`, found reference
    |                                |
    |                                expected due to this
    |
    = note: expected trait object `dyn BinIterator`
                  found reference `&<impl Histogram as Histogram>::B`

error[E0277]: the size for values of type `dyn BinIterator` cannot be known at compilation time
   --> src/histograms/preprocessed_histogram.rs:153:18
    |
153 |              let bin_iterator: dyn BinIterator = first_non_empty_bin;
    |                  ^^^^^^^^^^^^ doesn't have a size known at compile-time
    |
    = help: the trait `Sized` is not implemented for `dyn BinIterator`
    = note: all local variables must have a statically known size
    = help: unsized locals are gated as an unstable feature

error[E0277]: the type `[i32]` cannot be indexed by `i32`
   --> src/histograms/preprocessed_histogram.rs:159:17
    |
159 |                 non_empty_bin_indices_tmp[non_empty_bin_counter] = bin_iterator.get_bin_index();
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`
    |
    = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`
    = note: required because of the requirements on the impl of `Index<i32>` for `[i32]`

error[E0277]: the type `[i64]` cannot be indexed by `i32`
   --> src/histograms/preprocessed_histogram.rs:160:17
    |
160 | ...   accumulated_counts_tmp[non_empty_bin_counter] = accumulated_counts_tmp[non_empty_bin_counter - 1] + bin_iterator.get_bin_count();
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`
    |
    = help: the trait `SliceIndex<[i64]>` is not implemented for `i32`
    = note: required because of the requirements on the impl of `Index<i32>` for `[i64]`

error[E0277]: the type `[i64]` cannot be indexed by `i32`
   --> src/histograms/preprocessed_histogram.rs:160:65
    |
160 | ...bin_counter] = accumulated_counts_tmp[non_empty_bin_counter - 1] + bin_iterator.get_bin_count();
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`
    |
    = help: the trait `SliceIndex<[i64]>` is not implemented for `i32`
    = note: required because of the requirements on the impl of `Index<i32>` for `[i64]`

error[E0609]: no field `non_empty_bin_indices` on type `&&<impl Histogram as Histogram>::L`
   --> src/histograms/preprocessed_histogram.rs:163:20
    |
163 |             layout.non_empty_bin_indices = Self::copy_of(&non_empty_bin_indices_tmp, non_empty_bin_counter);
    |                    ^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/preprocessed_histogram.rs:163:86
    |
163 |             layout.non_empty_bin_indices = Self::copy_of(&non_empty_bin_indices_tmp, non_empty_bin_counter);
    |                                                                                      ^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `i32`
    |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
163 |             layout.non_empty_bin_indices = Self::copy_of(&non_empty_bin_indices_tmp, non_empty_bin_counter.try_into().unwrap());
    |                                                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0609]: no field `accumulated_counts` on type `&&<impl Histogram as Histogram>::L`
   --> src/histograms/preprocessed_histogram.rs:164:20
    |
164 |             layout.accumulated_counts = Self::copy_of(&accumulated_counts_tmp, non_empty_bin_counter);
    |                    ^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/preprocessed_histogram.rs:164:55
    |
164 |             layout.accumulated_counts = Self::copy_of(&accumulated_counts_tmp, non_empty_bin_counter);
    |                                                       ^^^^^^^^^^^^^^^^^^^^^^^ expected slice `[i32]`, found `&[i64]`
    |
    = note: expected reference `&[i32]`
               found reference `&&[i64]`

error[E0308]: mismatched types
   --> src/histograms/preprocessed_histogram.rs:164:80
    |
164 |             layout.accumulated_counts = Self::copy_of(&accumulated_counts_tmp, non_empty_bin_counter);
    |                                                                                ^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `i32`
    |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
164 |             layout.accumulated_counts = Self::copy_of(&accumulated_counts_tmp, non_empty_bin_counter.try_into().unwrap());
    |                                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/preprocessed_histogram.rs:143:16
    |
143 |           } else {
    |  ________________^
144 | |              let first_non_empty_bin = histogram.get_first_non_empty_bin();
145 | |              let last_non_empty_bin = histogram.get_last_non_empty_bin();
146 | |              let first_non_empty_bin_index: i32 = first_non_empty_bin.get_bin_index();
...   |
164 | |             layout.accumulated_counts = Self::copy_of(&accumulated_counts_tmp, non_empty_bin_counter);
165 | |         }
    | |_________^ expected struct `PreprocessedHistogram`, found `()`

error[E0308]: mismatched types
   --> src/histograms/preprocessed_histogram.rs:177:9
    |
174 |     fn copy_of(src: &[i32], length: usize) {
    |                                            - expected `()` because of default return type
...
177 |         dst
    |         ^^^ expected `()`, found `&Vec<i32>`
    |
    = note: expected unit type `()`
               found reference `&Vec<i32>`

error[E0599]: no function or associated item named `check_argument` found for struct `PreprocessedHistogram` in the current scope
   --> src/histograms/preprocessed_histogram.rs:182:15
    |
110 | pub struct PreprocessedHistogram {
    | -------------------------------- function or associated item `check_argument` not found for this
...
182 |         Self::check_argument(rank >= 0);
    |               ^^^^^^^^^^^^^^ function or associated item not found in `PreprocessedHistogram`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `Preconditions` defines an item `check_argument`, perhaps you need to implement it
   --> src/utilities/preconditions.rs:10:1
    |
10  | pub trait Preconditions {
    | ^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `check_argument` found for struct `PreprocessedHistogram` in the current scope
   --> src/histograms/preprocessed_histogram.rs:183:15
    |
110 | pub struct PreprocessedHistogram {
    | -------------------------------- function or associated item `check_argument` not found for this
...
183 |         Self::check_argument(rank < total_count);
    |               ^^^^^^^^^^^^^^ function or associated item not found in `PreprocessedHistogram`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `Preconditions` defines an item `check_argument`, perhaps you need to implement it
   --> src/utilities/preconditions.rs:10:1
    |
10  | pub trait Preconditions {
    | ^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/preprocessed_histogram.rs:184:22
    |
184 |         let i: i32 = &self.accumulated_counts.binary_search(&(rank + 1));
    |                ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found reference
    |                |
    |                expected due to this
    |
    = note:   expected type `i32`
            found reference `&Result<usize, usize>`

error[E0277]: the type `[i64]` cannot be indexed by `i32`
   --> src/histograms/preprocessed_histogram.rs:190:20
    |
190 |             return self.accumulated_counts[non_empty_bin_index] - self.accumulated_counts[non_empty_bin_index - 1];
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`
    |
    = help: the trait `SliceIndex<[i64]>` is not implemented for `i32`
    = note: required because of the requirements on the impl of `Index<i32>` for `Vec<i64>`

error[E0277]: the type `[i64]` cannot be indexed by `i32`
   --> src/histograms/preprocessed_histogram.rs:190:67
    |
190 |             return self.accumulated_counts[non_empty_bin_index] - self.accumulated_counts[non_empty_bin_index - 1];
    |                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`
    |
    = help: the trait `SliceIndex<[i64]>` is not implemented for `i32`
    = note: required because of the requirements on the impl of `Index<i32>` for `Vec<i64>`

error[E0277]: the type `[i64]` cannot be indexed by `i32`
   --> src/histograms/preprocessed_histogram.rs:192:20
    |
192 |             return self.accumulated_counts[non_empty_bin_index];
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`
    |
    = help: the trait `SliceIndex<[i64]>` is not implemented for `i32`
    = note: required because of the requirements on the impl of `Index<i32>` for `Vec<i64>`

error[E0034]: multiple applicable items in scope
   --> src/histograms/preprocessed_histogram.rs:197:17
    |
197 |         if self.is_empty() {
    |                 ^^^^^^^^ multiple `is_empty` found
    |
note: candidate #1 is defined in an impl of the trait `AbstractHistogram` for the type `PreprocessedHistogram`
   --> src/histograms/abstract_histogram.rs:397:5
    |
397 |     fn is_empty(&self) -> bool {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl of the trait `Histogram` for the type `PreprocessedHistogram`
   --> src/histograms/histogram.rs:126:5
    |
126 |     fn is_empty(&self) -> bool;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #3 is defined in the trait `ExactSizeIterator`
   --> /home/hedge/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:134:5
    |
134 |     fn is_empty(&self) -> bool {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
197 |         if AbstractHistogram::is_empty(&self) {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
197 |         if Histogram::is_empty(&self) {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #3
    |
197 |         if ExactSizeIterator::is_empty(&self) {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/preprocessed_histogram.rs:198:20
    |
196 |     fn check_if_element_exists(&self) {
    |                                       - expected `()` because of default return type
197 |         if self.is_empty() {
198 |             return Err(DynaHistError::NoSuchElementError);
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found enum `Result`
    |
    = note: expected unit type `()`
                    found enum `Result<_, fn(anyhow::Error) -> DynaHistError {DynaHistError::NoSuchElementError}>`

error[E0308]: mismatched types
   --> src/histograms/preprocessed_histogram.rs:209:37
    |
209 |         return BinIteratorImpl::new(self.non_empty_bin_indices.len() - 1);
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
209 |         return BinIteratorImpl::new((self.non_empty_bin_indices.len() - 1).try_into().unwrap());
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/preprocessed_histogram.rs:225:41
    |
225 |          let non_empty_bin_index: i32 = &self.non_empty_bin_indices.binary_search(&bin_index);
    |                                   ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found reference
    |                                   |
    |                                   expected due to this
    |
    = note:   expected type `i32`
            found reference `&Result<usize, usize>`

error[E0034]: multiple applicable items in scope
   --> src/histograms/preprocessed_histogram.rs:250:41
    |
250 |         Histogram::create_dynamic(&self.get_layout()).add_histogram().write(&data_output)
    |                                         ^^^^^^^^^^ multiple `get_layout` found
    |
note: candidate #1 is defined in an impl of the trait `AbstractHistogram` for the type `PreprocessedHistogram`
   --> src/histograms/abstract_histogram.rs:374:5
    |
374 |     fn get_layout(&self) -> Sketch {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl of the trait `Histogram` for the type `PreprocessedHistogram`
   --> src/histograms/histogram.rs:28:5
    |
28  |     fn get_layout(&self) -> &Self::L {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
250 |         Histogram::create_dynamic(&AbstractHistogram::get_layout(&self)).add_histogram().write(&data_output)
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
250 |         Histogram::create_dynamic(&Histogram::get_layout(&self)).add_histogram().write(&data_output)
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no associated item named `BYTES` found for type `f64` in the current scope
   --> src/histograms/preprocessed_histogram.rs:255:18
    |
255 |         2 * f64::BYTES +
    |                  ^^^^^ associated item not found in `f64`

error[E0599]: no associated item named `BYTES` found for type `i32` in the current scope
   --> src/histograms/preprocessed_histogram.rs:258:22
    |
258 |                 i32::BYTES + // accumulated_counts
    |                      ^^^^^ associated item not found in `i32`

error[E0599]: no associated item named `BYTES` found for type `i64` in the current scope
   --> src/histograms/preprocessed_histogram.rs:259:63
    |
259 |                 (self.accumulated_counts.len() as i64) * i64::BYTES
    |                                                               ^^^^^ associated item not found in `i64`

error[E0599]: no associated item named `BYTES` found for type `i32` in the current scope
   --> src/histograms/preprocessed_histogram.rs:263:22
    |
263 |                 i32::BYTES + // non_empty_bin_indices
    |                      ^^^^^ associated item not found in `i32`

error[E0599]: no associated item named `BYTES` found for type `i32` in the current scope
   --> src/histograms/preprocessed_histogram.rs:264:66
    |
264 |                 (self.non_empty_bin_indices.len() as i64) * i32::BYTES
    |                                                                  ^^^^^ associated item not found in `i32`

error[E0034]: multiple applicable items in scope
   --> src/histograms/dynamic_histogram.rs:50:61
    |
50  |         let histogram: DynamicHistogram = DynamicHistogram::new(layout);
    |                                                             ^^^ multiple `new` found
    |
note: candidate #1 is defined in an impl of the trait `AbstractHistogram` for the type `DynamicHistogram`
   --> src/histograms/abstract_histogram.rs:296:5
    |
296 |     fn new(layout: impl Layout) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl of the trait `AbstractMutableHistogram` for the type `DynamicHistogram`
   --> src/histograms/dynamic_histogram.rs:138:5
    |
138 |     fn new(layout: impl Layout) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #3 is defined in the trait `ValueEstimation`
   --> src/values/value_estimation.rs:22:5
    |
22  |     fn new() -> Self;
    |     ^^^^^^^^^^^^^^^^^
note: candidate #4 is defined in the trait `QuantileEstimation`
   --> src/quantiles/quantile_estimation.rs:43:5
    |
43  |     fn new(alphap: f64, betap: f64) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
50  |         let histogram: DynamicHistogram = AbstractHistogram::new(layout);
    |                                           ^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
50  |         let histogram: DynamicHistogram = AbstractMutableHistogram::new(layout);
    |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #3
    |
50  |         let histogram: DynamicHistogram = ValueEstimation::new(layout);
    |                                           ^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #4
    |
50  |         let histogram: DynamicHistogram = QuantileEstimation::new(layout);
    |                                           ^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/histograms/dynamic_histogram.rs:51:27
   |
51 |         Self::deserialize(histogram, &data_input);
   |                           ^^^^^^^^^
   |                           |
   |                           expected reference, found struct `DynamicHistogram`
   |                           help: consider borrowing here: `&histogram`
   |
   = note: expected reference `&_`
                 found struct `DynamicHistogram`

error[E0034]: multiple applicable items in scope
   --> src/histograms/dynamic_histogram.rs:56:40
    |
56  |         let absolute_index: i32 = self.get_layout().map_to_bin_index(value);
    |                                        ^^^^^^^^^^ multiple `get_layout` found
    |
note: candidate #1 is defined in an impl of the trait `AbstractHistogram` for the type `DynamicHistogram`
   --> src/histograms/abstract_histogram.rs:374:5
    |
374 |     fn get_layout(&self) -> Sketch {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl of the trait `Histogram` for the type `DynamicHistogram`
   --> src/histograms/histogram.rs:28:5
    |
28  |     fn get_layout(&self) -> &Self::L {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
56  |         let absolute_index: i32 = AbstractHistogram::get_layout(&self).map_to_bin_index(value);
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
56  |         let absolute_index: i32 = Histogram::get_layout(&self).map_to_bin_index(value);
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/histograms/dynamic_histogram.rs:60:46
   |
60 |         let mask: i64 = Self::get_count_mask(self.mode);
   |                                              ^^^^^^^^^
   |                                              |
   |                                              expected `i32`, found `i8`
   |                                              help: you can convert an `i8` to an `i32`: `self.mode.into()`

error[E0609]: no field `total_count` on type `&DynamicHistogram`
  --> src/histograms/dynamic_histogram.rs:62:21
   |
62 |             if self.total_count + count >= 0 {
   |                     ^^^^^^^^^^^ unknown field
   |
   = note: available fields are: `counts`, `mode`, `number_of_unused_counts`, `index_offset`, `histogram_type`

error[E0609]: no field `total_count` on type `&DynamicHistogram`
  --> src/histograms/dynamic_histogram.rs:63:22
   |
63 |                 self.total_count += count;
   |                      ^^^^^^^^^^^ unknown field
   |
   = note: available fields are: `counts`, `mode`, `number_of_unused_counts`, `index_offset`, `histogram_type`

error[E0308]: mismatched types
  --> src/histograms/dynamic_histogram.rs:65:50
   |
65 |                 if array_idx >= 0 && array_idx < self.counts.len() {
   |                                                  ^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
   |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
   |
65 |                 if array_idx >= 0 && array_idx < self.counts.len().try_into().unwrap() {
   |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: the type `[i64]` cannot be indexed by `i32`
  --> src/histograms/dynamic_histogram.rs:66:42
   |
66 |                     let old_value: i64 = self.counts[array_idx];
   |                                          ^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`
   |
   = help: the trait `SliceIndex<[i64]>` is not implemented for `i32`
   = note: required because of the requirements on the impl of `Index<i32>` for `Vec<i64>`

error[E0277]: the type `[i64]` cannot be indexed by `i32`
  --> src/histograms/dynamic_histogram.rs:68:21
   |
68 |                     self.counts[array_idx] += count << bit_offset;
   |                     ^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`
   |
   = help: the trait `SliceIndex<[i64]>` is not implemented for `i32`
   = note: required because of the requirements on the impl of `Index<i32>` for `Vec<i64>`

error[E0277]: the type `[i64]` cannot be indexed by `i32`
  --> src/histograms/dynamic_histogram.rs:70:25
   |
70 |                         self.counts[array_idx] = old_value;
   |                         ^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`
   |
   = help: the trait `SliceIndex<[i64]>` is not implemented for `i32`
   = note: required because of the requirements on the impl of `Index<i32>` for `Vec<i64>`

error[E0308]: mismatched types
  --> src/histograms/dynamic_histogram.rs:77:59
   |
77 |                 return Err(DynaHistError::ArithmeticError(Self::OVERFLOW_MSG));
   |                                                           ^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`
   |                                                           |
   |                                                           expected struct `String`, found `&str`

error[E0308]: mismatched types
  --> src/histograms/dynamic_histogram.rs:77:24
   |
55 |     fn add_values(&self, value: f64, count: i64) -> DynamicHistogram {
   |                                                     ---------------- expected `DynamicHistogram` because of return type
...
77 |                 return Err(DynaHistError::ArithmeticError(Self::OVERFLOW_MSG));
   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `DynamicHistogram`, found enum `Result`
   |
   = note: expected struct `DynamicHistogram`
                found enum `Result<_, DynaHistError>`

error[E0308]: mismatched types
  --> src/histograms/dynamic_histogram.rs:81:62
   |
81 |             return Err(DynaHistError::IllegalArgumentError { source });
   |                                                              ^^^^^^ expected struct `std::io::Error`, found struct `String`

error[E0609]: no field `total_count` on type `&DynamicHistogram`
  --> src/histograms/dynamic_histogram.rs:90:18
   |
90 |             self.total_count -= count;
   |                  ^^^^^^^^^^^ unknown field
   |
   = note: available fields are: `counts`, `mode`, `number_of_unused_counts`, `index_offset`, `histogram_type`

error[E0308]: mismatched types
  --> src/histograms/dynamic_histogram.rs:92:25
   |
92 |                 source: Self::NAN_VALUE_MSG,
   |                         ^^^^^^^^^^^^^^^^^^^ expected struct `std::io::Error`, found `&str`

error[E0308]: mismatched types
  --> src/histograms/dynamic_histogram.rs:91:20
   |
86 |       fn try_to_extend_and_increase_count(&self, absolute_index: i32, count: i64, value: f64) {
   |                                                                                               - expected `()` because of default return type
...
91 |               return Err(DynaHistError::IllegalArgumentError {
   |  ____________________^
92 | |                 source: Self::NAN_VALUE_MSG,
93 | |             });
   | |______________^ expected `()`, found enum `Result`
   |
   = note: expected unit type `()`
                   found enum `Result<_, DynaHistError>`

error[E0308]: mismatched types
  --> src/histograms/dynamic_histogram.rs:99:46
   |
99 |         let mask: i64 = Self::get_count_mask(mode) << bit_offset;
   |                                              ^^^^
   |                                              |
   |                                              expected `i32`, found `i8`
   |                                              help: you can convert an `i8` to an `i32`: `mode.into()`

error[E0277]: the type `[i64]` cannot be indexed by `i32`
   --> src/histograms/dynamic_histogram.rs:103:9
    |
103 |         counts[array_idx] = (counts[array_idx] & delete_mask) | set_mask;
    |         ^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`
    |
    = help: the trait `SliceIndex<[i64]>` is not implemented for `i32`
    = note: required because of the requirements on the impl of `Index<i32>` for `Vec<i64>`

error[E0277]: the type `[i64]` cannot be indexed by `i32`
   --> src/histograms/dynamic_histogram.rs:103:30
    |
103 |         counts[array_idx] = (counts[array_idx] & delete_mask) | set_mask;
    |                              ^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`
    |
    = help: the trait `SliceIndex<[i64]>` is not implemented for `i32`
    = note: required because of the requirements on the impl of `Index<i32>` for `Vec<i64>`

error[E0308]: mismatched types
   --> src/histograms/dynamic_histogram.rs:111:47
    |
111 |         return (counts.len() << (6 - mode)) - number_of_unused_counts;
    |                                               ^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `i8`

error[E0308]: mismatched types
   --> src/histograms/dynamic_histogram.rs:111:16
    |
110 |     fn get_num_counters(counts: &Vec<i64>, number_of_unused_counts: i8, mode: i8) -> i32 {
    |                                                                                      --- expected `i32` because of return type
111 |         return (counts.len() << (6 - mode)) - number_of_unused_counts;
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
111 |         return ((counts.len() << (6 - mode)) - number_of_unused_counts).try_into().unwrap();
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: cannot subtract `i8` from `usize`
   --> src/histograms/dynamic_histogram.rs:111:45
    |
111 |         return (counts.len() << (6 - mode)) - number_of_unused_counts;
    |                                             ^ no implementation for `usize - i8`
    |
    = help: the trait `Sub<i8>` is not implemented for `usize`

error[E0277]: the type `[i64]` cannot be indexed by `i32`
   --> src/histograms/dynamic_histogram.rs:129:26
    |
129 |         let value: i64 = counts[array_idx];
    |                          ^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`
    |
    = help: the trait `SliceIndex<[i64]>` is not implemented for `i32`
    = note: required because of the requirements on the impl of `Index<i32>` for `Vec<i64>`

error[E0308]: mismatched types
   --> src/histograms/dynamic_histogram.rs:131:36
    |
131 |             & Self::get_count_mask(mode);
    |                                    ^^^^
    |                                    |
    |                                    expected `i32`, found `i8`
    |                                    help: you can convert an `i8` to an `i32`: `mode.into()`

error[E0308]: mismatched types
   --> src/histograms/dynamic_histogram.rs:141:21
    |
141 |             counts: Self::EMPTY_COUNTS,
    |                     ^^^^^^^^^^^^^^^^^^ expected `i64`, found `i32`
    |
    = note: expected struct `Vec<i64>`
               found struct `Vec<i32>`

error[E0308]: mismatched types
   --> src/histograms/dynamic_histogram.rs:142:27
    |
142 |             index_offset: layout.get_underflow_bin_index() + 1,
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`

error[E0034]: multiple applicable items in scope
   --> src/histograms/dynamic_histogram.rs:149:35
    |
149 |         if absolute_index <= self.get_layout().get_underflow_bin_index() {
    |                                   ^^^^^^^^^^ multiple `get_layout` found
    |
note: candidate #1 is defined in an impl of the trait `AbstractHistogram` for the type `DynamicHistogram`
   --> src/histograms/abstract_histogram.rs:374:5
    |
374 |     fn get_layout(&self) -> Sketch {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl of the trait `Histogram` for the type `DynamicHistogram`
   --> src/histograms/histogram.rs:28:5
    |
28  |     fn get_layout(&self) -> &Self::L {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
149 |         if absolute_index <= AbstractHistogram::get_layout(&self).get_underflow_bin_index() {
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
149 |         if absolute_index <= Histogram::get_layout(&self).get_underflow_bin_index() {
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/dynamic_histogram.rs:151:42
    |
151 |         } else if absolute_index >= self.get_layout().get_overflow_bin_index() {
    |                                          ^^^^^^^^^^ multiple `get_layout` found
    |
note: candidate #1 is defined in an impl of the trait `AbstractHistogram` for the type `DynamicHistogram`
   --> src/histograms/abstract_histogram.rs:374:5
    |
374 |     fn get_layout(&self) -> Sketch {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl of the trait `Histogram` for the type `DynamicHistogram`
   --> src/histograms/histogram.rs:28:5
    |
28  |     fn get_layout(&self) -> &Self::L {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
151 |         } else if absolute_index >= AbstractHistogram::get_layout(&self).get_overflow_bin_index() {
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
151 |         } else if absolute_index >= Histogram::get_layout(&self).get_overflow_bin_index() {
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `get_num_counters` found for reference `&DynamicHistogram` in the current scope
   --> src/histograms/dynamic_histogram.rs:158:28
    |
158 |                     < self.get_num_counters(&self.counts, self.number_of_unused_counts, self.mode)
    |                       -----^^^^^^^^^^^^^^^^
    |                       |    |
    |                       |    this is an associated function, not a method
    |                       help: use associated function syntax instead: `DynamicHistogram::get_num_counters`
    |
    = note: found the following associated functions; to be used as methods, functions must have a `self` parameter
note: the candidate is defined in an impl for the type `DynamicHistogram`
   --> src/histograms/dynamic_histogram.rs:110:5
    |
110 |     fn get_num_counters(counts: &Vec<i64>, number_of_unused_counts: i8, mode: i8) -> i32 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/dynamic_histogram.rs:160:34
    |
160 |                 new_count = self.get_count(&self.counts, relative_index, self.mode) + count;
    |                                  ^^^^^^^^^ multiple `get_count` found
    |
note: candidate #1 is defined in an impl of the trait `Histogram` for the type `DynamicHistogram`
   --> src/histograms/histogram.rs:122:5
    |
122 |     fn get_count(&self, bin_index: i32) -> i64;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl of the trait `AbstractMutableHistogram` for the type `DynamicHistogram`
   --> src/histograms/dynamic_histogram.rs:127:5
    |
127 |     fn get_count(counts: &Vec<i64>, relative_idx: i32, mode: i8) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
160 |                 new_count = Histogram::get_count(&self, &self.counts, relative_index, self.mode) + count;
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
160 |                 new_count = AbstractMutableHistogram::get_count(&self, &self.counts, relative_index, self.mode) + count;
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `determine_required_mode` found for reference `&DynamicHistogram` in the current scope
   --> src/histograms/dynamic_histogram.rs:167:23
    |
167 |                 &self.determine_required_mode(new_count),
    |                       ^^^^^^^^^^^^^^^^^^^^^^^ this is an associated function, not a method
    |
    = note: found the following associated functions; to be used as methods, functions must have a `self` parameter
note: the candidate is defined in the trait `AbstractMutableHistogram`
   --> src/histograms/abstract_mutable_histogram.rs:300:5
    |
300 |     fn determine_required_mode(value: i64) -> i8 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
note: `AbstractMutableHistogram` defines an item `determine_required_mode`, perhaps you need to implement it
   --> src/histograms/abstract_mutable_histogram.rs:184:1
    |
184 | pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: use associated function syntax instead
    |
167 |                 &DynamicHistogram::determine_required_mode(new_count),
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for the candidate
    |
167 |                 &AbstractMutableHistogram::determine_required_mode(&self, new_count),
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `set_count` found for reference `&DynamicHistogram` in the current scope
   --> src/histograms/dynamic_histogram.rs:169:18
    |
169 |             self.set_count(
    |             -----^^^^^^^^^
    |             |    |
    |             |    this is an associated function, not a method
    |             help: use associated function syntax instead: `DynamicHistogram::set_count`
    |
    = note: found the following associated functions; to be used as methods, functions must have a `self` parameter
note: the candidate is defined in an impl for the type `DynamicHistogram`
   --> src/histograms/dynamic_histogram.rs:96:5
    |
96  |     fn set_count(counts: &Vec<i64>, relative_idx: i32, mode: i8, new_value: i64) {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/dynamic_histogram.rs:185:56
    |
185 |         Self::check_argument(min_absolute_index > self.get_layout().get_underflow_bin_index());
    |                                                        ^^^^^^^^^^ multiple `get_layout` found
    |
note: candidate #1 is defined in an impl of the trait `AbstractHistogram` for the type `DynamicHistogram`
   --> src/histograms/abstract_histogram.rs:374:5
    |
374 |     fn get_layout(&self) -> Sketch {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl of the trait `Histogram` for the type `DynamicHistogram`
   --> src/histograms/histogram.rs:28:5
    |
28  |     fn get_layout(&self) -> &Self::L {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
185 |         Self::check_argument(min_absolute_index > AbstractHistogram::get_layout(&self).get_underflow_bin_index());
    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
185 |         Self::check_argument(min_absolute_index > Histogram::get_layout(&self).get_underflow_bin_index());
    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/dynamic_histogram.rs:186:56
    |
186 |         Self::check_argument(max_absolute_index < self.get_layout().get_overflow_bin_index());
    |                                                        ^^^^^^^^^^ multiple `get_layout` found
    |
note: candidate #1 is defined in an impl of the trait `AbstractHistogram` for the type `DynamicHistogram`
   --> src/histograms/abstract_histogram.rs:374:5
    |
374 |     fn get_layout(&self) -> Sketch {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl of the trait `Histogram` for the type `DynamicHistogram`
   --> src/histograms/histogram.rs:28:5
    |
28  |     fn get_layout(&self) -> &Self::L {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
186 |         Self::check_argument(max_absolute_index < AbstractHistogram::get_layout(&self).get_overflow_bin_index());
    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
186 |         Self::check_argument(max_absolute_index < Histogram::get_layout(&self).get_overflow_bin_index());
    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/dynamic_histogram.rs:197:26
    |
197 |                     self.get_layout().get_underflow_bin_index() + 1,
    |                          ^^^^^^^^^^ multiple `get_layout` found
    |
note: candidate #1 is defined in an impl of the trait `AbstractHistogram` for the type `DynamicHistogram`
   --> src/histograms/abstract_histogram.rs:374:5
    |
374 |     fn get_layout(&self) -> Sketch {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl of the trait `Histogram` for the type `DynamicHistogram`
   --> src/histograms/histogram.rs:28:5
    |
28  |     fn get_layout(&self) -> &Self::L {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
197 |                     AbstractHistogram::get_layout(&self).get_underflow_bin_index() + 1,
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
197 |                     Histogram::get_layout(&self).get_underflow_bin_index() + 1,
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: cannot multiply `i32` by `f64`
   --> src/histograms/dynamic_histogram.rs:201:79
    |
201 | ...                   current_min_absolute_index - current_num_counters * Self::GROW_FACTOR,
    |                                                                         ^ no implementation for `i32 * f64`
    |
    = help: the trait `Mul<f64>` is not implemented for `i32`

error[E0308]: mismatched types
   --> src/histograms/dynamic_histogram.rs:198:21
    |
198 | /                     &std::cmp::min(
199 | |                         min_absolute_index,
200 | |                         num::Float::ceil(
201 | |                             current_min_absolute_index - current_num_counters * Self::GROW_FACTOR,
202 | |                         ) as i32,
203 | |                     ),
    | |_____________________^ expected `i32`, found `&i32`
    |
help: consider removing the borrow
    |
198 |                     std::cmp::min(
    |                    --

error[E0034]: multiple applicable items in scope
   --> src/histograms/dynamic_histogram.rs:211:26
    |
211 |                     self.get_layout().get_overflow_bin_index() - 1,
    |                          ^^^^^^^^^^ multiple `get_layout` found
    |
note: candidate #1 is defined in an impl of the trait `AbstractHistogram` for the type `DynamicHistogram`
   --> src/histograms/abstract_histogram.rs:374:5
    |
374 |     fn get_layout(&self) -> Sketch {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl of the trait `Histogram` for the type `DynamicHistogram`
   --> src/histograms/histogram.rs:28:5
    |
28  |     fn get_layout(&self) -> &Self::L {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
211 |                     AbstractHistogram::get_layout(&self).get_overflow_bin_index() - 1,
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
211 |                     Histogram::get_layout(&self).get_overflow_bin_index() - 1,
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: cannot multiply `i32` by `f64`
   --> src/histograms/dynamic_histogram.rs:215:79
    |
215 | ...                   current_max_absolute_index + current_num_counters * Self::GROW_FACTOR,
    |                                                                         ^ no implementation for `i32 * f64`
    |
    = help: the trait `Mul<f64>` is not implemented for `i32`

error[E0308]: mismatched types
   --> src/histograms/dynamic_histogram.rs:212:21
    |
212 | /                     &std::cmp::max(
213 | |                         max_absolute_index,
214 | |                         num::Float::ceil(
215 | |                             current_max_absolute_index + current_num_counters * Self::GROW_FACTOR,
216 | |                         ) as i32,
217 | |                     ),
    | |_____________________^ expected `i32`, found `&i32`
    |
help: consider removing the borrow
    |
212 |                     std::cmp::max(
    |                    --

error[E0308]: mismatched types
   --> src/histograms/dynamic_histogram.rs:239:35
    |
239 |             self.counts = vec![0; Self::get_long_array_size(new_num_counters, new_mode)];
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `i32`
    |
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
239 |             self.counts = vec![0; Self::get_long_array_size(new_num_counters, new_mode).try_into().unwrap()];
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/dynamic_histogram.rs:248:36
    |
248 | ...                   &Self::get_count(&old_counts, i, self.mode),
    |                              ^^^^^^^^^ multiple `get_count` found
    |
note: candidate #1 is defined in an impl of the trait `Histogram` for the type `DynamicHistogram`
   --> src/histograms/histogram.rs:122:5
    |
122 |     fn get_count(&self, bin_index: i32) -> i64;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl of the trait `AbstractMutableHistogram` for the type `DynamicHistogram`
   --> src/histograms/dynamic_histogram.rs:127:5
    |
127 |     fn get_count(counts: &Vec<i64>, relative_idx: i32, mode: i8) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
248 |                             &Histogram::get_count(&old_counts, i, self.mode),
    |                              ^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
248 |                             &AbstractMutableHistogram::get_count(&old_counts, i, self.mode),
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/dynamic_histogram.rs:256:44
    |
256 |                 (self.counts.len() << 6) - (new_num_counters << new_mode);
    |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `i32`

error[E0308]: mismatched types
   --> src/histograms/dynamic_histogram.rs:256:17
    |
255 |             let number_of_unused_bits: i32 =
    |                                        --- expected due to this
256 |                 (self.counts.len() << 6) - (new_num_counters << new_mode);
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`
    |
help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit
    |
256 |                 ((self.counts.len() << 6) - (new_num_counters << new_mode)).try_into().unwrap();
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: cannot subtract `i32` from `usize`
   --> src/histograms/dynamic_histogram.rs:256:42
    |
256 |                 (self.counts.len() << 6) - (new_num_counters << new_mode);
    |                                          ^ no implementation for `usize - i32`
    |
    = help: the trait `Sub<i32>` is not implemented for `usize`

error[E0308]: mismatched types
   --> src/histograms/dynamic_histogram.rs:271:20
    |
269 |     ) -> Self {
    |          ---- expected `DynamicHistogram` because of return type
270 |         if histogram.is_empty() {
271 |             return self;
    |                    ^^^^ expected struct `DynamicHistogram`, found `&DynamicHistogram`

error[E0034]: multiple applicable items in scope
   --> src/histograms/dynamic_histogram.rs:273:17
    |
273 |         if self.get_layout().equals(&histogram.get_layout()) {
    |                 ^^^^^^^^^^ multiple `get_layout` found
    |
note: candidate #1 is defined in an impl of the trait `AbstractHistogram` for the type `DynamicHistogram`
   --> src/histograms/abstract_histogram.rs:374:5
    |
374 |     fn get_layout(&self) -> Sketch {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl of the trait `Histogram` for the type `DynamicHistogram`
   --> src/histograms/histogram.rs:28:5
    |
28  |     fn get_layout(&self) -> &Self::L {}
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
273 |         if AbstractHistogram::get_layout(&self).equals(&histogram.get_layout()) {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
273 |         if Histogram::get_layout(&self).equals(&histogram.get_layout()) {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0609]: no field `total_count` on type `&DynamicHistogram`
   --> src/histograms/dynamic_histogram.rs:274:18
    |
274 |             self.total_count += histogram.get_total_count();
    |                  ^^^^^^^^^^^ unknown field
    |
    = note: available fields are: `counts`, `mode`, `number_of_unused_counts`, `index_offset`, `histogram_type`

error[E0609]: no field `total_count` on type `&DynamicHistogram`
   --> src/histograms/dynamic_histogram.rs:275:21
    |
275 |             if self.total_count < 0 {
    |                     ^^^^^^^^^^^ unknown field
    |
    = note: available fields are: `counts`, `mode`, `number_of_unused_counts`, `index_offset`, `histogram_type`

error[E0609]: no field `total_count` on type `&DynamicHistogram`
   --> src/histograms/dynamic_histogram.rs:276:22
    |
276 |                 self.total_count -= histogram.get_total_count();
    |                      ^^^^^^^^^^^ unknown field
    |
    = note: available fields are: `counts`, `mode`, `number_of_unused_counts`, `index_offset`, `histogram_type`

error[E0308]: mismatched types
   --> src/histograms/dynamic_histogram.rs:277:59
    |
277 |                 return Err(DynaHistError::ArithmeticError(Self::OVERFLOW_MSG));
    |                                                           ^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`
    |                                                           |
    |                                                           expected struct `String`, found `&str`

error[E0308]: mismatched types
   --> src/histograms/dynamic_histogram.rs:279:34
    |
279 |             self.updates_min_max(&histogram.get_min(), &histogram.get_max());
    |                                  ^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `&f64`
    |
help: consider removing the borrow
    |
279 |             self.updates_min_max(histogram.get_min(), &histogram.get_max());
    |                                 --

error[E0308]: mismatched types
   --> src/histograms/dynamic_histogram.rs:279:56
    |
279 |             self.updates_min_max(&histogram.get_min(), &histogram.get_max());
    |                                                        ^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `&f64`
    |
help: consider removing the borrow
    |
279 |             self.updates_min_max(&histogram.get_min(), histogram.get_max());
    |                                                       --

error[E0308]: mismatched types
   --> src/histograms/dynamic_histogram.rs:280:44
    |
280 |             self.increment_underflow_count(&histogram.get_underflow_count());
    |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i64`, found `&i64`
    |
help: consider removing the borrow
    |
280 |             self.increment_underflow_count(histogram.get_underflow_count());
    |                                           --

error[E0308]: mismatched types
   --> src/histograms/dynamic_histogram.rs:281:43
    |
281 |             self.increment_overflow_count(&histogram.get_overflow_count());
    |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i64`, found `&i64`
    |
help: consider removing the borrow
    |
281 |             self.increment_overflow_count(histogram.get_overflow_count());
    |                                          --

error[E0609]: no field `histogram_type` on type `impl Histogram`
   --> src/histograms/dynamic_histogram.rs:295:34
    |
295 |                     if histogram.histogram_type == "DynamicHistogram" {
    |                                  ^^^^^^^^^^^^^^

error[E0599]: no method named `mode` found for type parameter `impl Histogram` in the current scope
   --> src/histograms/dynamic_histogram.rs:296:75
    |
296 |                         desired_mode = std::cmp::max(self.mode, histogram.mode()).try_into()?;
    |                                                                           ^^^^ method not found in `impl Histogram`
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following traits define an item `mode`, perhaps you need to restrict type parameter `impl Histogram` with one of them:
    |
267 |         histogram: impl Histogram + PermissionsExt,
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
267 |         histogram: impl Histogram + OpenOptionsExt,
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
267 |         histogram: impl Histogram + std::os::unix::fs::MetadataExt,
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
267 |         histogram: impl Histogram + DirBuilderExt,
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `try_into` found for type `i8` in the current scope
   --> src/histograms/dynamic_histogram.rs:296:83
    |
296 |                         desired_mode = std::cmp::max(self.mode, histogram.mode()).try_into()?;
    |                                                                                   ^^^^^^^^ method not found in `i8`
    |
   ::: /home/hedge/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:397:8
    |
397 |     fn try_into(self) -> Result<T, Self::Error>;
    |        -------- the method is available for `i8` here
    |
    = help: items from traits can only be used if the trait is in scope
    = note: the following trait is implemented but not in scope; perhaps add a `use` for it:
            `use std::convert::TryInto;`

error[E0308]: mismatched types
   --> src/histograms/dynamic_histogram.rs:301:25
    |
301 |                         &first_bin.get_bin_index(),
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&i32`
    |
help: consider removing the borrow
    |
301 |                         first_bin.get_bin_index(),
    |                        --

error[E0308]: mismatched types
   --> src/histograms/dynamic_histogram.rs:302:25
    |
302 |                         &last_bin.get_bin_index(),
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&i32`
    |
help: consider removing the borrow
    |
302 |                         last_bin.get_bin_index(),
    |                        --

error[E0308]: mismatched types
   --> src/histograms/dynamic_histogram.rs:306:59
    |
306 |                 let mut limit: i64 = Self::get_count_mask(self.mode);
    |                                                           ^^^^^^^^^
    |                                                           |
    |                                                           expected `i32`, found `i8`
    |                                                           help: you can convert an `i8` to an `i32`: `self.mode.into()`

error[E0034]: multiple applicable items in scope
   --> src/histograms/dynamic_histogram.rs:310:31
    |
310 |                         Self::get_count(&self.counts, relative_index, self.mode)
    |                               ^^^^^^^^^ multiple `get_count` found
    |
note: candidate #1 is defined in an impl of the trait `Histogram` for the type `DynamicHistogram`
   --> src/histograms/histogram.rs:122:5
    |
122 |     fn get_count(&self, bin_index: i32) -> i64;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl of the trait `AbstractMutableHistogram` for the type `DynamicHistogram`
   --> src/histograms/dynamic_histogram.rs:127:5
    |
127 |     fn get_count(counts: &Vec<i64>, relative_idx: i32, mode: i8) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
310 |                         Histogram::get_count(&self.counts, relative_index, self.mode)
    |                         ^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
310 |                         AbstractMutableHistogram::get_count(&self.counts, relative_index, self.mode)
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/dynamic_histogram.rs:314:29
    |
314 | ...                   &first_bin.get_bin_index(),
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&i32`
    |
help: consider removing the borrow
    |
314 |                             first_bin.get_bin_index(),
    |                            --

error[E0308]: mismatched types
   --> src/histograms/dynamic_histogram.rs:315:29
    |
315 | ...                   &first_bin.get_bin_index(),
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&i32`
    |
help: consider removing the borrow
    |
315 |                             first_bin.get_bin_index(),
    |                            --

error[E0599]: no method named `determine_required_mode` found for reference `&DynamicHistogram` in the current scope
   --> src/histograms/dynamic_histogram.rs:316:35
    |
316 | ...                   &self.determine_required_mode(merged_count),
    |                             ^^^^^^^^^^^^^^^^^^^^^^^ this is an associated function, not a method
    |
    = note: found the following associated functions; to be used as methods, functions must have a `self` parameter
note: the candidate is defined in the trait `AbstractMutableHistogram`
   --> src/histograms/abstract_mutable_histogram.rs:300:5
    |
300 |     fn determine_required_mode(value: i64) -> i8 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
note: `AbstractMutableHistogram` defines an item `determine_required_mode`, perhaps you need to implement it
   --> src/histograms/abstract_mutable_histogram.rs:184:1
    |
184 | pub trait AbstractMutableHistogram: AbstractHistogram + Histogram + Preconditions {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: use associated function syntax instead
    |
316 |                             &DynamicHistogram::determine_required_mode(merged_count),
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for the candidate
    |
316 |                             &AbstractMutableHistogram::determine_required_mode(&self, merged_count),
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/dynamic_histogram.rs:318:54
    |
318 |                         limit = Self::get_count_mask(self.mode);
    |                                                      ^^^^^^^^^
    |                                                      |
    |                                                      expected `i32`, found `i8`
    |                                                      help: you can convert an `i8` to an `i32`: `self.mode.into()`

error[E0599]: no method named `set_count` found for reference `&DynamicHistogram` in the current scope
   --> src/histograms/dynamic_histogram.rs:320:26
    |
320 |                     self.set_count(&self.counts, relative_index, self.mode, merged_count);
    |                     -----^^^^^^^^^
    |                     |    |
    |                     |    this is an associated function, not a method
    |                     help: use associated function syntax instead: `DynamicHistogram::set_count`
    |
    = note: found the following associated functions; to be used as methods, functions must have a `self` parameter
note: the candidate is defined in an impl for the type `DynamicHistogram`
   --> src/histograms/dynamic_histogram.rs:96:5
    |
96  |     fn set_count(counts: &Vec<i64>, relative_idx: i32, mode: i8, new_value: i64) {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/dynamic_histogram.rs:328:18
    |
328 |             self.add_histogram_from_estimator(histogram, value_estimator);
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ multiple `add_histogram_from_estimator` found
    |
note: candidate #1 is defined in an impl of the trait `Histogram` for the type `DynamicHistogram`
   --> src/histograms/histogram.rs:279:5
    |
279 |     fn add_histogram_from_estimator(&self, histogram: &Self, value_estimator: &Self::V) -> Self;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl of the trait `AbstractMutableHistogram` for the type `DynamicHistogram`
   --> src/histograms/dynamic_histogram.rs:265:5
    |
265 | /     fn add_histogram_from_estimator(
266 | |         &self,
267 | |         histogram: impl Histogram,
268 | |         value_estimator: impl ValueEstimation,
269 | |     ) -> Self {
    | |_____________^
help: disambiguate the associated function for candidate #1
    |
328 |             Histogram::add_histogram_from_estimator(&self, histogram, value_estimator);
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
328 |             AbstractMutableHistogram::add_histogram_from_estimator(&self, histogram, value_estimator);
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0061]: this function takes 1 argument but 0 arguments were supplied
   --> src/histograms/dynamic_histogram.rs:334:93
    |
334 | ...   return (Self::ESTIMATED_REFERENCE_FOOTPRINT_IN_BYTES + (self.counts.len() as i64) * i64::to_be_bytes() + Self::ESTIMATED_OBJECT_HEA...
    |                                                                                           ^^^^^^^^^^^^^^^^-- supplied 0 arguments
    |                                                                                           |
    |                                                                                           expected 1 argument
    |
note: associated function defined here
   --> /home/hedge/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/mod.rs:113:5
    |
113 | /     int_impl! { i64, i64, u64, 64, 63, -9223372036854775808, 9223372036854775807, 12,
114 | |     "0xaa00000000006e1", "0x6e10aa", "0x1234567890123456", "0x5634129078563412",
115 | |     "0x6a2c48091e6a2c48", "[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]",
116 | |     "[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]", "", "" }
    | |________________________________________________________________^
    = note: this error originates in the macro `int_impl` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: cannot multiply `i64` by `[u8; 8]`
   --> src/histograms/dynamic_histogram.rs:334:91
    |
334 | ...   return (Self::ESTIMATED_REFERENCE_FOOTPRINT_IN_BYTES + (self.counts.len() as i64) * i64::to_be_bytes() + Self::ESTIMATED_OBJECT_HEA...
    |                                                                                         ^ no implementation for `i64 * [u8; 8]`
    |
    = help: the trait `Mul<[u8; 8]>` is not implemented for `i64`

error[E0061]: this function takes 1 argument but 0 arguments were supplied
   --> src/histograms/dynamic_histogram.rs:335:9
    |
335 |         i32::to_be_bytes()) + // mode
    |         ^^^^^^^^^^^^^^^^-- supplied 0 arguments
    |         |
    |         expected 1 argument
    |
note: associated function defined here
   --> /home/hedge/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/mod.rs:106:5
    |
106 | /     int_impl! { i32, i32, u32, 32, 31, -2147483648, 2147483647, 8, "0x10000b3", "0xb301",
107 | |     "0x12345678", "0x78563412", "0x1e6a2c48", "[0x78, 0x56, 0x34, 0x12]",
108 | |     "[0x12, 0x34, 0x56, 0x78]", "", "" }
    | |________________________________________^
    = note: this error originates in the macro `int_impl` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0061]: this function takes 1 argument but 0 arguments were supplied
   --> src/histograms/dynamic_histogram.rs:336:9
    |
336 |         i8::to_be_bytes() +   // number_of_unused_counts
    |         ^^^^^^^^^^^^^^^-- supplied 0 arguments
    |         |
    |         expected 1 argument
    |
note: associated function defined here
   --> /home/hedge/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/mod.rs:94:5
    |
94  | /     int_impl! { i8, i8, u8, 8, 7, -128, 127, 2, "-0x7e", "0xa", "0x12", "0x12", "0x48",
95  | |     "[0x12]", "[0x12]", "", "" }
    | |________________________________^
    = note: this error originates in the macro `int_impl` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0061]: this function takes 1 argument but 0 arguments were supplied
   --> src/histograms/dynamic_histogram.rs:337:9
    |
337 |         i8::to_be_bytes() +   // index_offset
    |         ^^^^^^^^^^^^^^^-- supplied 0 arguments
    |         |
    |         expected 1 argument
    |
note: associated function defined here
   --> /home/hedge/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/mod.rs:94:5
    |
94  | /     int_impl! { i8, i8, u8, 8, 7, -128, 127, 2, "-0x7e", "0xa", "0x12", "0x12", "0x48",
95  | |     "[0x12]", "[0x12]", "", "" }
    | |________________________________^
    = note: this error originates in the macro `int_impl` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0061]: this function takes 1 argument but 0 arguments were supplied
   --> src/histograms/dynamic_histogram.rs:338:9
    |
338 |         i32::to_be_bytes() + self.get_estimated_footprint_in_bytes();
    |         ^^^^^^^^^^^^^^^^-- supplied 0 arguments
    |         |
    |         expected 1 argument
    |
note: associated function defined here
   --> /home/hedge/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/mod.rs:106:5
    |
106 | /     int_impl! { i32, i32, u32, 32, 31, -2147483648, 2147483647, 8, "0x10000b3", "0xb301",
107 | |     "0x12345678", "0x78563412", "0x1e6a2c48", "[0x78, 0x56, 0x34, 0x12]",
108 | |     "[0x12, 0x34, 0x56, 0x78]", "", "" }
    | |________________________________________^
    = note: this error originates in the macro `int_impl` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0034]: multiple applicable items in scope
   --> src/histograms/dynamic_histogram.rs:338:35
    |
338 |         i32::to_be_bytes() + self.get_estimated_footprint_in_bytes();
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ multiple `get_estimated_footprint_in_bytes` found
    |
note: candidate #1 is defined in an impl of the trait `AbstractHistogram` for the type `DynamicHistogram`
   --> src/histograms/abstract_histogram.rs:413:5
    |
413 |     fn get_estimated_footprint_in_bytes(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl of the trait `Histogram` for the type `DynamicHistogram`
   --> src/histograms/histogram.rs:333:5
    |
333 |     fn get_estimated_footprint_in_bytes(&self) -> i64;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #3 is defined in an impl of the trait `AbstractMutableHistogram` for the type `DynamicHistogram`
   --> src/histograms/dynamic_histogram.rs:333:5
    |
333 |     fn get_estimated_footprint_in_bytes(&self) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
338 |         i32::to_be_bytes() + AbstractHistogram::get_estimated_footprint_in_bytes(&self);
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
338 |         i32::to_be_bytes() + Histogram::get_estimated_footprint_in_bytes(&self);
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #3
    |
338 |         i32::to_be_bytes() + AbstractMutableHistogram::get_estimated_footprint_in_bytes(&self);
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0034]: multiple applicable items in scope
   --> src/histograms/dynamic_histogram.rs:351:22
    |
351 |         return Self::get_count(&self.counts, bin_index - self.index_offset, self.mode);
    |                      ^^^^^^^^^ multiple `get_count` found
    |
note: candidate #1 is defined in an impl of the trait `Histogram` for the type `DynamicHistogram`
   --> src/histograms/histogram.rs:122:5
    |
122 |     fn get_count(&self, bin_index: i32) -> i64;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl of the trait `AbstractMutableHistogram` for the type `DynamicHistogram`
   --> src/histograms/dynamic_histogram.rs:127:5
    |
127 |     fn get_count(counts: &Vec<i64>, relative_idx: i32, mode: i8) -> i64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #1
    |
351 |         return Histogram::get_count(&self.counts, bin_index - self.index_offset, self.mode);
    |                ^^^^^^^^^^^^^^^^^^^^
help: disambiguate the associated function for candidate #2
    |
351 |         return AbstractMutableHistogram::get_count(&self.counts, bin_index - self.index_offset, self.mode);
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/histograms/abstract_histogram.rs:289:59
    |
289 |       const INCOMPATIBLE_SERIAL_VERSION_MSG: &'static str = format!(
    |  ___________________________________________________________^
290 | |         "Incompatible serial versions! Expected version {} but was %d.",
291 | |         Self::SERIAL_VERSION_V0
292 | |     );
    | |_____^ expected `&str`, found struct `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

warning: unused import: `crate::Histogram`
 --> src/bins/abstract_bin.rs:7:5
  |
7 | use crate::Histogram;
  |     ^^^^^^^^^^^^^^^^

warning: unused import: `num::Float`
 --> src/bins/abstract_bin.rs:9:5
  |
9 | use num::Float;
  |     ^^^^^^^^^^

warning: unused import: `crate::seriate::deserialization::SeriateRead`
  --> src/seriate/mod.rs:14:5
   |
14 | use crate::seriate::deserialization::SeriateRead;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::seriate::serialization::SeriateWrite`
  --> src/seriate/mod.rs:16:5
   |
16 | use crate::seriate::serialization::SeriateWrite;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::quantiles::quantile_estimation::QuantileEstimation`
  --> src/histograms/abstract_histogram.rs:18:5
   |
18 | use crate::quantiles::quantile_estimation::QuantileEstimation;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::utilities::Preconditions`
  --> src/histograms/abstract_histogram.rs:22:5
   |
22 | use crate::utilities::Preconditions;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::quantiles::quantile_estimation::QuantileEstimation`
  --> src/histograms/abstract_mutable_histogram.rs:17:5
   |
17 | use crate::quantiles::quantile_estimation::QuantileEstimation;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::utilities::Algorithms`
  --> src/histograms/abstract_mutable_histogram.rs:21:5
   |
21 | use crate::utilities::Algorithms;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::quantiles::quantile_estimation::QuantileEstimation`
  --> src/histograms/fixed.rs:15:5
   |
15 | use crate::quantiles::quantile_estimation::QuantileEstimation;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::values::value_estimation::ValueEstimation`
  --> src/histograms/fixed.rs:19:5
   |
19 | use crate::values::value_estimation::ValueEstimation;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::histograms::abstract_mutable_histogram::AbstractMutableHistogram`
  --> src/histograms/preprocessed_histogram.rs:14:5
   |
14 | use crate::histograms::abstract_mutable_histogram::AbstractMutableHistogram;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::quantiles::quantile_estimation::QuantileEstimation`
  --> src/histograms/preprocessed_histogram.rs:16:5
   |
16 | use crate::quantiles::quantile_estimation::QuantileEstimation;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::utilities::Preconditions`
  --> src/histograms/preprocessed_histogram.rs:19:5
   |
19 | use crate::utilities::Preconditions;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::quantiles::quantile_estimation::QuantileEstimation`
  --> src/histograms/dynamic_histogram.rs:16:5
   |
16 | use crate::quantiles::quantile_estimation::QuantileEstimation;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Some errors have detailed explanations: E0034, E0038, E0046, E0049, E0053, E0061, E0069, E0107, E0186...
For more information about an error, try `rustc --explain E0034`.
warning: `masts` (lib) generated 45 warnings
error: could not compile `masts` due to 864 previous errors; 45 warnings emitted
